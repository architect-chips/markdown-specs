{
  "children": [
    {
      "html": "<h1>Precision Preservation</h1><p>Though most software-based DNN implementations are FP32-based, many studies have already shown that lower precision is sufficient for inference. As such, NVDLA chooses to support INT8/INT16/FP16 as a trade-off between precision and performance/area. At the same time, NVDLA adopts technologies to keep the precision loss under control. Below, we give a diagram with an overview of NVDLA's precision-preservation architecture.</p><img alt=\"Diagram illustrating the NVDLA precision-preservation architecture. The architecture is divided into four main stages: Convolution Core, SDP, PDP, and CDP. The Convolution Core uses MAC CELLS and includes a PRA (Precision Reduction Architecture) block. The SDP stage uses X and Y LUTs (Look-Up Tables) and includes converters and shifters. The PDP stage uses a Pooling block. The CDP stage uses an LUT and includes converters and shifters. The input data (In, Mean, Weight) and output data (DRAM) are shown, along with various precision control components like Convertors, LUTs, Truncates, and Shifters.\" src=\"3ad4d1734817fe2ac05fe8d4da4f68e8_img.jpg\"/><div class=\"img-description\" style=\"border: 1px solid #ccc; padding: 10px;\"><div class=\"img-alt\">Diagram illustrating the NVDLA precision-preservation architecture. The architecture is divided into four main stages: Convolution Core, SDP, PDP, and CDP. The Convolution Core uses MAC CELLS and includes a PRA (Precision Reduction Architecture) block. The SDP stage uses X and Y LUTs (Look-Up Tables) and includes converters and shifters. The PDP stage uses a Pooling block. The CDP stage uses an LUT and includes converters and shifters. The input data (In, Mean, Weight) and output data (DRAM) are shown, along with various precision control components like Convertors, LUTs, Truncates, and Shifters.</div></div><p>Fig. 31 - NVDLA precision-preservation architecture</p><p>In total, there are four types of approaches to precision control in the NVDLA pipeline:</p><h2><ul><li>Converter:</li></ul></h2><p>The formula for a converter in INT8 and INT16 is:</p><p><math display=\"block\">y = \\text{saturation\\_round}(x - \\text{offset}_{\\text{int}}) * \\text{scaling}_{\\text{int}} \\gg \\text{shifter}_{\\text{uint}}</math></p><p><i>offset</i>, <i>scaling</i>, and <i>shifter</i> are programmable registers to allow software to control the output dynamic range. Saturation is dependent on the number of output bits.</p><p>For INT8 and INT16, <i>offset</i> and <i>scaling</i> are treated as signed integers, and the exact number of bits is depends on the input operands. <i>shifter</i> is a 5 bits unsigned integer (always specifying a right shift); the rounding method used after the shift is to \u201cround half away from zero\u201d.</p><p>For FP16, the dynamic range that can be represented by FP16 representable is large, and so converter and shifter logic is not implemented in hardware.</p><p>The converter is able to keep the best possible precision even if input data are not symmetric to 0, or dynamic range is not <math>2^N</math>; NVDLA uses it to convert internal precision (high) to external (low, typically INT8/INT16/FP16).</p><h2><ul><li>Truncate:</li></ul></h2><p>Truncation is enabled for INT8/INT16 only. The formula for truncation is: <math>y = \\text{saturation\\_round}(x[\\text{msb} : \\text{lsb}])</math></p><p><i>lsb</i> is a programmable register; <i>msb</i> is defined as <math>\\text{lsb} + \\text{output\\_bits}</math>.</p>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/0/Page/0",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/0/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 0,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              159.0,
              26.0
            ],
            [
              159.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            159.0,
            43.0
          ],
          "section_hierarchy": {},
          "images": {}
        },
        {
          "id": "/page/0/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 0,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            43.0
          ],
          "section_hierarchy": {},
          "images": {}
        },
        {
          "id": "/page/0/SectionHeader/2",
          "block_type": "SectionHeader",
          "html": "<h1>Precision Preservation</h1>",
          "page": 0,
          "polygon": [
            [
              68.0,
              86.0
            ],
            [
              567.0,
              86.0
            ],
            [
              567.0,
              130.0
            ],
            [
              68.0,
              130.0
            ]
          ],
          "bbox": [
            68.0,
            86.0,
            567.0,
            130.0
          ],
          "section_hierarchy": {},
          "images": {}
        },
        {
          "id": "/page/0/Text/3",
          "block_type": "Text",
          "html": "<p>Though most software-based DNN implementations are FP32-based, many studies have already shown that lower precision is sufficient for inference. As such, NVDLA chooses to support INT8/INT16/FP16 as a trade-off between precision and performance/area. At the same time, NVDLA adopts technologies to keep the precision loss under control. Below, we give a diagram with an overview of NVDLA's precision-preservation architecture.</p>",
          "page": 0,
          "polygon": [
            [
              68.0,
              161.0
            ],
            [
              1060.0,
              161.0
            ],
            [
              1060.0,
              258.0
            ],
            [
              68.0,
              258.0
            ]
          ],
          "bbox": [
            68.0,
            161.0,
            1060.0,
            258.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/0/Figure/4",
          "block_type": "Figure",
          "html": "<img alt=\"Diagram illustrating the NVDLA precision-preservation architecture. The architecture is divided into four main stages: Convolution Core, SDP, PDP, and CDP. The Convolution Core uses MAC CELLS and includes a PRA (Precision Reduction Architecture) block. The SDP stage uses X and Y LUTs (Look-Up Tables) and includes converters and shifters. The PDP stage uses a Pooling block. The CDP stage uses an LUT and includes converters and shifters. The input data (In, Mean, Weight) and output data (DRAM) are shown, along with various precision control components like Convertors, LUTs, Truncates, and Shifters.\" src=\"3ad4d1734817fe2ac05fe8d4da4f68e8_img.jpg\"/><div class=\"img-description\" style=\"border: 1px solid #ccc; padding: 10px;\"><div class=\"img-alt\">Diagram illustrating the NVDLA precision-preservation architecture. The architecture is divided into four main stages: Convolution Core, SDP, PDP, and CDP. The Convolution Core uses MAC CELLS and includes a PRA (Precision Reduction Architecture) block. The SDP stage uses X and Y LUTs (Look-Up Tables) and includes converters and shifters. The PDP stage uses a Pooling block. The CDP stage uses an LUT and includes converters and shifters. The input data (In, Mean, Weight) and output data (DRAM) are shown, along with various precision control components like Convertors, LUTs, Truncates, and Shifters.</div></div>",
          "page": 0,
          "polygon": [
            [
              86.0,
              288.0
            ],
            [
              1058.0,
              288.0
            ],
            [
              1058.0,
              677.0
            ],
            [
              86.0,
              677.0
            ]
          ],
          "bbox": [
            86.0,
            288.0,
            1058.0,
            677.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2"
          },
          "images": {
            "3ad4d1734817fe2ac05fe8d4da4f68e8_img.jpg": "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ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsDw//AMhfXv8Ar7H/AKCK36wPD/8AyF9e/wCvsf8AoIoA36KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACobu6jsrKe7lz5cEbSPtGThRk4/Kpqp6tayX2jX1pEVEk9vJEpbpllIGfzoAyh4x09bSa4ube9tPLtZLsJPEAZI0GWKkEgkDHGc81asvEEF1dG1mtbuyuPKaZY7qMLuRSASCCRxkcZzzXPX/h3XNb0lrW7hsrUwadcW0AjuGkMkkkewFjsG1Rz6nn25mu/B9xbXN3/AGRLiO9tvs7yXM7yy2/zDLRs5Y4I6rnGVX3oA0ZPGmjx6TBqZkl+zTXAtgRHyHJwMjsOQc+hFaUWsWk+t3OkIzG7t4kmkGOArZxz+FcndeBboytbQ3Ym0+SSKZvtG0OjINvARQOmO38Nanh3QL7TtUkv76SKSaa1WOVkJJLByR17YIoA6eiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKwPD/wDyF9e/6+x/6CK36wPD/wDyF9e/6+x/6CKAN+iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsDw/8A8hfXv+vsf+giiigDfooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//Z"
          }
        },
        {
          "id": "/page/0/Caption/5",
          "block_type": "Caption",
          "html": "<p>Fig. 31 - NVDLA precision-preservation architecture</p>",
          "page": 0,
          "polygon": [
            [
              331.0,
              686.0
            ],
            [
              785.0,
              686.0
            ],
            [
              785.0,
              708.0
            ],
            [
              331.0,
              708.0
            ]
          ],
          "bbox": [
            331.0,
            686.0,
            785.0,
            708.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/6",
          "block_type": "Text",
          "html": "<p>In total, there are four types of approaches to precision control in the NVDLA pipeline:</p>",
          "page": 0,
          "polygon": [
            [
              68.0,
              755.0
            ],
            [
              819.0,
              755.0
            ],
            [
              819.0,
              776.0
            ],
            [
              68.0,
              776.0
            ]
          ],
          "bbox": [
            68.0,
            755.0,
            819.0,
            776.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/0/SectionHeader/7",
          "block_type": "SectionHeader",
          "html": "<h2><ul><li>Converter:</li></ul></h2>",
          "page": 0,
          "polygon": [
            [
              97.0,
              803.0
            ],
            [
              215.0,
              803.0
            ],
            [
              215.0,
              822.0
            ],
            [
              97.0,
              822.0
            ]
          ],
          "bbox": [
            97.0,
            803.0,
            215.0,
            822.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/8",
          "block_type": "Text",
          "html": "<p>The formula for a converter in INT8 and INT16 is:</p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              849.0
            ],
            [
              554.0,
              849.0
            ],
            [
              554.0,
              870.0
            ],
            [
              119.0,
              870.0
            ]
          ],
          "bbox": [
            119.0,
            849.0,
            554.0,
            870.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/Equation/9",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">y = \\text{saturation\\_round}(x - \\text{offset}_{\\text{int}}) * \\text{scaling}_{\\text{int}} \\gg \\text{shifter}_{\\text{uint}}</math></p>",
          "page": 0,
          "polygon": [
            [
              117.0,
              876.0
            ],
            [
              700.0,
              876.0
            ],
            [
              700.0,
              899.0
            ],
            [
              117.0,
              899.0
            ]
          ],
          "bbox": [
            117.0,
            876.0,
            700.0,
            899.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/10",
          "block_type": "Text",
          "html": "<p><i>offset</i>, <i>scaling</i>, and <i>shifter</i> are programmable registers to allow software to control the output dynamic range. Saturation is dependent on the number of output bits.</p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              923.0
            ],
            [
              1055.0,
              923.0
            ],
            [
              1055.0,
              971.0
            ],
            [
              119.0,
              971.0
            ]
          ],
          "bbox": [
            119.0,
            923.0,
            1055.0,
            971.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/11",
          "block_type": "Text",
          "html": "<p>For INT8 and INT16, <i>offset</i> and <i>scaling</i> are treated as signed integers, and the exact number of bits is depends on the input operands. <i>shifter</i> is a 5 bits unsigned integer (always specifying a right shift); the rounding method used after the shift is to \u201cround half away from zero\u201d.</p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              997.0
            ],
            [
              1036.0,
              997.0
            ],
            [
              1036.0,
              1072.0
            ],
            [
              119.0,
              1072.0
            ]
          ],
          "bbox": [
            119.0,
            997.0,
            1036.0,
            1072.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/12",
          "block_type": "Text",
          "html": "<p>For FP16, the dynamic range that can be represented by FP16 representable is large, and so converter and shifter logic is not implemented in hardware.</p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              1097.0
            ],
            [
              1051.0,
              1097.0
            ],
            [
              1051.0,
              1144.0
            ],
            [
              119.0,
              1144.0
            ]
          ],
          "bbox": [
            119.0,
            1097.0,
            1051.0,
            1144.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/13",
          "block_type": "Text",
          "html": "<p>The converter is able to keep the best possible precision even if input data are not symmetric to 0, or dynamic range is not <math>2^N</math>; NVDLA uses it to convert internal precision (high) to external (low, typically INT8/INT16/FP16).</p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              1170.0
            ],
            [
              1004.0,
              1170.0
            ],
            [
              1004.0,
              1241.0
            ],
            [
              119.0,
              1241.0
            ]
          ],
          "bbox": [
            119.0,
            1170.0,
            1004.0,
            1241.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/SectionHeader/14",
          "block_type": "SectionHeader",
          "html": "<h2><ul><li>Truncate:</li></ul></h2>",
          "page": 0,
          "polygon": [
            [
              97.0,
              1268.0
            ],
            [
              204.0,
              1268.0
            ],
            [
              204.0,
              1287.0
            ],
            [
              97.0,
              1287.0
            ]
          ],
          "bbox": [
            97.0,
            1268.0,
            204.0,
            1287.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/7"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/15",
          "block_type": "Text",
          "html": "<p>Truncation is enabled for INT8/INT16 only. The formula for truncation is: <math>y = \\text{saturation\\_round}(x[\\text{msb} : \\text{lsb}])</math></p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              1314.0
            ],
            [
              1072.0,
              1314.0
            ],
            [
              1072.0,
              1337.0
            ],
            [
              119.0,
              1337.0
            ]
          ],
          "bbox": [
            119.0,
            1314.0,
            1072.0,
            1337.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/16",
          "block_type": "Text",
          "html": "<p><i>lsb</i> is a programmable register; <i>msb</i> is defined as <math>\\text{lsb} + \\text{output\\_bits}</math>.</p>",
          "page": 0,
          "polygon": [
            [
              119.0,
              1363.0
            ],
            [
              733.0,
              1363.0
            ],
            [
              733.0,
              1386.0
            ],
            [
              119.0,
              1386.0
            ]
          ],
          "bbox": [
            119.0,
            1363.0,
            733.0,
            1386.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/0/PageFooter/17",
          "block_type": "PageFooter",
          "html": "",
          "page": 0,
          "polygon": [
            [
              41.0,
              1434.0
            ],
            [
              298.0,
              1434.0
            ],
            [
              298.0,
              1453.0
            ],
            [
              41.0,
              1453.0
            ]
          ],
          "bbox": [
            41.0,
            1434.0,
            298.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/0/PageFooter/18",
          "block_type": "PageFooter",
          "html": "",
          "page": 0,
          "polygon": [
            [
              1076.0,
              1434.0
            ],
            [
              1102.0,
              1434.0
            ],
            [
              1102.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1434.0,
            1102.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {}
    },
    {
      "html": "<p>Similarly to the converter, the rounding method used in truncation is also \"round half away from zero\".</p><p>Truncation is used in NVDLA internal pipe where the <math>y</math> has enough bits (compared to converter case); it is the result of a trade-off between precision and area.</p><ul><li>Shifter:</li></ul><p>The shifter exists to make sure that the bias can be added to convolution results; it has the formula <math>y = \\text{saturate}(x \\ll \\text{shifter})</math>.</p><p><i>shifter</i> is a programmable register. The saturate function depends on the number of output bits.</p><ul><li>LUT:</li></ul><p>Look-up tables are used to deal with non-linear function in networks; these functions include sigmoid/tanh activation, or local response normalization as mentioned in Data Formats (<a href=\"https://nvdlia.org/hw/format.html\">https://nvdlia.org/hw/format.html</a>). We use an innovative 2 level hybrid LUT to mimic those non-linear functions; for more detail, see LUT programming (<a href=\"lut-programming.html\">lut-programming.html</a>).</p><h2>FP16 error threshold</h2><p>We know that the output of computations on floating-point data are highly depending on computation order. As a result, when comparing the results of tests that are computed in FP16 space, we should allow some certain threshold of error when comparing NVDLA's output against reference. Below is a summary of the thresholds that are applied for each module.</p><h3>Sub-module Threshold</h3><table><tbody><tr><td>CC DC</td><td><math>f \\text{abs}(a - b) \\le 2^{\\max\\_exp-20} \\cdot R \\cdot S \\cdot C \\cdot 2 \\cdot \\text{scale} + 2^{\\exp(a)-10}</math></td></tr><tr><td>CC Winograd</td><td><math>f \\text{abs}(a - b) \\le 2^{\\max\\_exp-20} \\cdot 18 \\cdot C \\cdot 2 \\cdot \\text{scale} + 2^{\\exp(a)-10}</math></td></tr><tr><td>SDP</td><td>Bit-by-bit identical</td></tr><tr><td>CDP</td><td><math>(f \\text{abs}(a - b) \\le 0.0001) \\text{ \\&amp; \\&amp; } (\\frac{f \\text{abs}(a-b)}{\\text{max\\_value}} \\le 0.001)</math></td></tr><tr><td>PDP</td><td><math>(f \\text{abs}(a - b) \\le 0.0001) \\text{ \\&amp; \\&amp; } (\\frac{f \\text{abs}(a-b)}{\\text{max\\_value}} \\le 0.001)</math></td></tr></tbody></table><p>In the above table, note that:</p><ul><li><math>\\exp(a)</math> in DC/Winograd is the operation to extract exponential field of an input: <math>\\exp(a) = ((a \\gg 10) \\&amp; 0x1f) - 15</math>.</li><li><math>\\max\\_exp</math>: in DC/Winograd is the maximum exponential value of <math>f</math>: <math>\\text{math}</math>: inside a convolution kernel. As data moves in a sliding window, <math>\\max\\_exp</math> is different element-by-element:</li></ul><p><math display=\"block\">\\max\\_exp = \\max_{\\substack{s=0...S-1 \\\\ r=0...R-1 \\\\ c=0...C-1}} (\\exp(\\text{data}_{r,s,c}) \\&amp; (\\sim 0x3) + \\exp(\\text{wt}_{r,s,c}) \\&amp; (\\sim 0x3))</math></p><ul><li><math>\\max\\_value</math> in CDP is the maximum value inside one square sum window.</li><li><math>\\max\\_value</math> in PDP is the maximum value inside one pooling window.</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/1/Page/1",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/1/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 1,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              159.0,
              26.0
            ],
            [
              159.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            159.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 1,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/2",
          "block_type": "Text",
          "html": "<p>Similarly to the converter, the rounding method used in truncation is also \"round half away from zero\".</p>",
          "page": 1,
          "polygon": [
            [
              119.0,
              51.0
            ],
            [
              1010.0,
              51.0
            ],
            [
              1010.0,
              74.0
            ],
            [
              119.0,
              74.0
            ]
          ],
          "bbox": [
            119.0,
            51.0,
            1010.0,
            74.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/3",
          "block_type": "Text",
          "html": "<p>Truncation is used in NVDLA internal pipe where the <math>y</math> has enough bits (compared to converter case); it is the result of a trade-off between precision and area.</p>",
          "page": 1,
          "polygon": [
            [
              119.0,
              98.0
            ],
            [
              1076.0,
              98.0
            ],
            [
              1076.0,
              145.0
            ],
            [
              119.0,
              145.0
            ]
          ],
          "bbox": [
            119.0,
            98.0,
            1076.0,
            145.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/ListGroup/4",
          "block_type": "ListGroup",
          "html": "<ul><li>Shifter:</li></ul>",
          "page": 1,
          "polygon": [
            [
              97.0,
              149.0
            ],
            [
              187.0,
              149.0
            ],
            [
              187.0,
              167.0
            ],
            [
              97.0,
              167.0
            ]
          ],
          "bbox": [
            97.0,
            149.0,
            187.0,
            167.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/5",
          "block_type": "Text",
          "html": "<p>The shifter exists to make sure that the bias can be added to convolution results; it has the formula <math>y = \\text{saturate}(x \\ll \\text{shifter})</math>.</p>",
          "page": 1,
          "polygon": [
            [
              119.0,
              197.0
            ],
            [
              987.0,
              197.0
            ],
            [
              987.0,
              243.0
            ],
            [
              119.0,
              243.0
            ]
          ],
          "bbox": [
            119.0,
            197.0,
            987.0,
            243.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/6",
          "block_type": "Text",
          "html": "<p><i>shifter</i> is a programmable register. The saturate function depends on the number of output bits.</p>",
          "page": 1,
          "polygon": [
            [
              119.0,
              271.0
            ],
            [
              967.0,
              271.0
            ],
            [
              967.0,
              292.0
            ],
            [
              119.0,
              292.0
            ]
          ],
          "bbox": [
            119.0,
            271.0,
            967.0,
            292.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/ListGroup/7",
          "block_type": "ListGroup",
          "html": "<ul><li>LUT:</li></ul>",
          "page": 1,
          "polygon": [
            [
              97.0,
              320.0
            ],
            [
              160.0,
              320.0
            ],
            [
              160.0,
              340.0
            ],
            [
              97.0,
              340.0
            ]
          ],
          "bbox": [
            97.0,
            320.0,
            160.0,
            340.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/8",
          "block_type": "Text",
          "html": "<p>Look-up tables are used to deal with non-linear function in networks; these functions include sigmoid/tanh activation, or local response normalization as mentioned in Data Formats (<a href=\"https://nvdlia.org/hw/format.html\">https://nvdlia.org/hw/format.html</a>). We use an innovative 2 level hybrid LUT to mimic those non-linear functions; for more detail, see LUT programming (<a href=\"lut-programming.html\">lut-programming.html</a>).</p>",
          "page": 1,
          "polygon": [
            [
              119.0,
              366.0
            ],
            [
              1076.0,
              366.0
            ],
            [
              1076.0,
              463.0
            ],
            [
              119.0,
              463.0
            ]
          ],
          "bbox": [
            119.0,
            366.0,
            1076.0,
            463.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/SectionHeader/9",
          "block_type": "SectionHeader",
          "html": "<h2>FP16 error threshold</h2>",
          "page": 1,
          "polygon": [
            [
              68.0,
              490.0
            ],
            [
              455.0,
              490.0
            ],
            [
              455.0,
              528.0
            ],
            [
              68.0,
              528.0
            ]
          ],
          "bbox": [
            68.0,
            490.0,
            455.0,
            528.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/0/SectionHeader/14"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/10",
          "block_type": "Text",
          "html": "<p>We know that the output of computations on floating-point data are highly depending on computation order. As a result, when comparing the results of tests that are computed in FP16 space, we should allow some certain threshold of error when comparing NVDLA's output against reference. Below is a summary of the thresholds that are applied for each module.</p>",
          "page": 1,
          "polygon": [
            [
              68.0,
              543.0
            ],
            [
              1055.0,
              543.0
            ],
            [
              1055.0,
              641.0
            ],
            [
              68.0,
              641.0
            ]
          ],
          "bbox": [
            68.0,
            543.0,
            1055.0,
            641.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9"
          },
          "images": {}
        },
        {
          "id": "/page/1/SectionHeader/11",
          "block_type": "SectionHeader",
          "html": "<h3>Sub-module Threshold</h3>",
          "page": 1,
          "polygon": [
            [
              97.0,
              668.0
            ],
            [
              335.0,
              668.0
            ],
            [
              335.0,
              690.0
            ],
            [
              97.0,
              690.0
            ]
          ],
          "bbox": [
            97.0,
            668.0,
            335.0,
            690.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9"
          },
          "images": {}
        },
        {
          "id": "/page/1/Table/12",
          "block_type": "Table",
          "html": "<table><tbody><tr><td>CC DC</td><td><math>f \\text{abs}(a - b) \\le 2^{\\max\\_exp-20} \\cdot R \\cdot S \\cdot C \\cdot 2 \\cdot \\text{scale} + 2^{\\exp(a)-10}</math></td></tr><tr><td>CC Winograd</td><td><math>f \\text{abs}(a - b) \\le 2^{\\max\\_exp-20} \\cdot 18 \\cdot C \\cdot 2 \\cdot \\text{scale} + 2^{\\exp(a)-10}</math></td></tr><tr><td>SDP</td><td>Bit-by-bit identical</td></tr><tr><td>CDP</td><td><math>(f \\text{abs}(a - b) \\le 0.0001) \\text{ \\&amp; \\&amp; } (\\frac{f \\text{abs}(a-b)}{\\text{max\\_value}} \\le 0.001)</math></td></tr><tr><td>PDP</td><td><math>(f \\text{abs}(a - b) \\le 0.0001) \\text{ \\&amp; \\&amp; } (\\frac{f \\text{abs}(a-b)}{\\text{max\\_value}} \\le 0.001)</math></td></tr></tbody></table>",
          "page": 1,
          "polygon": [
            [
              94.0,
              692.0
            ],
            [
              1043.0,
              692.0
            ],
            [
              1043.0,
              865.0
            ],
            [
              94.0,
              865.0
            ]
          ],
          "bbox": [
            94.0,
            692.0,
            1043.0,
            865.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/1/Text/13",
          "block_type": "Text",
          "html": "<p>In the above table, note that:</p>",
          "page": 1,
          "polygon": [
            [
              68.0,
              882.0
            ],
            [
              329.0,
              882.0
            ],
            [
              329.0,
              901.0
            ],
            [
              68.0,
              901.0
            ]
          ],
          "bbox": [
            68.0,
            882.0,
            329.0,
            901.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/1/ListGroup/14",
          "block_type": "ListGroup",
          "html": "<ul><li><math>\\exp(a)</math> in DC/Winograd is the operation to extract exponential field of an input: <math>\\exp(a) = ((a \\gg 10) \\&amp; 0x1f) - 15</math>.</li><li><math>\\max\\_exp</math>: in DC/Winograd is the maximum exponential value of <math>f</math>: <math>\\text{math}</math>: inside a convolution kernel. As data moves in a sliding window, <math>\\max\\_exp</math> is different element-by-element:</li></ul>",
          "page": 1,
          "polygon": [
            [
              97.0,
              928.0
            ],
            [
              1072.0,
              928.0
            ],
            [
              1072.0,
              1048.0
            ],
            [
              97.0,
              1048.0
            ]
          ],
          "bbox": [
            97.0,
            928.0,
            1072.0,
            1048.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/1/Equation/15",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">\\max\\_exp = \\max_{\\substack{s=0...S-1 \\\\ r=0...R-1 \\\\ c=0...C-1}} (\\exp(\\text{data}_{r,s,c}) \\&amp; (\\sim 0x3) + \\exp(\\text{wt}_{r,s,c}) \\&amp; (\\sim 0x3))</math></p>",
          "page": 1,
          "polygon": [
            [
              278.0,
              1072.0
            ],
            [
              911.0,
              1072.0
            ],
            [
              911.0,
              1149.0
            ],
            [
              278.0,
              1149.0
            ]
          ],
          "bbox": [
            278.0,
            1072.0,
            911.0,
            1149.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/1/ListGroup/16",
          "block_type": "ListGroup",
          "html": "<ul><li><math>\\max\\_value</math> in CDP is the maximum value inside one square sum window.</li><li><math>\\max\\_value</math> in PDP is the maximum value inside one pooling window.</li></ul>",
          "page": 1,
          "polygon": [
            [
              97.0,
              1171.0
            ],
            [
              765.0,
              1171.0
            ],
            [
              765.0,
              1241.0
            ],
            [
              97.0,
              1241.0
            ]
          ],
          "bbox": [
            97.0,
            1171.0,
            765.0,
            1241.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/1/PageFooter/17",
          "block_type": "PageFooter",
          "html": "",
          "page": 1,
          "polygon": [
            [
              41.0,
              1434.0
            ],
            [
              297.0,
              1434.0
            ],
            [
              297.0,
              1453.0
            ],
            [
              41.0,
              1453.0
            ]
          ],
          "bbox": [
            41.0,
            1434.0,
            297.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/1/PageFooter/18",
          "block_type": "PageFooter",
          "html": "",
          "page": 1,
          "polygon": [
            [
              1076.0,
              1434.0
            ],
            [
              1102.0,
              1434.0
            ],
            [
              1102.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1434.0,
            1102.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/0/SectionHeader/14"
      }
    },
    {
      "html": "<h2>Converter programming</h2><h3>Programming interface</h3><p>As mentioned above, for a given converter, there are 3 parameters: <i>offset</i>, <i>scaling</i> and <i>shifter</i>. Depending on the use cases, those parameters have different encodings:</p><table><thead><tr><th>Parameter</th><th>INT-&gt;INT</th><th>INT-&gt;FP16</th><th>FP16-&gt;INT</th><th>FP16-&gt;FP16</th></tr></thead><tbody><tr><td>Offset</td><td>INT32</td><td>INT32</td><td>Not supported</td><td>Not supported</td></tr><tr><td>Scaling</td><td>INT16</td><td>INT16</td><td>Not supported</td><td>Not supported</td></tr><tr><td>Shifter</td><td>UINT5</td><td>UINT5</td><td>Not supported</td><td>Not supported</td></tr></tbody></table><h2>Convolution converters</h2><p>The following is a list of place where converters or truncation might be used for a convolution layer (please refer to Fig. 31 about where're the converters in system):</p><table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td rowspan=\"2\">cc_cvt</td><td>For image input, this converter responsible for mean subtraction and 8 bit conversion;</td><td>INT8/INT16 only</td><td rowspan=\"2\">HW</td></tr><tr><td>For feature input, this converter won't be used</td><td>For FP16, subtract mean data only</td></tr><tr><td>wt_cvt</td><td>Convert weight data to INT8/16/FP16 representable</td><td>Offset is not allowed</td><td>SW</td></tr><tr><td>pra_trunc</td><td>Truncate the winograd pre-transformed results to INT8/16/FP16 representable</td><td>Used for winograd mode and CSC.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr><tr><td>cc_out_trunc</td><td>Truncate the data to INT32/FP32 before sending to SDP</td><td>CACC.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr><tr><td>bs_cvt</td><td>Convert bias data to INT8/16/FP16 representable</td><td>N/A</td><td>SW</td></tr><tr><td>bs_shifter</td><td>Shifter the input bias to make it addable with convolution pipeline results</td><td>SDP.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr></tbody></table><p><math display=\"block\">\\left\\{\\begin{array}{l}SF_{bs} * 2^{bs\\_trunc} = \\frac{SF_{in} * SF_{wt}}{2^{pra\\_trunc+cc\\_out\\_trunc}}, \\quad \\text{conv=winograd} \\\\SF_{bs} * 2^{bs\\_trunc} = \\frac{SF_{in} * SF_{wt}}{2^{cc\\_out\\_trunc}}, \\quad \\text{conv=DC}\\end{array}\\right.</math></p><p>In case of input data encoded with offset (<math>x'=(x-offset)*SF</math>), this offset should be carefully considered for cases below:</p><ul><li>Padding:</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/2/Page/2",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/2/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 2,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              159.0,
              26.0
            ],
            [
              159.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            159.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/2/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 2,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/2/SectionHeader/2",
          "block_type": "SectionHeader",
          "html": "<h2>Converter programming</h2>",
          "page": 2,
          "polygon": [
            [
              67.0,
              51.0
            ],
            [
              522.0,
              51.0
            ],
            [
              522.0,
              93.0
            ],
            [
              67.0,
              93.0
            ]
          ],
          "bbox": [
            67.0,
            51.0,
            522.0,
            93.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/1/SectionHeader/9",
            "3": "/page/1/SectionHeader/11"
          },
          "images": {}
        },
        {
          "id": "/page/2/SectionHeader/3",
          "block_type": "SectionHeader",
          "html": "<h3>Programming interface</h3>",
          "page": 2,
          "polygon": [
            [
              67.0,
              117.0
            ],
            [
              414.0,
              117.0
            ],
            [
              414.0,
              151.0
            ],
            [
              67.0,
              151.0
            ]
          ],
          "bbox": [
            67.0,
            117.0,
            414.0,
            151.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/2/Text/4",
          "block_type": "Text",
          "html": "<p>As mentioned above, for a given converter, there are 3 parameters: <i>offset</i>, <i>scaling</i> and <i>shifter</i>. Depending on the use cases, those parameters have different encodings:</p>",
          "page": 2,
          "polygon": [
            [
              67.0,
              161.0
            ],
            [
              1059.0,
              161.0
            ],
            [
              1059.0,
              212.0
            ],
            [
              67.0,
              212.0
            ]
          ],
          "bbox": [
            67.0,
            161.0,
            1059.0,
            212.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/2",
            "3": "/page/2/SectionHeader/3"
          },
          "images": {}
        },
        {
          "id": "/page/2/Table/5",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Parameter</th><th>INT-&gt;INT</th><th>INT-&gt;FP16</th><th>FP16-&gt;INT</th><th>FP16-&gt;FP16</th></tr></thead><tbody><tr><td>Offset</td><td>INT32</td><td>INT32</td><td>Not supported</td><td>Not supported</td></tr><tr><td>Scaling</td><td>INT16</td><td>INT16</td><td>Not supported</td><td>Not supported</td></tr><tr><td>Shifter</td><td>UINT5</td><td>UINT5</td><td>Not supported</td><td>Not supported</td></tr></tbody></table>",
          "page": 2,
          "polygon": [
            [
              222.0,
              237.0
            ],
            [
              913.0,
              237.0
            ],
            [
              913.0,
              350.0
            ],
            [
              222.0,
              350.0
            ]
          ],
          "bbox": [
            222.0,
            237.0,
            913.0,
            350.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/2",
            "3": "/page/2/SectionHeader/3"
          },
          "images": {}
        },
        {
          "id": "/page/2/SectionHeader/6",
          "block_type": "SectionHeader",
          "html": "<h2>Convolution converters</h2>",
          "page": 2,
          "polygon": [
            [
              67.0,
              375.0
            ],
            [
              416.0,
              375.0
            ],
            [
              416.0,
              408.0
            ],
            [
              67.0,
              408.0
            ]
          ],
          "bbox": [
            67.0,
            375.0,
            416.0,
            408.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/2",
            "3": "/page/2/SectionHeader/3"
          },
          "images": {}
        },
        {
          "id": "/page/2/Text/7",
          "block_type": "Text",
          "html": "<p>The following is a list of place where converters or truncation might be used for a convolution layer (please refer to Fig. 31 about where're the converters in system):</p>",
          "page": 2,
          "polygon": [
            [
              67.0,
              421.0
            ],
            [
              1072.0,
              421.0
            ],
            [
              1072.0,
              469.0
            ],
            [
              67.0,
              469.0
            ]
          ],
          "bbox": [
            67.0,
            421.0,
            1072.0,
            469.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/2/Table/8",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td rowspan=\"2\">cc_cvt</td><td>For image input, this converter responsible for mean subtraction and 8 bit conversion;</td><td>INT8/INT16 only</td><td rowspan=\"2\">HW</td></tr><tr><td>For feature input, this converter won't be used</td><td>For FP16, subtract mean data only</td></tr><tr><td>wt_cvt</td><td>Convert weight data to INT8/16/FP16 representable</td><td>Offset is not allowed</td><td>SW</td></tr><tr><td>pra_trunc</td><td>Truncate the winograd pre-transformed results to INT8/16/FP16 representable</td><td>Used for winograd mode and CSC.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr><tr><td>cc_out_trunc</td><td>Truncate the data to INT32/FP32 before sending to SDP</td><td>CACC.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr><tr><td>bs_cvt</td><td>Convert bias data to INT8/16/FP16 representable</td><td>N/A</td><td>SW</td></tr><tr><td>bs_shifter</td><td>Shifter the input bias to make it addable with convolution pipeline results</td><td>SDP.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr></tbody></table>",
          "page": 2,
          "polygon": [
            [
              67.0,
              491.0
            ],
            [
              1068.0,
              491.0
            ],
            [
              1068.0,
              1143.0
            ],
            [
              67.0,
              1143.0
            ]
          ],
          "bbox": [
            67.0,
            491.0,
            1068.0,
            1143.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/2/Equation/9",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">\\left\\{\\begin{array}{l}SF_{bs} * 2^{bs\\_trunc} = \\frac{SF_{in} * SF_{wt}}{2^{pra\\_trunc+cc\\_out\\_trunc}}, \\quad \\text{conv=winograd} \\\\SF_{bs} * 2^{bs\\_trunc} = \\frac{SF_{in} * SF_{wt}}{2^{cc\\_out\\_trunc}}, \\quad \\text{conv=DC}\\end{array}\\right.</math></p>",
          "page": 2,
          "polygon": [
            [
              323.0,
              1158.0
            ],
            [
              815.0,
              1158.0
            ],
            [
              815.0,
              1232.0
            ],
            [
              323.0,
              1232.0
            ]
          ],
          "bbox": [
            323.0,
            1158.0,
            815.0,
            1232.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/2/Text/10",
          "block_type": "Text",
          "html": "<p>In case of input data encoded with offset (<math>x'=(x-offset)*SF</math>), this offset should be carefully considered for cases below:</p>",
          "page": 2,
          "polygon": [
            [
              67.0,
              1250.0
            ],
            [
              1041.0,
              1250.0
            ],
            [
              1041.0,
              1297.0
            ],
            [
              67.0,
              1297.0
            ]
          ],
          "bbox": [
            67.0,
            1250.0,
            1041.0,
            1297.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/2/ListGroup/11",
          "block_type": "ListGroup",
          "html": "<ul><li>Padding:</li></ul>",
          "page": 2,
          "polygon": [
            [
              96.0,
              1324.0
            ],
            [
              198.0,
              1324.0
            ],
            [
              198.0,
              1346.0
            ],
            [
              96.0,
              1346.0
            ]
          ],
          "bbox": [
            96.0,
            1324.0,
            198.0,
            1346.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/2/PageFooter/12",
          "block_type": "PageFooter",
          "html": "",
          "page": 2,
          "polygon": [
            [
              41.0,
              1434.0
            ],
            [
              297.0,
              1434.0
            ],
            [
              297.0,
              1453.0
            ],
            [
              41.0,
              1453.0
            ]
          ],
          "bbox": [
            41.0,
            1434.0,
            297.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/2/PageFooter/13",
          "block_type": "PageFooter",
          "html": "",
          "page": 2,
          "polygon": [
            [
              1076.0,
              1434.0
            ],
            [
              1103.0,
              1434.0
            ],
            [
              1103.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1434.0,
            1103.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/1/SectionHeader/9",
        "3": "/page/1/SectionHeader/11"
      }
    },
    {
      "html": "<p>Convolution supports zero-padding, however, if the input encoded with \"offset\", it means <math>x=0</math> becomes <math>x'=(0-\\text{offset})*\\text{SF}=-\\text{offset}*\\text{SF}</math> thus hardware should do \"valued padding\" instead of \"zero padding\". Convolution has a register named as:</p><p>PADDING_VALUE, this register should be set as <math>-\\text{offset}*\\text{SF}</math> for INT8/16 pipeline. However, for FP16, we assume there's no offset thus PADDING_VALUE should be set as 0;</p><ul><li>Activation:</li></ul><p>As discussed above, activation such as ReLU is a piece wise function:</p><p><math display=\"block\">\\begin{cases} y = x, &amp; x&gt;0 \\\\ y = 0, &amp; \\text{otherwise} \\end{cases}</math></p><p>0 plays a important role to decide activation output, unfortunately, if \"offset\" is enabled on input convolution data, the \"0\" is no longer 0 in the encoded activation data:</p><p>Let's deduce the CC output (activation layer input) offset based on convolution definition:</p><p>Given: <math>I_{\\text{int}} = S_{\\text{in}} * (I_{\\text{n}} - \\text{Offset}_{\\text{in}})</math>, <math>W_{\\text{int}} = S_{\\text{wt}} * W_{\\text{t}}</math>, <math>CC_{\\text{FP}} = \\sum I_{\\text{n}} * W_{\\text{t}}</math>,</p><p><math display=\"block\">\\begin{aligned} CC_{\\text{int}} &amp;= \\frac{\\sum I_{\\text{int}} * W_{\\text{int}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{\\sum S_{\\text{in}} * (I_{\\text{n}} - \\text{Offset}_{\\text{in}}) * S_{\\text{wt}} * W_{\\text{t}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{S_{\\text{in}} * S_{\\text{wt}} * \\sum (I_{\\text{n}} - \\text{Offset}_{\\text{in}}) * W_{\\text{t}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{S_{\\text{in}} * S_{\\text{wt}} * (\\sum I_{\\text{n}} * W_{\\text{t}} - \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}})}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{S_{\\text{in}} * S_{\\text{wt}} * (CC_{\\text{FP}} - \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}})}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\end{aligned}</math></p><p>(The truncate for activation/weight are merged to <math>S_{\\text{in}}</math>, <math>S_{\\text{wt}}</math> in formula above to simplify deduction)</p><p>So, the CC output offset is: <math>\\frac{S_{\\text{in}} * S_{\\text{wt}} * \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}}</math>.</p><p>Please be noticed: The formula above is assuming no quantization error, in practice, there'll be quantization error</p><p>on weight thus actual offset is <math>\\frac{S_{\\text{in}} * S_{\\text{wt}} * \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}}'}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}}</math>.</p><p>Where <math>W_{\\text{t}}'</math> is the low precision version of weight which takes weight quantization error into consideration.</p><p><math>\\sum W_{\\text{t}}'</math> is different channel-by-channel which means <math>\\frac{S_{\\text{in}} * S_{\\text{wt}} * \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}}'}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}}</math> also vary channel by channel thus per-channel operation has to be adopted to compensate the CC output offset. This compensation is done by ALU module in X1/X2/Y in SDP.</p><h3>SDP converters</h3><p>SDP has kinds of use scenarios, table below lists how those use scenarios maps to SDP sub-modules (For the meaning of X/Y, please refer to Fig. 31)</p><table><thead><tr><th>Use scenario</th><th>Sub-module</th></tr></thead><tbody><tr><td>Bias addition</td><td>X or Y</td></tr><tr><td>Batch Normalization</td><td>X or Y</td></tr></tbody></table>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/3/Page/3",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/3/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 3,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              158.0,
              26.0
            ],
            [
              158.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            158.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 3,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/2",
          "block_type": "Text",
          "html": "<p>Convolution supports zero-padding, however, if the input encoded with \"offset\", it means <math>x=0</math> becomes <math>x'=(0-\\text{offset})*\\text{SF}=-\\text{offset}*\\text{SF}</math> thus hardware should do \"valued padding\" instead of \"zero padding\". Convolution has a register named as:</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              51.0
            ],
            [
              1028.0,
              51.0
            ],
            [
              1028.0,
              123.0
            ],
            [
              67.0,
              123.0
            ]
          ],
          "bbox": [
            67.0,
            51.0,
            1028.0,
            123.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/3",
          "block_type": "Text",
          "html": "<p>PADDING_VALUE, this register should be set as <math>-\\text{offset}*\\text{SF}</math> for INT8/16 pipeline. However, for FP16, we assume there's no offset thus PADDING_VALUE should be set as 0;</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              149.0
            ],
            [
              1041.0,
              149.0
            ],
            [
              1041.0,
              196.0
            ],
            [
              67.0,
              196.0
            ]
          ],
          "bbox": [
            67.0,
            149.0,
            1041.0,
            196.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/ListGroup/4",
          "block_type": "ListGroup",
          "html": "<ul><li>Activation:</li></ul>",
          "page": 3,
          "polygon": [
            [
              96.0,
              222.0
            ],
            [
              215.0,
              222.0
            ],
            [
              215.0,
              242.0
            ],
            [
              96.0,
              242.0
            ]
          ],
          "bbox": [
            96.0,
            222.0,
            215.0,
            242.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/5",
          "block_type": "Text",
          "html": "<p>As discussed above, activation such as ReLU is a piece wise function:</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              259.0
            ],
            [
              670.0,
              259.0
            ],
            [
              670.0,
              279.0
            ],
            [
              67.0,
              279.0
            ]
          ],
          "bbox": [
            67.0,
            259.0,
            670.0,
            279.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Equation/6",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">\\begin{cases} y = x, &amp; x&gt;0 \\\\ y = 0, &amp; \\text{otherwise} \\end{cases}</math></p>",
          "page": 3,
          "polygon": [
            [
              471.0,
              305.0
            ],
            [
              669.0,
              305.0
            ],
            [
              669.0,
              357.0
            ],
            [
              471.0,
              357.0
            ]
          ],
          "bbox": [
            471.0,
            305.0,
            669.0,
            357.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/7",
          "block_type": "Text",
          "html": "<p>0 plays a important role to decide activation output, unfortunately, if \"offset\" is enabled on input convolution data, the \"0\" is no longer 0 in the encoded activation data:</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              377.0
            ],
            [
              1063.0,
              377.0
            ],
            [
              1063.0,
              423.0
            ],
            [
              67.0,
              423.0
            ]
          ],
          "bbox": [
            67.0,
            377.0,
            1063.0,
            423.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/8",
          "block_type": "Text",
          "html": "<p>Let's deduce the CC output (activation layer input) offset based on convolution definition:</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              449.0
            ],
            [
              846.0,
              449.0
            ],
            [
              846.0,
              470.0
            ],
            [
              67.0,
              470.0
            ]
          ],
          "bbox": [
            67.0,
            449.0,
            846.0,
            470.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/9",
          "block_type": "Text",
          "html": "<p>Given: <math>I_{\\text{int}} = S_{\\text{in}} * (I_{\\text{n}} - \\text{Offset}_{\\text{in}})</math>, <math>W_{\\text{int}} = S_{\\text{wt}} * W_{\\text{t}}</math>, <math>CC_{\\text{FP}} = \\sum I_{\\text{n}} * W_{\\text{t}}</math>,</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              494.0
            ],
            [
              795.0,
              494.0
            ],
            [
              795.0,
              519.0
            ],
            [
              67.0,
              519.0
            ]
          ],
          "bbox": [
            67.0,
            494.0,
            795.0,
            519.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Equation/10",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">\\begin{aligned} CC_{\\text{int}} &amp;= \\frac{\\sum I_{\\text{int}} * W_{\\text{int}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{\\sum S_{\\text{in}} * (I_{\\text{n}} - \\text{Offset}_{\\text{in}}) * S_{\\text{wt}} * W_{\\text{t}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{S_{\\text{in}} * S_{\\text{wt}} * \\sum (I_{\\text{n}} - \\text{Offset}_{\\text{in}}) * W_{\\text{t}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{S_{\\text{in}} * S_{\\text{wt}} * (\\sum I_{\\text{n}} * W_{\\text{t}} - \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}})}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\\\ &amp;= \\frac{S_{\\text{in}} * S_{\\text{wt}} * (CC_{\\text{FP}} - \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}})}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}} \\end{aligned}</math></p>",
          "page": 3,
          "polygon": [
            [
              312.0,
              544.0
            ],
            [
              823.0,
              544.0
            ],
            [
              823.0,
              831.0
            ],
            [
              312.0,
              831.0
            ]
          ],
          "bbox": [
            312.0,
            544.0,
            823.0,
            831.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/11",
          "block_type": "Text",
          "html": "<p>(The truncate for activation/weight are merged to <math>S_{\\text{in}}</math>, <math>S_{\\text{wt}}</math> in formula above to simplify deduction)</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              846.0
            ],
            [
              956.0,
              846.0
            ],
            [
              956.0,
              870.0
            ],
            [
              67.0,
              870.0
            ]
          ],
          "bbox": [
            67.0,
            846.0,
            956.0,
            870.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/12",
          "block_type": "Text",
          "html": "<p>So, the CC output offset is: <math>\\frac{S_{\\text{in}} * S_{\\text{wt}} * \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}}}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}}</math>.</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              891.0
            ],
            [
              502.0,
              891.0
            ],
            [
              502.0,
              932.0
            ],
            [
              67.0,
              932.0
            ]
          ],
          "bbox": [
            67.0,
            891.0,
            502.0,
            932.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/13",
          "block_type": "Text",
          "html": "<p>Please be noticed: The formula above is assuming no quantization error, in practice, there'll be quantization error</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              956.0
            ],
            [
              1055.0,
              956.0
            ],
            [
              1055.0,
              977.0
            ],
            [
              67.0,
              977.0
            ]
          ],
          "bbox": [
            67.0,
            956.0,
            1055.0,
            977.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/14",
          "block_type": "Text",
          "html": "<p>on weight thus actual offset is <math>\\frac{S_{\\text{in}} * S_{\\text{wt}} * \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}}'}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}}</math>.</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              977.0
            ],
            [
              530.0,
              977.0
            ],
            [
              530.0,
              1021.0
            ],
            [
              67.0,
              1021.0
            ]
          ],
          "bbox": [
            67.0,
            977.0,
            530.0,
            1021.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/15",
          "block_type": "Text",
          "html": "<p>Where <math>W_{\\text{t}}'</math> is the low precision version of weight which takes weight quantization error into consideration.</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              1043.0
            ],
            [
              991.0,
              1043.0
            ],
            [
              991.0,
              1072.0
            ],
            [
              67.0,
              1072.0
            ]
          ],
          "bbox": [
            67.0,
            1043.0,
            991.0,
            1072.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/16",
          "block_type": "Text",
          "html": "<p><math>\\sum W_{\\text{t}}'</math> is different channel-by-channel which means <math>\\frac{S_{\\text{in}} * S_{\\text{wt}} * \\text{Offset}_{\\text{in}} * \\sum W_{\\text{t}}'}{2^{\\text{pra\\_trunc}+\\text{cc\\_out\\_trunc}}}</math> also vary channel by channel thus per-channel operation has to be adopted to compensate the CC output offset. This compensation is done by ALU module in X1/X2/Y in SDP.</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              1092.0
            ],
            [
              1048.0,
              1092.0
            ],
            [
              1048.0,
              1185.0
            ],
            [
              67.0,
              1185.0
            ]
          ],
          "bbox": [
            67.0,
            1092.0,
            1048.0,
            1185.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/SectionHeader/17",
          "block_type": "SectionHeader",
          "html": "<h3>SDP converters</h3>",
          "page": 3,
          "polygon": [
            [
              67.0,
              1211.0
            ],
            [
              301.0,
              1211.0
            ],
            [
              301.0,
              1244.0
            ],
            [
              67.0,
              1244.0
            ]
          ],
          "bbox": [
            67.0,
            1211.0,
            301.0,
            1244.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/3/Text/18",
          "block_type": "Text",
          "html": "<p>SDP has kinds of use scenarios, table below lists how those use scenarios maps to SDP sub-modules (For the meaning of X/Y, please refer to Fig. 31)</p>",
          "page": 3,
          "polygon": [
            [
              67.0,
              1260.0
            ],
            [
              1021.0,
              1260.0
            ],
            [
              1021.0,
              1306.0
            ],
            [
              67.0,
              1306.0
            ]
          ],
          "bbox": [
            67.0,
            1260.0,
            1021.0,
            1306.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/3/Table/19",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Use scenario</th><th>Sub-module</th></tr></thead><tbody><tr><td>Bias addition</td><td>X or Y</td></tr><tr><td>Batch Normalization</td><td>X or Y</td></tr></tbody></table>",
          "page": 3,
          "polygon": [
            [
              331.0,
              1330.0
            ],
            [
              807.0,
              1330.0
            ],
            [
              807.0,
              1415.0
            ],
            [
              331.0,
              1415.0
            ]
          ],
          "bbox": [
            331.0,
            1330.0,
            807.0,
            1415.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/3/PageFooter/20",
          "block_type": "PageFooter",
          "html": "",
          "page": 3,
          "polygon": [
            [
              41.0,
              1435.0
            ],
            [
              296.0,
              1435.0
            ],
            [
              296.0,
              1453.0
            ],
            [
              41.0,
              1453.0
            ]
          ],
          "bbox": [
            41.0,
            1435.0,
            296.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/3/PageFooter/21",
          "block_type": "PageFooter",
          "html": "",
          "page": 3,
          "polygon": [
            [
              1076.0,
              1435.0
            ],
            [
              1102.0,
              1435.0
            ],
            [
              1102.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1435.0,
            1102.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/2/SectionHeader/6"
      }
    },
    {
      "html": "<table><thead><tr><th>Use scenario</th><th>Sub-module</th></tr></thead><tbody><tr><td>Element-wise</td><td>X or Y</td></tr><tr><td>Activation(ReLU/PReLU)</td><td>X or Y</td></tr><tr><td>Activation(Sigmoid/Tanh, etc)</td><td>Y</td></tr><tr><td>Precision conversion</td><td>X or Y</td></tr></tbody></table><p>Let's review those cases one by one:</p><h3>Bias addition</h3><p>This already covered by Convolution converters</p><h3>Batch normalization</h3><p>Here's a list of converter/shifters needed to realize batch normalization function in SDP:</p><table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>bn_m_cvt</td><td>Convert the offline trained batch normalization mean data to INT8/16/FP16 representable</td><td>N/A</td><td>SW</td></tr><tr><td>bn_m_shifter</td><td>Shift the bn_m_cvt converted values to have the same scaling factor as input</td><td>For SDP.PROC_PRECISION=INT8/INT16 only</td><td>HW</td></tr><tr><td>bn_v_cvt</td><td>Convert the offline trained batch normalization 1/variance to INT8/16/FP16 representable</td><td>Offset is not allowed</td><td>SW</td></tr></tbody></table><p>The input of batch normalization should be either from CONV/MC or previous pipeline stages thus we should assume <math>O_{in}</math>, <math>SF_{in}</math> are applied on input.</p><p>In order to make mean addable with input data, formula below should be satisfied:</p><p><math display=\"block\">SF_{in} = SF_{bs\\_m\\_cvt} * 2^{bn\\_m\\_shifter}</math></p><h3>Element wise</h3><p>Here's a list of converter/shifters needed to related to element wise operation in SDP:</p><table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>ew_cvt</td><td>The converter applied on element-wise input, as element-wise are cube-based, the element-wise hardware layer are the output of upstream hardware layers</td><td>For SDP.PROC_PRECISION=INT8/INT16 only</td><td>HW</td></tr></tbody></table>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/4/Page/4",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/4/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 4,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              159.0,
              26.0
            ],
            [
              159.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            159.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/4/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 4,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/4/Table/2",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Use scenario</th><th>Sub-module</th></tr></thead><tbody><tr><td>Element-wise</td><td>X or Y</td></tr><tr><td>Activation(ReLU/PReLU)</td><td>X or Y</td></tr><tr><td>Activation(Sigmoid/Tanh, etc)</td><td>Y</td></tr><tr><td>Precision conversion</td><td>X or Y</td></tr></tbody></table>",
          "page": 4,
          "polygon": [
            [
              332.0,
              51.0
            ],
            [
              805.0,
              51.0
            ],
            [
              805.0,
              194.0
            ],
            [
              332.0,
              194.0
            ]
          ],
          "bbox": [
            332.0,
            51.0,
            805.0,
            194.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/4/Text/3",
          "block_type": "Text",
          "html": "<p>Let's review those cases one by one:</p>",
          "page": 4,
          "polygon": [
            [
              68.0,
              209.0
            ],
            [
              390.0,
              209.0
            ],
            [
              390.0,
              230.0
            ],
            [
              68.0,
              230.0
            ]
          ],
          "bbox": [
            68.0,
            209.0,
            390.0,
            230.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/4/SectionHeader/4",
          "block_type": "SectionHeader",
          "html": "<h3>Bias addition</h3>",
          "page": 4,
          "polygon": [
            [
              68.0,
              252.0
            ],
            [
              215.0,
              252.0
            ],
            [
              215.0,
              279.0
            ],
            [
              68.0,
              279.0
            ]
          ],
          "bbox": [
            68.0,
            252.0,
            215.0,
            279.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/3/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/4/Text/5",
          "block_type": "Text",
          "html": "<p>This already covered by Convolution converters</p>",
          "page": 4,
          "polygon": [
            [
              68.0,
              292.0
            ],
            [
              484.0,
              292.0
            ],
            [
              484.0,
              314.0
            ],
            [
              68.0,
              314.0
            ]
          ],
          "bbox": [
            68.0,
            292.0,
            484.0,
            314.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/4"
          },
          "images": {}
        },
        {
          "id": "/page/4/SectionHeader/6",
          "block_type": "SectionHeader",
          "html": "<h3>Batch normalization</h3>",
          "page": 4,
          "polygon": [
            [
              68.0,
              338.0
            ],
            [
              295.0,
              338.0
            ],
            [
              295.0,
              363.0
            ],
            [
              68.0,
              363.0
            ]
          ],
          "bbox": [
            68.0,
            338.0,
            295.0,
            363.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/4"
          },
          "images": {}
        },
        {
          "id": "/page/4/Text/7",
          "block_type": "Text",
          "html": "<p>Here's a list of converter/shifters needed to realize batch normalization function in SDP:</p>",
          "page": 4,
          "polygon": [
            [
              68.0,
              377.0
            ],
            [
              832.0,
              377.0
            ],
            [
              832.0,
              399.0
            ],
            [
              68.0,
              399.0
            ]
          ],
          "bbox": [
            68.0,
            377.0,
            832.0,
            399.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/4/Table/8",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>bn_m_cvt</td><td>Convert the offline trained batch normalization mean data to INT8/16/FP16 representable</td><td>N/A</td><td>SW</td></tr><tr><td>bn_m_shifter</td><td>Shift the bn_m_cvt converted values to have the same scaling factor as input</td><td>For SDP.PROC_PRECISION=INT8/INT16 only</td><td>HW</td></tr><tr><td>bn_v_cvt</td><td>Convert the offline trained batch normalization 1/variance to INT8/16/FP16 representable</td><td>Offset is not allowed</td><td>SW</td></tr></tbody></table>",
          "page": 4,
          "polygon": [
            [
              68.0,
              421.0
            ],
            [
              1068.0,
              421.0
            ],
            [
              1068.0,
              788.0
            ],
            [
              68.0,
              788.0
            ]
          ],
          "bbox": [
            68.0,
            421.0,
            1068.0,
            788.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/4/Text/9",
          "block_type": "Text",
          "html": "<p>The input of batch normalization should be either from CONV/MC or previous pipeline stages thus we should assume <math>O_{in}</math>, <math>SF_{in}</math> are applied on input.</p>",
          "page": 4,
          "polygon": [
            [
              68.0,
              801.0
            ],
            [
              1013.0,
              801.0
            ],
            [
              1013.0,
              849.0
            ],
            [
              68.0,
              849.0
            ]
          ],
          "bbox": [
            68.0,
            801.0,
            1013.0,
            849.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/4/Text/10",
          "block_type": "Text",
          "html": "<p>In order to make mean addable with input data, formula below should be satisfied:</p>",
          "page": 4,
          "polygon": [
            [
              68.0,
              874.0
            ],
            [
              792.0,
              874.0
            ],
            [
              792.0,
              896.0
            ],
            [
              68.0,
              896.0
            ]
          ],
          "bbox": [
            68.0,
            874.0,
            792.0,
            896.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/4/Equation/11",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">SF_{in} = SF_{bs\\_m\\_cvt} * 2^{bn\\_m\\_shifter}</math></p>",
          "page": 4,
          "polygon": [
            [
              428.0,
              919.0
            ],
            [
              717.0,
              919.0
            ],
            [
              717.0,
              950.0
            ],
            [
              428.0,
              950.0
            ]
          ],
          "bbox": [
            428.0,
            919.0,
            717.0,
            950.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/4/SectionHeader/12",
          "block_type": "SectionHeader",
          "html": "<h3>Element wise</h3>",
          "page": 4,
          "polygon": [
            [
              68.0,
              965.0
            ],
            [
              221.0,
              965.0
            ],
            [
              221.0,
              990.0
            ],
            [
              68.0,
              990.0
            ]
          ],
          "bbox": [
            68.0,
            965.0,
            221.0,
            990.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/6"
          },
          "images": {}
        },
        {
          "id": "/page/4/Text/13",
          "block_type": "Text",
          "html": "<p>Here's a list of converter/shifters needed to related to element wise operation in SDP:</p>",
          "page": 4,
          "polygon": [
            [
              68.0,
              1005.0
            ],
            [
              815.0,
              1005.0
            ],
            [
              815.0,
              1026.0
            ],
            [
              68.0,
              1026.0
            ]
          ],
          "bbox": [
            68.0,
            1005.0,
            815.0,
            1026.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/4/Table/14",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>ew_cvt</td><td>The converter applied on element-wise input, as element-wise are cube-based, the element-wise hardware layer are the output of upstream hardware layers</td><td>For SDP.PROC_PRECISION=INT8/INT16 only</td><td>HW</td></tr></tbody></table>",
          "page": 4,
          "polygon": [
            [
              68.0,
              1049.0
            ],
            [
              1068.0,
              1049.0
            ],
            [
              1068.0,
              1259.0
            ],
            [
              68.0,
              1259.0
            ]
          ],
          "bbox": [
            68.0,
            1049.0,
            1068.0,
            1259.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/4/PageFooter/15",
          "block_type": "PageFooter",
          "html": "",
          "page": 4,
          "polygon": [
            [
              41.0,
              1434.0
            ],
            [
              297.0,
              1434.0
            ],
            [
              297.0,
              1453.0
            ],
            [
              41.0,
              1453.0
            ]
          ],
          "bbox": [
            41.0,
            1434.0,
            297.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/4/PageFooter/16",
          "block_type": "PageFooter",
          "html": "",
          "page": 4,
          "polygon": [
            [
              1076.0,
              1434.0
            ],
            [
              1102.0,
              1434.0
            ],
            [
              1102.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1434.0,
            1102.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/2/SectionHeader/6",
        "3": "/page/3/SectionHeader/17"
      }
    },
    {
      "html": "<table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>ew_inv_cvt</td><td>Align the offset/scaling factors to meet the requirement of different element wise operation(see below). If the requirement already satisfied, this converter can be bypassed.</td><td>For SDP.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr></tbody></table><p>Since there might be 2 converters applied on E-RDMA stream, if original input is <math>x</math>, the output from ew_inv_cvt is:</p><p><math display=\"block\">x' = \\{(x - O_{ew\\_cvt}) * SF_{ew\\_cvt} - O_{ew\\_inv\\_cvt}\\} * SF_{ew\\_inv\\_cvt} = \\{x - (O_{ew\\_cvt} + \\frac{O_{ew\\_inv\\_cvt}}{SF_{ew\\_cvt}})\\} * SF_{ew\\_cvt} * SF_{ew\\_inv\\_cvt}</math></p><p>In order to make element-wise acts as we supposed, the converter parameter should be carefully configured based on different element-wise operation (Assume converter parameter from BN module is: <math>O_{in}</math>, <math>SF_{in}</math>):</p><ul><li>MAX</li></ul><p>The offset/scaling applied on input stream and E-RDMA stream should be the same, which means:</p><p><math display=\"block\">O_{in} == O_{ew\\_cvt} + \\frac{O_{ew\\_inv\\_cvt}}{SF_{ew\\_cvt}} \\\\ SF_{in} == SF_{ew\\_cvt} * SF_{ew\\_inv\\_cvt}</math></p><ul><li>SUM</li></ul><p>The scaling factor applied on both stream should be the same:</p><p><math display=\"block\">SF_{in} == SF_{ew\\_cvt} * SF_{ew\\_inv\\_cvt}</math></p><ul><li>PROD</li></ul><p>The offset applied on E-RDMA stream should be 0:</p><p><math display=\"block\">O_{ew\\_cvt} + \\frac{O_{ew\\_inv\\_cvt}}{SF_{ew\\_cvt}} == 0</math></p><h3>Activation (ReLU/PRReLU)</h3><p>The input offset of ReLU, PRReLU already eliminated in ALU unit of X1/X2/Y thus the 0s in ReLU/PRReLU is real \"0\", so, we don't need to worry modules;</p><h3>Activation (Sigmoid/TanH, etc.)</h3><p>If complex activation function (e.g.: sigmoid or TanH) are used, LUT has to be used to mimic the curve of those functions. The LUT coverage has to be precisely matched with the input converter parameter to make it acts as you want.</p><p>Let's use an example to explain this match process: suppose [100, 300] is the most interesting data range, user will program LUT (suppose we have 257 LUT entries) as:</p><p><math display=\"block\">LUT[0]=f(100),</math></p><p><math display=\"block\">LUT[1]=f(100+200/256)</math></p><p>...</p>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/5/Page/5",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/5/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 5,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              158.0,
              26.0
            ],
            [
              158.0,
              41.0
            ],
            [
              41.0,
              41.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            158.0,
            41.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 5,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              41.0
            ],
            [
              502.0,
              41.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            41.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Table/2",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>ew_inv_cvt</td><td>Align the offset/scaling factors to meet the requirement of different element wise operation(see below). If the requirement already satisfied, this converter can be bypassed.</td><td>For SDP.PROC_PRECIS ION=INT8/INT16 only</td><td>HW</td></tr></tbody></table>",
          "page": 5,
          "polygon": [
            [
              65.0,
              47.0
            ],
            [
              1072.0,
              47.0
            ],
            [
              1072.0,
              282.0
            ],
            [
              65.0,
              282.0
            ]
          ],
          "bbox": [
            65.0,
            47.0,
            1072.0,
            282.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/3",
          "block_type": "Text",
          "html": "<p>Since there might be 2 converters applied on E-RDMA stream, if original input is <math>x</math>, the output from ew_inv_cvt is:</p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              295.0
            ],
            [
              1064.0,
              295.0
            ],
            [
              1064.0,
              319.0
            ],
            [
              67.0,
              319.0
            ]
          ],
          "bbox": [
            67.0,
            295.0,
            1064.0,
            319.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Equation/4",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">x' = \\{(x - O_{ew\\_cvt}) * SF_{ew\\_cvt} - O_{ew\\_inv\\_cvt}\\} * SF_{ew\\_inv\\_cvt} = \\{x - (O_{ew\\_cvt} + \\frac{O_{ew\\_inv\\_cvt}}{SF_{ew\\_cvt}})\\} * SF_{ew\\_cvt} * SF_{ew\\_inv\\_cvt}</math></p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              340.0
            ],
            [
              1094.0,
              340.0
            ],
            [
              1094.0,
              399.0
            ],
            [
              67.0,
              399.0
            ]
          ],
          "bbox": [
            67.0,
            340.0,
            1094.0,
            399.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/5",
          "block_type": "Text",
          "html": "<p>In order to make element-wise acts as we supposed, the converter parameter should be carefully configured based on different element-wise operation (Assume converter parameter from BN module is: <math>O_{in}</math>, <math>SF_{in}</math>):</p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              414.0
            ],
            [
              1074.0,
              414.0
            ],
            [
              1074.0,
              463.0
            ],
            [
              67.0,
              463.0
            ]
          ],
          "bbox": [
            67.0,
            414.0,
            1074.0,
            463.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/ListGroup/6",
          "block_type": "ListGroup",
          "html": "<ul><li>MAX</li></ul>",
          "page": 5,
          "polygon": [
            [
              96.0,
              487.0
            ],
            [
              160.0,
              487.0
            ],
            [
              160.0,
              507.0
            ],
            [
              96.0,
              507.0
            ]
          ],
          "bbox": [
            96.0,
            487.0,
            160.0,
            507.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/7",
          "block_type": "Text",
          "html": "<p>The offset/scaling applied on input stream and E-RDMA stream should be the same, which means:</p>",
          "page": 5,
          "polygon": [
            [
              118.0,
              534.0
            ],
            [
              976.0,
              534.0
            ],
            [
              976.0,
              558.0
            ],
            [
              118.0,
              558.0
            ]
          ],
          "bbox": [
            118.0,
            534.0,
            976.0,
            558.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Equation/8",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">O_{in} == O_{ew\\_cvt} + \\frac{O_{ew\\_inv\\_cvt}}{SF_{ew\\_cvt}} \\\\ SF_{in} == SF_{ew\\_cvt} * SF_{ew\\_inv\\_cvt}</math></p>",
          "page": 5,
          "polygon": [
            [
              427.0,
              576.0
            ],
            [
              711.0,
              576.0
            ],
            [
              711.0,
              675.0
            ],
            [
              427.0,
              675.0
            ]
          ],
          "bbox": [
            427.0,
            576.0,
            711.0,
            675.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/ListGroup/9",
          "block_type": "ListGroup",
          "html": "<ul><li>SUM</li></ul>",
          "page": 5,
          "polygon": [
            [
              96.0,
              692.0
            ],
            [
              160.0,
              692.0
            ],
            [
              160.0,
              711.0
            ],
            [
              96.0,
              711.0
            ]
          ],
          "bbox": [
            96.0,
            692.0,
            160.0,
            711.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/10",
          "block_type": "Text",
          "html": "<p>The scaling factor applied on both stream should be the same:</p>",
          "page": 5,
          "polygon": [
            [
              118.0,
              742.0
            ],
            [
              664.0,
              742.0
            ],
            [
              664.0,
              763.0
            ],
            [
              118.0,
              763.0
            ]
          ],
          "bbox": [
            118.0,
            742.0,
            664.0,
            763.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Equation/11",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">SF_{in} == SF_{ew\\_cvt} * SF_{ew\\_inv\\_cvt}</math></p>",
          "page": 5,
          "polygon": [
            [
              427.0,
              781.0
            ],
            [
              711.0,
              781.0
            ],
            [
              711.0,
              807.0
            ],
            [
              427.0,
              807.0
            ]
          ],
          "bbox": [
            427.0,
            781.0,
            711.0,
            807.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/ListGroup/12",
          "block_type": "ListGroup",
          "html": "<ul><li>PROD</li></ul>",
          "page": 5,
          "polygon": [
            [
              96.0,
              825.0
            ],
            [
              172.0,
              825.0
            ],
            [
              172.0,
              844.0
            ],
            [
              96.0,
              844.0
            ]
          ],
          "bbox": [
            96.0,
            825.0,
            172.0,
            844.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/13",
          "block_type": "Text",
          "html": "<p>The offset applied on E-RDMA stream should be 0:</p>",
          "page": 5,
          "polygon": [
            [
              118.0,
              871.0
            ],
            [
              560.0,
              871.0
            ],
            [
              560.0,
              895.0
            ],
            [
              118.0,
              895.0
            ]
          ],
          "bbox": [
            118.0,
            871.0,
            560.0,
            895.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Equation/14",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">O_{ew\\_cvt} + \\frac{O_{ew\\_inv\\_cvt}}{SF_{ew\\_cvt}} == 0</math></p>",
          "page": 5,
          "polygon": [
            [
              448.0,
              911.0
            ],
            [
              693.0,
              911.0
            ],
            [
              693.0,
              968.0
            ],
            [
              448.0,
              968.0
            ]
          ],
          "bbox": [
            448.0,
            911.0,
            693.0,
            968.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/SectionHeader/15",
          "block_type": "SectionHeader",
          "html": "<h3>Activation (ReLU/PRReLU)</h3>",
          "page": 5,
          "polygon": [
            [
              67.0,
              978.0
            ],
            [
              347.0,
              978.0
            ],
            [
              347.0,
              1006.0
            ],
            [
              67.0,
              1006.0
            ]
          ],
          "bbox": [
            67.0,
            978.0,
            347.0,
            1006.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/4/SectionHeader/12"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/16",
          "block_type": "Text",
          "html": "<p>The input offset of ReLU, PRReLU already eliminated in ALU unit of X1/X2/Y thus the 0s in ReLU/PRReLU is real \"0\", so, we don't need to worry modules;</p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1018.0
            ],
            [
              1046.0,
              1018.0
            ],
            [
              1046.0,
              1067.0
            ],
            [
              67.0,
              1067.0
            ]
          ],
          "bbox": [
            67.0,
            1018.0,
            1046.0,
            1067.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/15"
          },
          "images": {}
        },
        {
          "id": "/page/5/SectionHeader/17",
          "block_type": "SectionHeader",
          "html": "<h3>Activation (Sigmoid/TanH, etc.)</h3>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1088.0
            ],
            [
              422.0,
              1088.0
            ],
            [
              422.0,
              1116.0
            ],
            [
              67.0,
              1116.0
            ]
          ],
          "bbox": [
            67.0,
            1088.0,
            422.0,
            1116.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/15"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/18",
          "block_type": "Text",
          "html": "<p>If complex activation function (e.g.: sigmoid or TanH) are used, LUT has to be used to mimic the curve of those functions. The LUT coverage has to be precisely matched with the input converter parameter to make it acts as you want.</p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1128.0
            ],
            [
              1076.0,
              1128.0
            ],
            [
              1076.0,
              1201.0
            ],
            [
              67.0,
              1201.0
            ]
          ],
          "bbox": [
            67.0,
            1128.0,
            1076.0,
            1201.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/19",
          "block_type": "Text",
          "html": "<p>Let's use an example to explain this match process: suppose [100, 300] is the most interesting data range, user will program LUT (suppose we have 257 LUT entries) as:</p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1225.0
            ],
            [
              1050.0,
              1225.0
            ],
            [
              1050.0,
              1272.0
            ],
            [
              67.0,
              1272.0
            ]
          ],
          "bbox": [
            67.0,
            1225.0,
            1050.0,
            1272.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/5/Equation/20",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">LUT[0]=f(100),</math></p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1299.0
            ],
            [
              207.0,
              1299.0
            ],
            [
              207.0,
              1323.0
            ],
            [
              67.0,
              1323.0
            ]
          ],
          "bbox": [
            67.0,
            1299.0,
            207.0,
            1323.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/5/Equation/21",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">LUT[1]=f(100+200/256)</math></p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1345.0
            ],
            [
              288.0,
              1345.0
            ],
            [
              288.0,
              1369.0
            ],
            [
              67.0,
              1369.0
            ]
          ],
          "bbox": [
            67.0,
            1345.0,
            288.0,
            1369.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/5/Text/22",
          "block_type": "Text",
          "html": "<p>...</p>",
          "page": 5,
          "polygon": [
            [
              67.0,
              1400.0
            ],
            [
              87.0,
              1400.0
            ],
            [
              87.0,
              1416.0
            ],
            [
              67.0,
              1416.0
            ]
          ],
          "bbox": [
            67.0,
            1400.0,
            87.0,
            1416.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/5/PageFooter/23",
          "block_type": "PageFooter",
          "html": "",
          "page": 5,
          "polygon": [
            [
              39.0,
              1435.0
            ],
            [
              297.0,
              1435.0
            ],
            [
              297.0,
              1453.0
            ],
            [
              39.0,
              1453.0
            ]
          ],
          "bbox": [
            39.0,
            1435.0,
            297.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/5/PageFooter/24",
          "block_type": "PageFooter",
          "html": "",
          "page": 5,
          "polygon": [
            [
              1077.0,
              1435.0
            ],
            [
              1103.0,
              1435.0
            ],
            [
              1103.0,
              1453.0
            ],
            [
              1077.0,
              1453.0
            ]
          ],
          "bbox": [
            1077.0,
            1435.0,
            1103.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/2/SectionHeader/6",
        "3": "/page/4/SectionHeader/12"
      }
    },
    {
      "html": "<p>LUT[256]=f(300)</p><p>This means, if you want to get the correct LUT output, the LUT input has to be <math>x' = (x - O) * SF</math>, where O=100, SF=200/256</p><p>So, software has to carefully program the converters before LUT to achieve this.</p><h2>Precision conversion</h2><p>SDP supports various format conversions, when conversion from high precision to low (e.g.: INT16-&gt;INT8, FP16-&gt;INT16/8), a converter is suggested to avoid the interested data range be rounding/saturated.</p><p>The conversion can be done by any of the converters in SDP pipeline (except <code>ew_inv_cvt</code>).</p><h3>CDP converters</h3><p>CDP has converters listed below:</p><table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>cdp_in_cvt</td><td>Convert the input data compatible with LUT requirement, which means, the output of this converter should be: <math>x*2^N</math></td><td>For CDP.INPUT_DATA_TYPE=INT8/INT16 only</td><td>HW</td></tr><tr><td>cdp_lut_cvt</td><td>Each LUT entry has 16bits (can be interpreted as INT16 or FP16 based on pipeline), the original <math>f(x)</math> has to be converted to keep a specified format to keep a high precision</td><td>No offset allowed</td><td>SW</td></tr><tr><td>cdp_out_cvt</td><td>Convert the results to INT8/16/FP16 before output to external</td><td>For CDP.INPUT_DATA_TYPE=INT8/INT16 only</td><td>HW</td></tr></tbody></table><p>Suppose the CDP input has, in order to make LUT input has the form of <math>x*2^M</math>, <code>cdp_in_cvt</code> has to be programmed as:</p><p><math display=\"block\">O_{cdp\\_in\\_cvt} = -O_{in} * SF_{in}</math><math display=\"block\">SF_{cdp\\_in\\_cvt} = \\frac{2^M}{SF_{in}}</math></p><p>Value M should be selected by precision study.</p><p>Suppose CDP output is encoded as <math>O_{out}, SF_{out}</math>, <code>cdp_lut_cvt</code> and <code>cdp_out_cvt</code> has to be programmed as:</p><p><math display=\"block\">O_{out} = \\frac{O_{cdp\\_out\\_cvt}}{SF_{cdp\\_lut\\_cvt} * 2^M}</math><math display=\"block\">SF_{out} = SF_{cdp\\_lut\\_cvt} * SDP_{cdp\\_out\\_cvt} * 2^M</math></p><h3>PDP converters</h3><p>There's no converter instanced in PDP. But be noticed that the PDP padding value is intended to compensate the input offset, for FP16 pipe, they're ignored as we assume there's no offset for FP16 pipe;</p>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/6/Page/6",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/6/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 6,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              158.0,
              26.0
            ],
            [
              158.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            158.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/6/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 6,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              811.0,
              26.0
            ],
            [
              811.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            811.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/2",
          "block_type": "Text",
          "html": "<p>LUT[256]=f(300)</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              51.0
            ],
            [
              221.0,
              51.0
            ],
            [
              221.0,
              74.0
            ],
            [
              67.0,
              74.0
            ]
          ],
          "bbox": [
            67.0,
            51.0,
            221.0,
            74.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/3",
          "block_type": "Text",
          "html": "<p>This means, if you want to get the correct LUT output, the LUT input has to be <math>x' = (x - O) * SF</math>, where O=100, SF=200/256</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              98.0
            ],
            [
              1058.0,
              98.0
            ],
            [
              1058.0,
              148.0
            ],
            [
              67.0,
              148.0
            ]
          ],
          "bbox": [
            67.0,
            98.0,
            1058.0,
            148.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/4",
          "block_type": "Text",
          "html": "<p>So, software has to carefully program the converters before LUT to achieve this.</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              173.0
            ],
            [
              765.0,
              173.0
            ],
            [
              765.0,
              196.0
            ],
            [
              67.0,
              196.0
            ]
          ],
          "bbox": [
            67.0,
            173.0,
            765.0,
            196.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/6/SectionHeader/5",
          "block_type": "SectionHeader",
          "html": "<h2>Precision conversion</h2>",
          "page": 6,
          "polygon": [
            [
              67.0,
              210.0
            ],
            [
              298.0,
              210.0
            ],
            [
              298.0,
              233.0
            ],
            [
              67.0,
              233.0
            ]
          ],
          "bbox": [
            67.0,
            210.0,
            298.0,
            233.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/2/SectionHeader/6",
            "3": "/page/5/SectionHeader/17"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/6",
          "block_type": "Text",
          "html": "<p>SDP supports various format conversions, when conversion from high precision to low (e.g.: INT16-&gt;INT8, FP16-&gt;INT16/8), a converter is suggested to avoid the interested data range be rounding/saturated.</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              247.0
            ],
            [
              1056.0,
              247.0
            ],
            [
              1056.0,
              295.0
            ],
            [
              67.0,
              295.0
            ]
          ],
          "bbox": [
            67.0,
            247.0,
            1056.0,
            295.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/7",
          "block_type": "Text",
          "html": "<p>The conversion can be done by any of the converters in SDP pipeline (except <code>ew_inv_cvt</code>).</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              322.0
            ],
            [
              856.0,
              322.0
            ],
            [
              856.0,
              343.0
            ],
            [
              67.0,
              343.0
            ]
          ],
          "bbox": [
            67.0,
            322.0,
            856.0,
            343.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5"
          },
          "images": {}
        },
        {
          "id": "/page/6/SectionHeader/8",
          "block_type": "SectionHeader",
          "html": "<h3>CDP converters</h3>",
          "page": 6,
          "polygon": [
            [
              67.0,
              371.0
            ],
            [
              303.0,
              371.0
            ],
            [
              303.0,
              402.0
            ],
            [
              67.0,
              402.0
            ]
          ],
          "bbox": [
            67.0,
            371.0,
            303.0,
            402.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/9",
          "block_type": "Text",
          "html": "<p>CDP has converters listed below:</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              417.0
            ],
            [
              357.0,
              417.0
            ],
            [
              357.0,
              439.0
            ],
            [
              67.0,
              439.0
            ]
          ],
          "bbox": [
            67.0,
            417.0,
            357.0,
            439.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Table/10",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Converter</th><th>Functionality</th><th>Limitation</th><th>Owner</th></tr></thead><tbody><tr><td>cdp_in_cvt</td><td>Convert the input data compatible with LUT requirement, which means, the output of this converter should be: <math>x*2^N</math></td><td>For CDP.INPUT_DATA_TYPE=INT8/INT16 only</td><td>HW</td></tr><tr><td>cdp_lut_cvt</td><td>Each LUT entry has 16bits (can be interpreted as INT16 or FP16 based on pipeline), the original <math>f(x)</math> has to be converted to keep a specified format to keep a high precision</td><td>No offset allowed</td><td>SW</td></tr><tr><td>cdp_out_cvt</td><td>Convert the results to INT8/16/FP16 before output to external</td><td>For CDP.INPUT_DATA_TYPE=INT8/INT16 only</td><td>HW</td></tr></tbody></table>",
          "page": 6,
          "polygon": [
            [
              67.0,
              463.0
            ],
            [
              1069.0,
              463.0
            ],
            [
              1069.0,
              877.0
            ],
            [
              67.0,
              877.0
            ]
          ],
          "bbox": [
            67.0,
            463.0,
            1069.0,
            877.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/11",
          "block_type": "Text",
          "html": "<p>Suppose the CDP input has, in order to make LUT input has the form of <math>x*2^M</math>, <code>cdp_in_cvt</code> has to be programmed as:</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              891.0
            ],
            [
              1052.0,
              891.0
            ],
            [
              1052.0,
              940.0
            ],
            [
              67.0,
              940.0
            ]
          ],
          "bbox": [
            67.0,
            891.0,
            1052.0,
            940.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Equation/12",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">O_{cdp\\_in\\_cvt} = -O_{in} * SF_{in}</math><math display=\"block\">SF_{cdp\\_in\\_cvt} = \\frac{2^M}{SF_{in}}</math></p>",
          "page": 6,
          "polygon": [
            [
              459.0,
              962.0
            ],
            [
              684.0,
              962.0
            ],
            [
              684.0,
              1064.0
            ],
            [
              459.0,
              1064.0
            ]
          ],
          "bbox": [
            459.0,
            962.0,
            684.0,
            1064.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/13",
          "block_type": "Text",
          "html": "<p>Value M should be selected by precision study.</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              1081.0
            ],
            [
              474.0,
              1081.0
            ],
            [
              474.0,
              1103.0
            ],
            [
              67.0,
              1103.0
            ]
          ],
          "bbox": [
            67.0,
            1081.0,
            474.0,
            1103.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/14",
          "block_type": "Text",
          "html": "<p>Suppose CDP output is encoded as <math>O_{out}, SF_{out}</math>, <code>cdp_lut_cvt</code> and <code>cdp_out_cvt</code> has to be programmed as:</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              1128.0
            ],
            [
              974.0,
              1128.0
            ],
            [
              974.0,
              1152.0
            ],
            [
              67.0,
              1152.0
            ]
          ],
          "bbox": [
            67.0,
            1128.0,
            974.0,
            1152.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Equation/15",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">O_{out} = \\frac{O_{cdp\\_out\\_cvt}}{SF_{cdp\\_lut\\_cvt} * 2^M}</math><math display=\"block\">SF_{out} = SF_{cdp\\_lut\\_cvt} * SDP_{cdp\\_out\\_cvt} * 2^M</math></p>",
          "page": 6,
          "polygon": [
            [
              375.0,
              1173.0
            ],
            [
              762.0,
              1173.0
            ],
            [
              762.0,
              1278.0
            ],
            [
              375.0,
              1278.0
            ]
          ],
          "bbox": [
            375.0,
            1173.0,
            762.0,
            1278.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/SectionHeader/16",
          "block_type": "SectionHeader",
          "html": "<h3>PDP converters</h3>",
          "page": 6,
          "polygon": [
            [
              67.0,
              1305.0
            ],
            [
              300.0,
              1305.0
            ],
            [
              300.0,
              1336.0
            ],
            [
              67.0,
              1336.0
            ]
          ],
          "bbox": [
            67.0,
            1305.0,
            300.0,
            1336.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/8"
          },
          "images": {}
        },
        {
          "id": "/page/6/Text/17",
          "block_type": "Text",
          "html": "<p>There's no converter instanced in PDP. But be noticed that the PDP padding value is intended to compensate the input offset, for FP16 pipe, they're ignored as we assume there's no offset for FP16 pipe;</p>",
          "page": 6,
          "polygon": [
            [
              67.0,
              1349.0
            ],
            [
              1046.0,
              1349.0
            ],
            [
              1046.0,
              1398.0
            ],
            [
              67.0,
              1398.0
            ]
          ],
          "bbox": [
            67.0,
            1349.0,
            1046.0,
            1398.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/16"
          },
          "images": {}
        },
        {
          "id": "/page/6/PageFooter/18",
          "block_type": "PageFooter",
          "html": "",
          "page": 6,
          "polygon": [
            [
              39.0,
              1435.0
            ],
            [
              298.0,
              1435.0
            ],
            [
              298.0,
              1453.0
            ],
            [
              39.0,
              1453.0
            ]
          ],
          "bbox": [
            39.0,
            1435.0,
            298.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/16"
          },
          "images": {}
        },
        {
          "id": "/page/6/PageFooter/19",
          "block_type": "PageFooter",
          "html": "",
          "page": 6,
          "polygon": [
            [
              1076.0,
              1435.0
            ],
            [
              1103.0,
              1435.0
            ],
            [
              1103.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1435.0,
            1103.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/16"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/2/SectionHeader/6",
        "3": "/page/5/SectionHeader/17"
      }
    },
    {
      "html": "<h2>Converter statistics</h2><p>NVDLA implemented counters to evaluate number of samples overflowed during converter. The overflow is defined as:</p><p><math display=\"block\">INT32 : x &lt; -2147483648 || x &gt; 2147483647</math></p><p><math display=\"block\">INT16 : x &lt; -32768 || x &gt; 32767</math></p><p><math display=\"block\">INT8 : x &lt; -128 || x &gt; 127</math></p><p><math display=\"block\">FP16 : f_{abs}(x) \\ge 65504</math></p><p>Here's a list of saturation counters in NVDLA pipeline:</p><table><thead><tr><th>Register</th><th>Valid condition</th></tr></thead><tbody><tr><td>CACC_D_OUT_SATURATION</td><td>Always enabled</td></tr><tr><td>SDP_D_PERF_OUT_SATURATION</td><td>PERF_SAT_EN=YES &amp;&amp; PROC_PRECISION== OUT_PRECISION==FP16</td></tr><tr><td>CDP_D_OUT_SATURATION</td><td>Always enabled</td></tr></tbody></table>",
      "bbox": [
        0.0,
        0.0,
        1148.0,
        1485.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1148.0,
          0.0
        ],
        [
          1148.0,
          1485.0
        ],
        [
          0.0,
          1485.0
        ]
      ],
      "id": "/page/7/Page/7",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/7/PageHeader/0",
          "block_type": "PageHeader",
          "html": "",
          "page": 7,
          "polygon": [
            [
              41.0,
              26.0
            ],
            [
              160.0,
              26.0
            ],
            [
              160.0,
              43.0
            ],
            [
              41.0,
              43.0
            ]
          ],
          "bbox": [
            41.0,
            26.0,
            160.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/16"
          },
          "images": {}
        },
        {
          "id": "/page/7/PageHeader/1",
          "block_type": "PageHeader",
          "html": "",
          "page": 7,
          "polygon": [
            [
              502.0,
              26.0
            ],
            [
              812.0,
              26.0
            ],
            [
              812.0,
              43.0
            ],
            [
              502.0,
              43.0
            ]
          ],
          "bbox": [
            502.0,
            26.0,
            812.0,
            43.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/16"
          },
          "images": {}
        },
        {
          "id": "/page/7/SectionHeader/2",
          "block_type": "SectionHeader",
          "html": "<h2>Converter statistics</h2>",
          "page": 7,
          "polygon": [
            [
              67.0,
              50.0
            ],
            [
              362.0,
              50.0
            ],
            [
              362.0,
              83.0
            ],
            [
              67.0,
              83.0
            ]
          ],
          "bbox": [
            67.0,
            50.0,
            362.0,
            83.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/6/SectionHeader/5",
            "3": "/page/6/SectionHeader/16"
          },
          "images": {}
        },
        {
          "id": "/page/7/Text/3",
          "block_type": "Text",
          "html": "<p>NVDLA implemented counters to evaluate number of samples overflowed during converter. The overflow is defined as:</p>",
          "page": 7,
          "polygon": [
            [
              67.0,
              95.0
            ],
            [
              1068.0,
              95.0
            ],
            [
              1068.0,
              142.0
            ],
            [
              67.0,
              142.0
            ]
          ],
          "bbox": [
            67.0,
            95.0,
            1068.0,
            142.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/Equation/4",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">INT32 : x &lt; -2147483648 || x &gt; 2147483647</math></p>",
          "page": 7,
          "polygon": [
            [
              360.0,
              167.0
            ],
            [
              781.0,
              167.0
            ],
            [
              781.0,
              191.0
            ],
            [
              360.0,
              191.0
            ]
          ],
          "bbox": [
            360.0,
            167.0,
            781.0,
            191.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/Equation/5",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">INT16 : x &lt; -32768 || x &gt; 32767</math></p>",
          "page": 7,
          "polygon": [
            [
              415.0,
              210.0
            ],
            [
              727.0,
              210.0
            ],
            [
              727.0,
              234.0
            ],
            [
              415.0,
              234.0
            ]
          ],
          "bbox": [
            415.0,
            210.0,
            727.0,
            234.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/Equation/6",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">INT8 : x &lt; -128 || x &gt; 127</math></p>",
          "page": 7,
          "polygon": [
            [
              444.0,
              253.0
            ],
            [
              699.0,
              253.0
            ],
            [
              699.0,
              279.0
            ],
            [
              444.0,
              279.0
            ]
          ],
          "bbox": [
            444.0,
            253.0,
            699.0,
            279.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/Equation/7",
          "block_type": "Equation",
          "html": "<p><math display=\"block\">FP16 : f_{abs}(x) \\ge 65504</math></p>",
          "page": 7,
          "polygon": [
            [
              446.0,
              295.0
            ],
            [
              696.0,
              295.0
            ],
            [
              696.0,
              320.0
            ],
            [
              446.0,
              320.0
            ]
          ],
          "bbox": [
            446.0,
            295.0,
            696.0,
            320.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/Text/8",
          "block_type": "Text",
          "html": "<p>Here's a list of saturation counters in NVDLA pipeline:</p>",
          "page": 7,
          "polygon": [
            [
              67.0,
              340.0
            ],
            [
              538.0,
              340.0
            ],
            [
              538.0,
              362.0
            ],
            [
              67.0,
              362.0
            ]
          ],
          "bbox": [
            67.0,
            340.0,
            538.0,
            362.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/Table/9",
          "block_type": "Table",
          "html": "<table><thead><tr><th>Register</th><th>Valid condition</th></tr></thead><tbody><tr><td>CACC_D_OUT_SATURATION</td><td>Always enabled</td></tr><tr><td>SDP_D_PERF_OUT_SATURATION</td><td>PERF_SAT_EN=YES &amp;&amp; PROC_PRECISION== OUT_PRECISION==FP16</td></tr><tr><td>CDP_D_OUT_SATURATION</td><td>Always enabled</td></tr></tbody></table>",
          "page": 7,
          "polygon": [
            [
              204.0,
              387.0
            ],
            [
              932.0,
              387.0
            ],
            [
              932.0,
              546.0
            ],
            [
              204.0,
              546.0
            ]
          ],
          "bbox": [
            204.0,
            387.0,
            932.0,
            546.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/PageFooter/10",
          "block_type": "PageFooter",
          "html": "",
          "page": 7,
          "polygon": [
            [
              39.0,
              1434.0
            ],
            [
              298.0,
              1434.0
            ],
            [
              298.0,
              1455.0
            ],
            [
              39.0,
              1455.0
            ]
          ],
          "bbox": [
            39.0,
            1434.0,
            298.0,
            1455.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        },
        {
          "id": "/page/7/PageFooter/11",
          "block_type": "PageFooter",
          "html": "",
          "page": 7,
          "polygon": [
            [
              1076.0,
              1434.0
            ],
            [
              1105.0,
              1434.0
            ],
            [
              1105.0,
              1453.0
            ],
            [
              1076.0,
              1453.0
            ]
          ],
          "bbox": [
            1076.0,
            1434.0,
            1105.0,
            1453.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/2",
            "2": "/page/7/SectionHeader/2"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/2",
        "2": "/page/6/SectionHeader/5",
        "3": "/page/6/SectionHeader/16"
      }
    }
  ],
  "metadata": {
    "page_stats": [
      {
        "page_id": 0,
        "num_blocks": 19
      },
      {
        "page_id": 1,
        "num_blocks": 19
      },
      {
        "page_id": 2,
        "num_blocks": 14
      },
      {
        "page_id": 3,
        "num_blocks": 22
      },
      {
        "page_id": 4,
        "num_blocks": 17
      },
      {
        "page_id": 5,
        "num_blocks": 25
      },
      {
        "page_id": 6,
        "num_blocks": 20
      },
      {
        "page_id": 7,
        "num_blocks": 12
      }
    ]
  }
}