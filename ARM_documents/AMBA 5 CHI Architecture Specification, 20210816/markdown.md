

# AMBA® 5 CHI Architecture Specification

![ARM logo](935eed7aa61f7777f62cfc032e11bee9_img.jpg)

ARM logo

## AMBA 5 CHI

Copyright © 2014, 2017-2021 Arm Limited or its affiliates. All rights reserved.

## Release Information

*Change history* lists the changes made to this specification.

## Change history

| Date           | Issue | Confidentiality  | Change                |
|----------------|-------|------------------|-----------------------|
| 12 June 2014   | A     | Confidential     | First limited release |
| 04 August 2017 | B     | Non-Confidential | First public release  |
| 08 May 2018    | C     | Non-Confidential | Second public release |
| 28 August 2019 | D     | Non-Confidential | Third public release  |
| 19 August 2020 | E.a   | Non-Confidential | Fourth public release |
| 16 August 2021 | E.b   | Non-Confidential | Fifth public release  |

## Proprietary Notice

This document is **NON-CONFIDENTIAL**, and any use by you is subject to the terms of this notice and the Arm AMBA Specification Licence set about below.

This document is protected by copyright and other related rights and the practice or implementation of the information contained in this document may be protected by one or more patents or pending patent applications. No part of this document may be reproduced in any form by any means without the express prior written permission of Arm. No license, express or implied, by estoppel or otherwise to any intellectual property rights is granted by this document unless specifically stated.

Your access to the information in this document is conditional upon your acceptance that you will not use or permit others to use the information for the purposes of determining whether implementations infringe any third party patents.

THIS DOCUMENT IS PROVIDED "AS IS", ARM PROVIDES NO REPRESENTATIONS AND NO WARRANTIES, EXPRESS, IMPLIED OR STATUTORY, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY QUALITY, NON-INFRINGEMENT OR FITNESS FOR A PARTICULAR PURPOSE WITH RESPECT TO THE DOCUMENT. For the avoidance of doubt, Arm makes no representation with respect to, and has undertaken no analysis to identify or understand the scope and content of, patents, copyrights, trade secrets, or other rights.

This document may include technical inaccuracies or typographical errors.

TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ARM BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF ARM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

This document consists solely of commercial items. You shall be responsible for ensuring that any use, duplication or disclosure of this document complies fully with any relevant export laws and regulations to assure that this document or any portion thereof is not exported, directly or indirectly, in violation of such export laws. Use of the word "partner" in reference to Arm's customers is not intended to create or refer to any partnership relationship with any other company. Arm may make changes to this document at any time and without notice.

This document may be translated into other languages for convenience, and you agree that if there is any conflict between the English version of this document and any translation, the terms of the English version of the Agreement shall prevail.

The Arm corporate logo and words marked with ® or ™ are registered trademarks or trademarks of Arm Limited (or its subsidiaries) in the US and/or elsewhere. All rights reserved. Other brands and names mentioned in this document may be the trademarks of their respective owners. Please follow Arm's trademark usage guidelines at <http://www.arm.com/company/policies/trademarks>.

Copyright © 2014, 2017-2021 Arm Limited (or its affiliates). All rights reserved.

Arm Limited. Company 02557590 registered in England.  
110 Fulbourn Road, Cambridge, England CB1 9NJ.  
LES-PRE-21451 version 2.2

## AMBA SPECIFICATION LICENCE

THIS END USER LICENCE AGREEMENT ("LICENCE") IS A LEGAL AGREEMENT BETWEEN YOU (EITHER A SINGLE INDIVIDUAL, OR SINGLE LEGAL ENTITY) AND ARM LIMITED ("ARM") FOR THE USE OF ARM'S INTELLECTUAL PROPERTY (INCLUDING, WITHOUT LIMITATION, ANY COPYRIGHT) IN THE RELEVANT AMBA SPECIFICATION ACCOMPANYING THIS LICENCE. ARM LICENCES THE RELEVANT AMBA SPECIFICATION TO YOU ON CONDITION THAT YOU ACCEPT ALL OF THE TERMS IN THIS LICENCE. BY CLICKING "I AGREE" OR OTHERWISE USING OR COPYING THE RELEVANT AMBA SPECIFICATION YOU INDICATE THAT YOU AGREE TO BE BOUND BY ALL THE TERMS OF THIS LICENCE.

"LICENSEE" means You and your Subsidiaries.

"Subsidiary" means, if You are a single entity, any company the majority of whose voting shares is now or hereafter owned or controlled, directly or indirectly, by You. A company shall be a Subsidiary only for the period during which such control exists.

1. Subject to the provisions of Clauses 2, 3 and 4, Arm hereby grants to LICENSEE a perpetual, non-exclusive, non-transferable, royalty free, worldwide licence to:

   1. use and copy the relevant AMBA Specification for the purpose of developing and having developed products that comply with the relevant AMBA Specification;
   2. manufacture and have manufactured products which either: (a) have been created by or for LICENSEE under the licence granted in Clause 1(i); or (b) incorporate a product(s) which has been created by a third party(s) under a licence granted by Arm in Clause 1(i) of such third party's AMBA Specification Licence; and
   3. offer to sell, sell, supply or otherwise distribute products which have either been (a) created by or for LICENSEE under the licence granted in Clause 1(i); or (b) manufactured by or for LICENSEE under the licence granted in Clause 1(ii).
2. LICENSEE hereby agrees that the licence granted in Clause 1 is subject to the following restrictions:

   1. where a product created under Clause 1(i) is an integrated circuit which includes a CPU then either: (a) such CPU shall only be manufactured under licence from Arm; or (b) such CPU is neither substantially compliant with nor marketed as being compliant with the Arm instruction sets licensed by Arm from time to time;
   2. the licences granted in Clause 1(iii) shall not extend to any portion or function of a product that is not itself compliant with part of the relevant AMBA Specification; and
   3. no right is granted to LICENSEE to sublicence the rights granted to LICENSEE under this Agreement.
3. Except as specifically licensed in accordance with Clause 1, LICENSEE acquires no right, title or interest in any Arm technology or any intellectual property embodied therein. In no event shall the licences granted in accordance with Clause 1 be construed as granting LICENSEE, expressly or by implication, estoppel or otherwise, a licence to use any Arm technology except the relevant AMBA Specification.
4. THE RELEVANT AMBA SPECIFICATION IS PROVIDED "AS IS" WITH NO REPRESENTATION OR WARRANTIES EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF SATISFACTORY QUALITY, MERCHANTABILITY, NON-INFRINGEMENT OR FITNESS FOR A PARTICULAR PURPOSE, OR THAT ANY USE OR IMPLEMENTATION OF SUCH ARM TECHNOLOGY WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADE SECRETS OR OTHER INTELLECTUAL PROPERTY RIGHTS.
5. NOTWITHSTANDING ANYTHING TO THE CONTRARY CONTAINED IN THIS AGREEMENT, TO THE FULLEST EXTENT PERMITTED BY LAW, THE MAXIMUM LIABILITY OF ARM IN AGGREGATE FOR ALL CLAIMS MADE AGAINST ARM, IN CONTRACT, TORT OR OTHERWISE, IN CONNECTION WITH THE SUBJECT MATTER OF THIS AGREEMENT (INCLUDING WITHOUT LIMITATION (I) LICENSEE'S USE OF THE ARM TECHNOLOGY; AND (II) THE IMPLEMENTATION OF THE ARM TECHNOLOGY IN ANY PRODUCT CREATED BY LICENSEE UNDER THIS AGREEMENT) SHALL NOT EXCEED THE FEES PAID (IF ANY) BY LICENSEE TO ARM UNDER THIS AGREEMENT. THE EXISTENCE OF MORE THAN ONE CLAIM OR SUIT WILL NOT ENLARGE OR EXTEND THE LIMIT LICENSEE RELEASES ARM FROM ALL OBLIGATIONS, LIABILITY, CLAIMS OR DEMANDS IN EXCESS OF THIS LIMITATION.
6. No licence, express, implied or otherwise, is granted to LICENSEE, under the provisions of Clause 1, to use the Arm tradename, or AMBA trademark in connection with the relevant AMBA Specification or any products based thereon. Nothing in Clause 1 shall be construed as authority for LICENSEE to make any representations on behalf of Arm in respect of the relevant AMBA Specification.
7. This Licence shall remain in force until terminated by you or by Arm. Without prejudice to any of its other rights if LICENSEE is in breach of any of the terms and conditions of this Licence then Arm may terminate this Licence immediately upon giving written notice to You. You may terminate this Licence at any time. Upon expiry or termination

of this Licence by You or by Arm LICENSEE shall stop using the relevant AMBA Specification and destroy all copies of the relevant AMBA Specification in your possession together with all documentation and related materials. Upon expiry or termination of this Licence, the provisions of clauses 6 and 7 shall survive.

8. The validity, construction and performance of this Agreement shall be governed by English Law.

## Confidentiality Status

This document is Non-Confidential. The right to use, copy and disclose this document may be subject to license restrictions in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to.

## Product Status

The information in this document is final, that is for a developed product.

## Web Address

<http://www.arm.com>

## Contents

# AMBA 5 CHI Architecture Specification

# Preface

| About this specification | x  |
|--------------------------|----|
| Feedback                 | xv |

# Chapter 1

# Introduction

| 1.1 | Architecture overview      | 1-18 |
|-----|----------------------------|------|
| 1.2 | Topology                   | 1-20 |
| 1.3 | Terminology                | 1-21 |
| 1.4 | Transaction classification | 1-24 |
| 1.5 | Coherence overview         | 1-26 |
| 1.6 | Component naming           | 1-28 |
| 1.7 | Read data source           | 1-30 |

# Chapter 2

# Transactions

| 2.1  | Channels overview                        | 2-32  |
|------|------------------------------------------|-------|
| 2.2  | Channel fields                           | 2-33  |
| 2.3  | Transaction structure                    | 2-40  |
| 2.4  | Transaction identifier fields            | 2-86  |
| 2.5  | Details of transaction identifier fields | 2-87  |
| 2.6  | Transaction identifier field flows       | 2-92  |
| 2.7  | Logical Processor Identifier             | 2-113 |
| 2.8  | Ordering                                 | 2-114 |
| 2.9  | Address, Control, and Data               | 2-125 |
| 2.10 | Data transfer                            | 2-134 |
| 2.11 | Request Retry                            | 2-145 |

# Chapter 3

# Network Layer

| 3.1 | System Address Map | 3-150 |
|-----|--------------------|-------|
| 3.2 | Node ID            | 3-151 |

| 3.3               | Target ID determination                        | 3-152  |
|-------------------|------------------------------------------------|--------|
| 3.4               | Network layer flow examples                    | 3-155  |
| <b>Chapter 4</b>  | <b>Coherence Protocol</b>                      |        |
| 4.1               | Cache line states                              | 4-160  |
| 4.2               | Request types                                  | 4-162  |
| 4.3               | Snoop request types                            | 4-191  |
| 4.4               | Request types and corresponding Snoop requests | 4-194  |
| 4.5               | Response types                                 | 4-197  |
| 4.6               | Silent cache state transitions                 | 4-209  |
| 4.7               | Cache state transitions at a Requester         | 4-210  |
| 4.8               | Cache state transitions at a Snoopee           | 4-221  |
| 4.9               | Returning Data with Snoop response             | 4-240  |
| 4.10              | Do not transition to SD                        | 4-241  |
| 4.11              | Hazard conditions                              | 4-242  |
| <b>Chapter 5</b>  | <b>Interconnect Protocol Flows</b>             |        |
| 5.1               | Read transaction flows                         | 5-246  |
| 5.2               | Dataless transaction flows                     | 5-256  |
| 5.3               | Write transaction flows                        | 5-260  |
| 5.4               | Atomic transaction flows                       | 5-263  |
| 5.5               | Stash transaction flows                        | 5-270  |
| 5.6               | Hazard handling examples                       | 5-273  |
| <b>Chapter 6</b>  | <b>Exclusive accesses</b>                      |        |
| 6.1               | Overview                                       | 6-282  |
| 6.2               | Exclusive monitors                             | 6-283  |
| 6.3               | Exclusive transactions                         | 6-286  |
| <b>Chapter 7</b>  | <b>Cache Stashing</b>                          |        |
| 7.1               | Overview                                       | 7-294  |
| 7.2               | Write with Stash hint                          | 7-296  |
| 7.3               | Independent Stash request                      | 7-297  |
| 7.4               | Stash target identifiers                       | 7-299  |
| 7.5               | Stash messages                                 | 7-300  |
| <b>Chapter 8</b>  | <b>DVM Operations</b>                          |        |
| 8.1               | DVM transaction flow                           | 8-304  |
| 8.2               | DVM Operation types                            | 8-315  |
| 8.3               | DVM Operations                                 | 8-322  |
| <b>Chapter 9</b>  | <b>Error Handling</b>                          |        |
| 9.1               | Error types                                    | 9-334  |
| 9.2               | Error response fields                          | 9-335  |
| 9.3               | Errors and transaction structure               | 9-336  |
| 9.4               | Error response use by transaction type         | 9-337  |
| 9.5               | Poison                                         | 9-347  |
| 9.6               | Data Check                                     | 9-348  |
| 9.7               | Use of interface parity                        | 9-349  |
| 9.8               | Interoperability of Poison and DataCheck       | 9-352  |
| 9.9               | Hardware and software error categories         | 9-353  |
| <b>Chapter 10</b> | <b>Quality of Service</b>                      |        |
| 10.1              | Overview                                       | 10-356 |
| 10.2              | QoS priority value                             | 10-357 |
| 10.3              | Repeating a transaction with higher QoS value  | 10-358 |

| <b>Chapter 11</b> | <b>System Debug, Trace, and Monitoring</b>           |        |
|-------------------|------------------------------------------------------|--------|
| 11.1              | Data Source indication                               | 11-360 |
| 11.2              | SLC replacement hint                                 | 11-363 |
| 11.3              | MPAM                                                 | 11-365 |
| 11.4              | Completer Busy                                       | 11-367 |
| 11.5              | Trace Tag                                            | 11-368 |
| <b>Chapter 12</b> | <b>Memory Tagging</b>                                |        |
| 12.1              | Introduction                                         | 12-372 |
| 12.2              | Message extensions                                   | 12-373 |
| 12.3              | Tag coherency                                        | 12-374 |
| 12.4              | Read transaction rules                               | 12-375 |
| 12.5              | Write transactions                                   | 12-378 |
| 12.6              | Dataless transactions                                | 12-380 |
| 12.7              | Atomic transactions                                  | 12-381 |
| 12.8              | Stash transactions                                   | 12-382 |
| 12.9              | Snoop requests                                       | 12-383 |
| 12.10             | Home to Subordinate transactions                     | 12-385 |
| 12.11             | Error response                                       | 12-386 |
| 12.12             | Requests and permitted tag operations                | 12-388 |
| 12.13             | TagOp field use summary                              | 12-390 |
| <b>Chapter 13</b> | <b>Link Layer</b>                                    |        |
| 13.1              | Introduction                                         | 13-394 |
| 13.2              | Link                                                 | 13-395 |
| 13.3              | Flit                                                 | 13-396 |
| 13.4              | Channel                                              | 13-397 |
| 13.5              | Port                                                 | 13-399 |
| 13.6              | Node interface definitions                           | 13-400 |
| 13.7              | Increasing inter-port bandwidth                      | 13-402 |
| 13.8              | Channel interface signals                            | 13-406 |
| 13.9              | Flit packet definitions                              | 13-410 |
| 13.10             | Protocol flit fields                                 | 13-416 |
| 13.11             | Link flit                                            | 13-442 |
| <b>Chapter 14</b> | <b>Link Handshake</b>                                |        |
| 14.1              | Clock, and initialization                            | 14-444 |
| 14.2              | Link layer Credit                                    | 14-445 |
| 14.3              | Low power signaling                                  | 14-446 |
| 14.4              | Flit level clock gating                              | 14-447 |
| 14.5              | Interface activation and deactivation                | 14-448 |
| 14.6              | Transmit and receive link interaction                | 14-454 |
| 14.7              | Protocol layer activity indication                   | 14-460 |
| <b>Chapter 15</b> | <b>System Coherency Interface</b>                    |        |
| 15.1              | Overview                                             | 15-466 |
| 15.2              | Handshake                                            | 15-467 |
| <b>Chapter 16</b> | <b>Properties, Parameters, and Broadcast Signals</b> |        |
| 16.1              | Interface properties and parameters                  | 16-470 |
| 16.2              | Optional interface broadcast signals                 | 16-474 |
| 16.3              | Atomic transaction support                           | 16-478 |
| <b>Appendix A</b> | <b>Message Field Mappings</b>                        |        |
| A.1               | Request message field mappings                       | A-483  |
| A.2               | Response message field mappings                      | A-488  |
| A.3               | Data message field mappings                          | A-489  |
| A.4               | Snoop Request message field mappings                 | A-490  |

| <b>Appendix B</b> | <b>Communicating Nodes</b>   |       |
|-------------------|------------------------------|-------|
| B.1               | Request communicating nodes  | B-492 |
| B.2               | Snoop communicating nodes    | B-494 |
| B.3               | Response communicating nodes | B-495 |
| B.4               | Data communicating nodes     | B-496 |
| <b>Appendix C</b> | <b>Revisions</b>             |       |
|                   | <b>Glossary</b>              |       |

# Preface

This preface introduces the *AMBA 5 CHI Architecture Specification*. It contains the following sections:

- *About this specification* on page x
- *Using this specification* on page x
- *Conventions* on page xii
- *Additional reading* on page xiv
- *Feedback* on page xv

## About this specification

This specification describes the AMBA 5 *Coherent Hub Interface* (CHI) architecture.

### Intended audience

This specification is written for hardware and software engineers who want to become familiar with the CHI architecture and design systems and modules that are compatible with the CHI architecture.

### Using this specification

This book is organized into the following chapters:

# Chapter 1 Introduction

Read this for an introduction to the CHI architecture and the terminology used in this specification.

## Chapter 2 Transactions

Read this for an overview of the communication channels between nodes, the associated packet fields, transaction structures, transaction ID flows, and the supported transaction ordering.

## Chapter 3 Network Layer

Read this for a description of the Network layer that is responsible for determining the node ID of a destination node.

## Chapter 4 Coherence Protocol

Read this for an introduction to the coherence protocol.

## Chapter 5 Interconnect Protocol Flows

Read this for examples of protocol flows for different transaction types.

## Chapter 6 Exclusive accesses

Read this for a description of the mechanisms that the architecture includes to support Exclusive accesses.

## Chapter 7 Cache Stashing

Read this for a description of the cache stashing mechanism whereby data can be installed in a cache.

## Chapter 8 DVM Operations

Read this for a description of DVM operations that the protocol uses to manage virtual memory.

## Chapter 9 Error Handling

Read this for a description of the error response requirements.

## Chapter 10 Quality of Service

Read this for a description of the mechanisms that the protocol includes to support *Quality of Service* (QoS).

## Chapter 11 System Debug, Trace, and Monitoring

Read this for a description of the mechanisms that provide additional support for the debugging, tracing, and performance measurement of systems.

## Chapter 12 Memory Tagging

Read this for a description of the *Memory Tagging Extension* (MTE) that provides a mechanism to check the correct usage of data held in memory.

# Chapter 13 Link Layer

Read this for a description of the Link layer that provides a mechanism for packet based communication between protocol nodes and the interconnect.

## Chapter 14 Link Handshake

Read this for a description of the Link layer handshake requirements.

# Chapter 15 System Coherency Interface

Read this for a description of the interface signals that support connecting and disconnecting components from both the Coherency and DVM domains.

# Chapter 16 Properties, Parameters, and Broadcast Signals

Read this for a description of the optional signals that provide flexibility in configuring optional interface properties.

## Appendix A Message Field Mappings

Read this for the field mappings for messages.

## Appendix B Communicating Nodes

Read this for the node pairs that can legally communicate within the protocol.

## Appendix C Revisions

Read this for a description of the technical changes between released issues of this specification.

## Glossary

Read this for definitions of terms used in this specification.

## Conventions

The following sections describe conventions that this specification can use:

- [Typographical conventions](#)
- [Timing diagrams](#)
- [Signals on page xiv](#)
- [Numbers on page xiv](#)

### Typographical conventions

The typographical conventions are:

| <i>italic</i>  | Highlights important notes, introduces special terminology, and denotes internal cross-references and citations.                                                                                                                                          |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>bold</b>    | Denotes signal names, and is used for terms in descriptive lists, where appropriate.                                                                                                                                                                      |
| monospace      | Used for assembler syntax descriptions, pseudocode, and source code examples.<br>Also used in the main text for instruction mnemonics and for references to other items appearing in assembler syntax descriptions, pseudocode, and source code examples. |
| SMALL CAPITALS | Used for a few terms that have specific technical meanings.                                                                                                                                                                                               |

#### Timing diagrams

The components used in timing diagrams are explained in the figure, [Key to timing diagram conventions](#). Variations have clear labels, when they occur. Do not assume any timing information that is not explicit in the diagrams.

Shaded bus and signal areas are undefined, so the bus or signal can assume any value within the shaded area at that time. The actual level is unimportant and does not affect normal operation.

![](79d61011f426d34fb542d86176482d2c_img.jpg)

Timing diagram conventions:

- Clock
- HIGH to LOW
- Transient
- HIGH/LOW to HIGH
- Bus stable
- Bus to high impedance
- Bus change
- High impedance to stable bus

#### Key to timing diagram conventions

Timing diagrams sometimes show single-bit signals as HIGH and LOW at the same time and they look similar to the bus change that the [Key to timing diagram conventions](#) figure shows. If a timing diagram shows a single-bit signal in this way then its value does not affect the accompanying description.

#### Time-Space diagrams

The *Key to Time-Space diagram conventions* figure explains the format used to illustrate protocol flow.

![Time-Space diagram illustrating protocol flow. The vertical axis represents Time, and the horizontal axis represents Space. Protocol nodes are RN-F and HN-F. The diagram shows the Initial cache state (vertical line) and a Cache state change (I->UC) leading to Deallocation. Allocation occurs, followed by a REQ message flow. The lifetime of a transaction is shown as a shaded rectangle. A RESP message flow is shown. A diamond shape indicates Allocated but forward progress is blocked. A green diamond shape indicates Forward progress is unblocked.](98ee20ceb85cd84e2415b20b1eda1bcf_img.jpg)

Time-Space diagram illustrating protocol flow. The vertical axis represents Time, and the horizontal axis represents Space. Protocol nodes are RN-F and HN-F. The diagram shows the Initial cache state (vertical line) and a Cache state change (I->UC) leading to Deallocation. Allocation occurs, followed by a REQ message flow. The lifetime of a transaction is shown as a shaded rectangle. A RESP message flow is shown. A diamond shape indicates Allocated but forward progress is blocked. A green diamond shape indicates Forward progress is unblocked.

#### Key to Time-Space diagram conventions

In the Time-Space diagram:

- The protocol nodes are positioned along the horizontal axis and time is indicated vertically, top to bottom.
- The lifetime of a transaction at a protocol node is shown by an elongated shaded rectangle along the time axis from allocation to the deallocation time.
- The initial cache state at the node is shown at the top.
- The diamond shape on the timeline indicates arrival of a request and whether its processing is blocked waiting for another event to complete.
- The cache state transition, upon the occurrence of an event, is indicated by I->UC.

### Signals

The signal conventions are:

**Signal level** The level of an asserted signal depends on whether the signal is active-HIGH or active-LOW. Asserted means:

- HIGH for active-HIGH signals.
- LOW for active-LOW signals.

**Lowercase n** At the start or end of a signal name denotes an active-LOW signal.

#### Numbers

Numbers are normally written in decimal. Binary numbers are preceded by `0b`, and hexadecimal numbers by `0x`. Both are written in a monospace font.

## Additional reading

This section lists relevant publications from Arm.

See *Arm Developer* <https://developer.arm.com/documentation>, for access to Arm documentation.

### Arm publications

- *AMBA® AXI and ACE Protocol Specification* (ARM IHI 0022).

## Feedback

Arm welcomes feedback on its documentation.

### Feedback on this specification

If you have comments on the content of this specification, send an e-mail to [errata@arm.com](mailto:errata@arm.com). Give:

- The title, *AMBA 5 CHI Architecture Specification*.
- The number, ARM IHI 0050E.b.
- The page numbers to which your comments apply.
- A concise explanation of your comments.

Arm also welcomes general suggestions for additions and improvements.

### Progressive terminology commitment

Arm values inclusive communities. Arm recognizes that we and our industry have used terms that can be offensive.

Arm strives to lead the industry and create change.

Previous issues of this document included terms that can be offensive. We have replaced these terms. If you find offensive terms in this document, please contact [terms@arm.com](mailto:terms@arm.com).



# Chapter 1Introduction

This chapter introduces the CHI architecture and the terminology used throughout this specification. It contains the following sections:

- [Architecture overview on page 1-18](#)
- [Topology on page 1-20](#)
- [Terminology on page 1-21](#)
- [Transaction classification on page 1-24](#)
- [Coherence overview on page 1-26](#)
- [Component naming on page 1-28](#)
- [Read data source on page 1-30](#)

## 1.1 Architecture overview

The CHI architecture provides a comprehensive layered specification to build small, medium, and large systems comprising of multiple components using a scalable coherent hub interface and on-chip interconnect. The CHI architecture permits flexibility on the topology of the component connections, which can be driven from the system performance, power, and area requirements.

### 1.1.1 Components

The components of CHI-based systems can comprise of standalone processors, processor clusters, graphic processors, memory controllers, I/O bridges, PCIe subsystems, and the interconnect itself.

The key features of the architecture are:

- Scalable architecture, enabling modular designs that scale from small to large systems.
- Independent layered approach, comprising of Protocol, Network, and Link layer, with distinct functionalities.
- Packet-based communication.
- All transactions handled by an interconnect-based Home Node that co-ordinates required snoops, cache, and memory accesses.
- The CHI coherence protocol supports:
  - Coherency granule of 64-byte cache line.
  - Snoop filter and directory based systems for snoop scaling.
  - Both MESI and MOESI cache models with forwarding of data from any cache state.
  - Additional partial and empty cache line states.
- The CHI transaction set includes:
  - Enriched transaction types that permit performance, area, and power efficient system cache implementation.
  - Support for atomic operations and synchronization within the interconnect.
  - Support for the efficient execution of Exclusive accesses.
  - Transactions for the efficient movement and placement of data, to move data in a timely manner closer to the point of anticipated use.
  - Virtual memory management through *Distributed Virtual Memory (DVM)* operations.
- Request retry to manage protocol resources.
- Support for end-to-end *Quality of Service (QoS)*.
- Support for the Arm *Memory Tagging Extension (MTE)*.
- Configurable data width to meet the requirements of the system.
- ARM TrustZone™ support on a transaction-by-transaction basis.
- Optimized transaction flow for coherent writes with a producer-consumer ordering model.
- Error reporting and propagation across components and interconnect for system reliability and integrity.
- Handling sub cache line data errors using Data Poisoning and per byte error indication.
- Power-aware signaling on the component interface:
  - Enabling flit-level clock gating.
  - Component activation and deactivation sequence for clock-gate and power-gate control.
  - Protocol activity indication for power and clock control.

### 1.1.2 Architecture layers

Functionality is grouped into the following layers:

- Protocol
- Network
- Link

Table 1-1 describes the primary function of each layer.

Table 1-1 Layers of the CHI architecture

| Layer    | Communication granularity | Primary function                                                                                                                                                                                                                                                                                                                                                                                            |
|----------|---------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Protocol | Transaction               | The Protocol layer is the topmost layer in the CHI architecture. The function of the Protocol layer is to: <ul><li>Generate and process requests and responses at the protocol nodes.</li><li>Define the permitted cache state transitions at the protocol nodes that include caches.</li><li>Define the transaction flows for each request type.</li><li>Manage the protocol level flow control.</li></ul> |
| Network  | Packet                    | The function of the Network layer is to: <ul><li>Packetize the protocol message.</li><li>Determine the source and target Node IDs required to route the packet over the interconnect to the required destination and add to the packet.</li></ul>                                                                                                                                                           |
| Link     | Flit                      | The function of the Link layer is to: <ul><li>Provide flow control between network devices.</li><li>Manage link channels to provide deadlock-free switching across the network.</li></ul>                                                                                                                                                                                                                   |

## 1.2 Topology

The CHI architecture is primarily topology-independent. However, certain topology-dependent optimizations are included in this specification to make implementation more efficient. Figure 1-1 shows three examples of topologies selected to show the range of interconnect bandwidth and scalability options that are available.

![](9260ae281f6b6470331f4a0f82dbc2b1_img.jpg)

Diagram illustrating three interconnect topologies: 4x4 Mesh, Ring, and 4x4 Crossbar.

Legend:

- Protocol node such as processor complex, Memory Controller, or I/O complex (represented by a gray circle)
- Router (represented by a white square)

**Figure 1-1 Example interconnect topologies**

**Crossbar** This topology is simple to build, and naturally provides an ordered network with low latency. It is suitable where the wire counts are still relatively small. This topology is suitable for an interconnect with a small number of nodes.

**Ring** This topology provides a good trade-off between interconnect wiring efficiency and latency. The latency increases linearly with the number of nodes on the ring. This topology is suitable for a medium size interconnect.

**Mesh** This topology provides greater bandwidth at the cost of more wires. It is very modular and can be easily scaled to larger systems by adding more rows and columns of switches. This topology is suitable for a larger scale interconnect.

## 1.3 Terminology

The following terms have a specific meaning in this specification:

### Transaction

A transaction carries out a single operation. Typically, a transaction either reads from memory or writes to memory.

### Message

A message is a protocol layer term that defines the granule-of-exchange between two components. Examples are:

- Request
- Data response
- Snoop request

A single Data response message might be made up of a number of packets.

### Packet

A packet is the granule-of-transfer over the interconnect between endpoints. A message might be made up of one or more packets. For example, a single Data response message can be made up of 1 to 4 packets. Each packet contains routing information, such as destination ID and source ID that enables it to be routed independently over the interconnect.

### Flit

*Flow control unit* (Flit) is the smallest flow control unit. A packet can be made up of one or more flits. All the flits of a given packet follow the same path through the interconnect.

— Note —  
For CHI, all packets consist of a single flit.

### Phit

*Physical layer transfer unit* (Phit) is defined as one transfer between two adjacent network devices. A flit can be made up of one or more phits.

— Note —  
For CHI, all flits consist of a single phit.

### PoS

*Point of Serialization* (PoS) is a point within the interconnect where the ordering between Requests from different agents is determined.

### PoC

*Point of Coherence* (PoC) is a point at which all agents that can access memory are guaranteed to see the same copy of a memory location. In a typical CHI-based system, it is the HN-F in the interconnect.

### PoP

*Point of Persistence* (PoP) is the point in a memory system, if it exists, at or beyond the Point of Coherency, where a write to memory is maintained when system power is removed, and reliably recovered when power is restored to the affected locations in memory.

### Downstream cache

A downstream cache is defined from the perspective of a Request Node. A downstream cache for a Request, is a cache that the Request accesses using CHI Request transactions. A Request Node can send a Request with data to allocate data into a downstream cache.

| Requester         | A component that starts a transaction by issuing a Request message. The term Requester can be used for a component that independently initiates transactions. The term Requester can also be used for an interconnect component that issues a downstream Request message independently or as a side-effect of other transactions that are occurring in the system. |
|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Completer         | Any component that responds to a transaction it receives from another component. A Completer can either be an interconnect component, such as Home Node or a Misc Node, or a component, such as a Subordinate, that is outside of the interconnect.                                                                                                                |
| Subordinate       | An agent that receives transactions and completes them appropriately. Typically, a Subordinate is the most downstream agent in a system. A Subordinate can also be referred to as a Completer or Endpoint.                                                                                                                                                         |
| Endpoint          | Another name for a Subordinate component. As the name implies, an endpoint is the final destination for a transaction.                                                                                                                                                                                                                                             |
| Protocol Credit   | A credit, or guarantee, from a Completer that it will accept a transaction.                                                                                                                                                                                                                                                                                        |
| Link layer Credit | A credit, or guarantee, that a flit will be accepted on the other side of the link. A <i>Link layer Credit</i> (L-Credit) is a credit for a single hop at the Link layer.                                                                                                                                                                                          |
| ICN               | <i>Interconnect</i> (ICN) is the CHI transport mechanism that is used for communication between protocol nodes. An ICN might include a fabric of switches connected in a ring, mesh, crossbar, or some other topology. The ICN might include protocol nodes such as Home Node and Misc Node. The topology of the ICN is IMPLEMENTATION DEFINED.                    |
| IPA               | <i>Intermediate Physical Address</i> (IPA). In two stage address translation: <ul><li>Stage one results in an Intermediate Physical Address.</li><li>Stage two provides the Physical Address.</li></ul>                                                                                                                                                            |
| RN                | <i>Request Node</i> (RN) generates protocol transactions, including reads and writes, to the interconnect.                                                                                                                                                                                                                                                         |
| HN                | <i>Home Node</i> (HN) is a node located within the interconnect that receives protocol transactions from Request Nodes, completes the required Coherency action, and returns a Response.                                                                                                                                                                           |
| SN                | <i>Subordinate Node</i> (SN) is a node that receives a Request from a Home Node, completes the required action, and returns a Response.                                                                                                                                                                                                                            |
| MN                | <i>Misc or Miscellaneous Node</i> (MN) is a node located within the interconnect that receives DVM messages from Request Nodes, completes the required action, and returns a Response.                                                                                                                                                                             |

### **IO Coherent node**

A Request Node that generates a subset of Snoopable requests in addition to Non-snoopable requests. The Snoopable requests that an IO Coherent node generates do not result in the caching of the received data in a coherent state. Therefore, an IO Coherent node does not receive any Snoop requests.

### **Snoopee**

A Request Node that is receiving a snoop.

### **Write-Invalidate protocol**

A protocol in which a Request Node writing to a cache line that is shared in the system must invalidate all the shared copies before proceeding with the write. The CHI protocol is a Write-Invalidate protocol.

### **In a timely manner**

The protocol cannot define an absolute time within which something must occur. However, in a sufficiently idle system, it will make progress and complete without requiring any explicit action.

### **Inapplicable**

A field value that indicates that the field is not used in the processing of the message.

## 1.4 Transaction classification

The protocol transactions that this specification supports, and their major classification, are as follows:

### Read

- ReadNoSnp, ReadNoSnpSep
- ReadOnce
- ReadOnceCleanInvalid
- ReadOnceMakeInvalid
- ReadClean
- ReadNotSharedDirty
- ReadShared
- ReadUnique
- ReadPreferUnique
- MakeReadUnique

### Dataless

- CleanUnique
- MakeUnique
- Evict
- StashOnceUnique, StashOnceSepUnique
- StashOnceShared, StashOnceSepShared
- CleanShared
- CleanSharedPersist, CleanSharedPersistSep
- CleanInvalid
- MakeInvalid

### Write

- WriteNoSnpPtl, WriteNoSnpFull, WriteNoSnpZero
- WriteUniquePtl, WriteUniqueFull, WriteUniqueZero
- WriteUniquePtlStash, WriteUniqueFullStash
- WriteBackPtl, WriteBackFull
- WriteCleanFull
- WriteEvictFull, WriteEvictOrEvict

### Combined Write

- WriteNoSnpPtlCleanInv, WriteNoSnpPtlCleanSh, WriteNoSnpPtlCleanShPerSep
- WriteNoSnpFullCleanInv, WriteNoSnpFullCleanSh, WriteNoSnpFullCleanShPerSep
- WriteUniquePtlCleanSh, WriteUniquePtlCleanShPerSep
- WriteUniqueFullCleanSh, WriteUniqueFullCleanShPerSep
- WriteBackFullCleanInv, WriteBackFullCleanSh, WriteBackFullCleanShPerSep
- WriteCleanFullCleanSh, WriteCleanFullCleanShPerSep

### Atomic

- AtomicStore
- AtomicLoad
- AtomicSwap
- AtomicCompare

### Other

- DVMOp
- PrefetchTgt
- PCrdReturn

### Snoop

- SnpOnceFwd
- SnpOnce
- SnpStashUnique
- SnpStashShared
- SnpCleanFwd
- SnpClean
- SnpNotSharedDirtyFwd
- SnpNotSharedDirty
- SnpSharedFwd
- SnpShared
- SnpUniqueFwd
- SnpUnique
- SnpPreferUniqueFwd
- SnpPreferUnique
- SnpUniqueStash
- SnpCleanShared
- SnpCleanInvalid
- SnpMakeInvalid
- SnpMakeInvalidStash
- SnpQuery
- SnpDVMOp

In this specification, unless specifically stated otherwise:

- ReadOnce\* represents ReadOnce, ReadOnceCleanInvalid and ReadOnceMakeInvalid.
- WriteNoSnp represents both WriteNoSnpPtl and WriteNoSnpFull.
- WriteUnique represents WriteUniquePtl, WriteUniqueFull, WriteUniquePtlStash and WriteUniqueFullStash.
- WriteBack represents both WriteBackPtl and WriteBackFull.
- StashOnce represents both StashOnceUnique and StashOnceShared.
- StashOnceSep represents both StashOnceSepUnique and StashOnceSepShared.
- StashOnce\* represents both StashOnce and StashOnceSep.
- StashOnce\*Unique represents both StashOnceUnique and StashOnceSepUnique.
- StashOnce\*Shared represents both StashOnceShared and StashOnceSepShared.
- CleanSharedPersist\* represents both CleanSharedPersist and CleanSharedPersistSep.
- SnpStash represents both SnpStashUnique and SnpStashShared.
- DBIDResp\* represents both DBIDResp and DBIDRespOrd.

## 1.5 Coherence overview

Hardware coherency enables the sharing of memory by system components without the requirement to perform software cache maintenance to maintain coherency between caches.

Regions of memory are coherent if writes to the same memory location by two components are observable in the same order by all components.

### 1.5.1 Coherency model

Figure 1-2 shows an example coherent system that includes three Requester components, each with a local cache and coherent protocol node. The protocol permits cached copies of the same memory location to reside in the local cache of one or more Requester components.

![Diagram illustrating the Coherency Model (Figure 1-2). Three Requester components (Requester 1, Requester 2, Requester 3) each have an RN-F Cache and an RN-F Coherent Protocol Node (CPN). These CPNs connect to a central ICN (Inter-Component Network). The ICN connects to Main memory and an SN-F Subordinate 1 component. The ICN also connects to an Optional cache.](62a4c9055642dbb00663e633332f04d3_img.jpg)

Diagram illustrating the Coherency Model (Figure 1-2). Three Requester components (Requester 1, Requester 2, Requester 3) each have an RN-F Cache and an RN-F Coherent Protocol Node (CPN). These CPNs connect to a central ICN (Inter-Component Network). The ICN connects to Main memory and an SN-F Subordinate 1 component. The ICN also connects to an Optional cache.

Figure 1-2 Example coherency model

The coherence protocol ensures that all Requesters observe the correct data value at any given address location by enforcing that no more than one copy exists whenever a store occurs to the location. After each store to a location, other Requesters can obtain a new copy of the data for their own local cache, to permit multiple cached copies to exist.

All coherency is maintained at cache line granularity. A cache line is defined as a 64-byte aligned memory region that is 64 bytes in size.

The protocol does not require main memory to be up to date at all times. Main memory is only required to be updated before a copy of the memory location is no longer held in any cache.

— Note —

Although not a requirement, it is acceptable to update main memory while cached copies still exist.

The protocol enables Requester components to determine whether a cache line is the only copy of a particular memory location, or if there might be other copies of the same location, so that:

- If a cache line is the only copy, a Requester component can change the value of the cache line without notifying any other Requester components in the system.
- If a cache line might also be present in another cache, a Requester component must notify the other caches using an appropriate transaction.

### 1.5.2 Cache state model

To determine whether an action is required when a component accesses a cache line, the protocol defines cache states. Each cache state is based on the following cache line characteristics:

**Valid, Invalid** When Valid, the cache line is present in the cache. When Invalid, the cache line is not present in the cache.

**Unique, Shared** When Unique, the cache line exists only in this cache. When Shared, the cache line might exist in more than one cache, but this is not guaranteed.

**Clean, Dirty** When Clean, the cache does not have responsibility for updating main memory. When Dirty, the cache line has been modified with respect to main memory, and this cache must ensure that main memory is eventually updated.

**Full, Partial, Empty** A Full cache line has all bytes valid. A Partial cache line might have some bytes valid, where some include none or all bytes. An Empty cache line has no bytes valid.

Figure 1-3 shows the seven state cache model. *Cache line states on page 4-160* gives further information about each cache state.

A valid cache state name that is not Partial or Empty is considered to be Full. In Figure 1-3, UC, UD, SC, and SD are all Full cache line states.

![](2bb33687a0af0373c35b56f023a2a1d4_img.jpg)

|       |     | Valid  |        | Invalid |
|-------|-----|--------|--------|---------|
|       |     | Unique | Shared |         |
| Clean | UC  | SC     |        |         |
|       | UCE |        |        |         |
| Dirty | UD  | SD     |        | I       |
|       | UDP |        |        |         |

Figure 1-3 Cache state model

## 1.6 Component naming

Components are classified by CHI protocol node type:

**RN** Request Node. Generates protocol transactions, including reads and writes, to the interconnect.  
A Request Node is further categorized as:

- **RN-F** Fully Coherent Request Node:
  - Includes a hardware-coherent cache.
  - Permitted to generate all transactions defined by the protocol.
  - Supports all Snoop transactions.
- **RN-D** IO Coherent Request Node with DVM support:
  - Does not include a hardware-coherent cache.
  - Receives DVM transactions.
  - Generates a subset of transactions defined by the protocol.
- **RN-I** IO Coherent Request Node:
  - Does not include a hardware-coherent cache.
  - Does not receive DVM transactions.
  - Generates a subset of transactions defined by the protocol.
  - Does not require snoop functionality.

**HN** Home Node. Node located within the interconnect that receives protocol transactions from Request Nodes.  
A Home Node is further categorized as:

- **HN-F** Fully Coherent Home Node:
  - Expected to receive all request types, except DVMOp.
  - Includes a *Point of Coherence (PoC)* that manages coherency by snooping the required RN-Fs, consolidating the Snoop responses for a transaction, and sending a single response to the requesting Request Node.
  - Expected to be the *Point of Serialization (PoS)* that manages order between memory requests.
  - Might include a directory or snoop filter to reduce redundant snoops.

**Note**  
IMPLEMENTATION SPECIFIC, can include an integrated ICN cache.

- **HN-I** Non-coherent Home Node:
  - Processes a limited subset of request types defined by the protocol.
  - Does not include a PoC and is not capable of processing a Snoopable request. On receipt of a Snoopable request, it must respond with a protocol compliant message.
  - Expected to be the PoS that manages order between IO requests targeting the IO subsystem.

**MN** Miscellaneous Node. Receives a DVM transaction from a Request Node, completes the required action, and returns a response.

**SN** Subordinate Node. A Subordinate Node receives a request from a Home Node, completes the required action, and returns a response.

A Subordinate Node is further categorized as:

**SN-F** A Subordinate Node type used for Normal memory. It can process Non-snoopable Read, Write, and Atomic requests, including exclusive variants of them, and *Cache Maintenance Operation* (CMO) requests.

**SN-I** A Subordinate Node type used for peripherals or Normal memory. It can process Non-snoopable Read, Write, and Atomic requests, including exclusive variants of them, and CMO requests.

Figure 1-4 shows various protocol node types connected through an interconnect.

![](1b1bb497e39fcc025a3fc8bd4fc78d9a_img.jpg)

Diagram illustrating various protocol node types connected through an Interconnect (ICN).

The Interconnect (ICN) connects the following nodes:

- Requesters (Fully coherent): RN-F0, RN-F1, RN-F2.
- Requester (IO coherent): RN-I.
- Subordinates (Peripheral and/or Normal Memory): SN-I.
- Subordinates (Normal Memory): SN-F.
- Home Nodes (HN-I, HN-F, HN-F).
- Maintenance Node (MN).

The diagram shows connections between these nodes via the Interconnect (ICN).

Figure 1-4 Protocol node examples

## 1.7 Read data source

In a CHI-based system, a Read request can obtain data from different sources. Figure 1-5 shows that these sources are:

- Cache within the interconnect
- Subordinate Node
- Peer RN-F

![Diagram illustrating possible data providers for a read request in a CHI-based system. The Requester sends a Request to the Home. The Home interacts with the ICN (Interconnect Controller). The Home also interacts with a Subordinate Node. The Home interacts with two RN-F (Remote Node-F) nodes. The RN-F nodes are shaded, indicating they are Data providers. The RN-F nodes send Data back to the Home, and the Home sends Data back to the Requester. The Subordinate Node sends Data back to the Home, and the Home sends Data back to the Requester. The RN-F nodes also show a Snoop connection to the ICN.](99938fa8d7d80af041634eba601e418b_img.jpg)

Diagram illustrating possible data providers for a read request in a CHI-based system. The Requester sends a Request to the Home. The Home interacts with the ICN (Interconnect Controller). The Home also interacts with a Subordinate Node. The Home interacts with two RN-F (Remote Node-F) nodes. The RN-F nodes are shaded, indicating they are Data providers. The RN-F nodes send Data back to the Home, and the Home sends Data back to the Requester. The Subordinate Node sends Data back to the Home, and the Home sends Data back to the Requester. The RN-F nodes also show a Snoop connection to the ICN.

Figure 1-5 Possible Data providers for a Read request

One option for Home is to request that the RN-F or Subordinate Node returns data only to Home. The Home in turn forwards a copy of the received data to the Requester. A hop in obtaining Data in this Read transaction flow can be removed if the Data provider is enabled to forward the Data response directly to the Requester instead of via the Home.

The Read and Write latency saving and the interconnect bandwidth utilization reduction techniques supported in this specification, which use the reduction of the number of hops, can be categorized as:

### *Direct Memory Transfer (DMT)*

Defines the feature that permits the Subordinate Node to send data directly to the Requester.

### *Direct Cache Transfer (DCT)*

Defines the feature which permits a peer RN-F to send data directly to the Requester.

The Data provider in the DCT Read transaction flows has to inform the Home that it has sent Data to the Requester and, in some cases, it also has to send a copy of data to the Home.

### *Direct Write-data Transfer (DWT)*

Defines the feature which permits the requesting Request Node to send write data directly to the Subordinate Node.

# Chapter 2 Transactions

This chapter gives an overview of the communication channels between nodes, the associated packet fields, and the transaction structure. It contains the following sections:

- [Channels overview on page 2-32](#)
- [Channel fields on page 2-33](#)
- [Transaction structure on page 2-40](#)
- [Transaction identifier fields on page 2-86](#)
- [Details of transaction identifier fields on page 2-87](#)
- [Transaction identifier field flows on page 2-92](#)
- [Logical Processor Identifier on page 2-113](#)
- [Ordering on page 2-114](#)
- [Address, Control, and Data on page 2-125](#)
- [Data transfer on page 2-134](#)
- [Request Retry on page 2-145](#)

## 2.1 Channels overview

Communication between nodes is channel-based. Table 2-1 shows the channel naming and the channel designations at the Request Nodes and Subordinate Nodes.

This section uses shorthand naming for the channels to describe the transaction structure. Table 2-1 shows the shorthand name and the physical channel name that exists on the Request Node or Subordinate Node component.

See [Channel on page 13-397](#) for the mapping of physical channels on the Request Node and Subordinate Node components.

Table 2-1 Channel naming and designation at the RN and SN nodes

| Channel | RN channel designation                                                               | SN channel designation                                              |
|---------|--------------------------------------------------------------------------------------|---------------------------------------------------------------------|
| REQ     | TXREQ. Outbound Request.                                                             | RXREQ. Inbound Request.                                             |
| WDAT    | TXDAT. Outbound Data.<br>Used for write data, atomic data, snoop data, forward data. | RXDAT. Inbound Data.<br>Used for write data, atomic data.           |
| SRSP    | TXRSP. Outbound Response.<br>Used for snoop response and completion acknowledge.     | -                                                                   |
| CRSP    | RXRSP. Inbound Response.<br>Used for responses from the Completer.                   | TXRSP. Outbound Response.<br>Used for responses from the Completer. |
| RDAT    | RXDAT. Inbound Data.<br>Used for read data, atomic data.                             | TXDAT. Outbound Data.<br>Used for read data, atomic data.           |
| SNP     | RXSMP. Inbound Snoop request.                                                        | -                                                                   |

## 2.2 Channel fields

This section gives a brief overview of the channel fields and indicates which fields affect the transaction structure. The fields associated with each channel are described in the following sections:

- [Transaction request fields](#)
- [Snoop request fields on page 2-36](#)
- [Data fields on page 2-37](#)
- [Response fields on page 2-39](#)

### 2.2.1 Transaction request fields

Table 2-2 shows the fields associated with a request packet.

The term 'transaction structure' is used to describe the different packets that build a transaction. The transaction structure can vary depending on a number of factors. Table 2-2 shows which Request fields can affect the transaction structure.

More information on the different transaction structures can be found in [Transaction structure on page 2-40](#) and [Flit packet definitions on page 13-410](#).

Table 2-2 Request channel fields

| Field       | Affects structure | Description                                                                                                                                                                                                           |
|-------------|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| QoS         | No                | Quality of Service priority. Specifies one of 16 possible priority levels for the transaction with ascending values of QoS indicating higher priority levels. See <a href="#">Chapter 10 Quality of Service</a> .     |
| TgtID       | No                | Target ID. The node ID of the port on the component to which the packet is targeted. See <a href="#">Details of transaction identifier fields on page 2-87</a> and <a href="#">System Address Map on page 3-150</a> . |
| SrcID       | No                | Source ID. The node ID of the port on the component from which the packet was sent. See <a href="#">Details of transaction identifier fields on page 2-87</a> .                                                       |
| TxnID       | No                | Transaction ID. A transaction has a unique transaction ID per source node. See <a href="#">Details of transaction identifier fields on page 2-87</a> .                                                                |
| LPID        | No                | Logical Processor ID. Used with the SrcID field to uniquely identify the logical processor that generated the request. See <a href="#">Logical Processor Identifier on page 2-113</a> .                               |
| PGroupID    | No                | Persistence Group ID. Indicates the set of CleanSharedPersistSep transactions to which the request applies. See <a href="#">Persistence Group Identifier; PGroupID on page 13-418</a> .                               |
| Deep        | No                | Deep persistence. Indicates that the Persist response must not be sent until all earlier writes are written to the final destination. See <a href="#">Deep Persistent CMO on page 4-172</a> .                         |
| ReturnNID   | No                | Return Node ID. The recipient node ID for the Data response, Persist response, or TagMatch response. See <a href="#">Details of transaction identifier fields on page 2-87</a> .                                      |
| ReturnTxnID | No                | Return Transaction ID. The unique transaction ID that conveys the value of TxnID in the data response from the Subordinate. See <a href="#">Details of transaction identifier fields on page 2-87</a> .               |
| StashNID    | No                | Stash Node ID. The node ID of the Stash target. See <a href="#">Stash Node Identifier; StashNID on page 13-418</a> .                                                                                                  |

Table 2-2 Request channel fields (continued)

| Field          | Affects structure | Description                                                                                                                                                                                              |
|----------------|-------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| StashNIDValid  | Yes               | Stash Node ID Valid. Indicates that the StashNID field has a valid Stash target value. See <i>Stash Node Identifier Valid, StashNIDValid</i> on page 13-419.                                             |
| StashLPID      | No                | Stash Logical Processor ID. The ID of the logical processor at the Stash target. See <i>Stash Logical Processor Identifier, StashLPID</i> on page 13-419.                                                |
| StashLPIDValid | No                | Stash Logical Processor ID Valid. Indicates that the StashLPID field value must be considered as the Stash target. See <i>Stash Logical Processor Identifier Valid, StashLPIDValid</i> on page 13-419.   |
| StashGroupID   | No                | Stash Group ID. Indicates the set of StashOnceSep transactions to which the request applies. See <i>Stash Group Identifier, StashGroupID</i> on page 13-419.                                             |
| Opcode         | Yes               | Request opcode. Specifies the transaction type and is the primary field that determines the transaction structure. See <i>Request types</i> on page 4-162 and <i>REQ channel opcodes</i> on page 13-421. |
| Addr           | No                | Address. The address of the memory location being accessed for Read and Write requests. See <i>Address</i> on page 2-125 and <i>Address, Addr</i> on page 13-427.                                        |
| NS             | No                | Non-secure. Determines if the transaction is Non-secure or Secure. See <i>Non-secure bit</i> on page 2-125 and <i>Non-secure, NS</i> on page 13-427.                                                     |
| Size           | Yes               | Data size. Specifies the size of the data associated with the transaction. This determines the number of data packets within the transaction. See <i>Data transfer</i> on page 2-134.                    |
| AllowRetry     | Yes               | Allow Retry. Determines if the target is permitted to give a Retry response. See <i>Request Retry</i> on page 2-145.                                                                                     |
| PCrDType       | No                | Protocol Credit Type. Indicates the type of Protocol Credit being used by a request that has the AllowRetry field deasserted. See <i>Request Retry</i> on page 2-145.                                    |
| ExpCompAck     | Yes               | Expect CompAck. Indicates that the transaction will include a completion acknowledge message. See <i>Transaction structure</i> on page 2-40 and <i>Ordering</i> on page 2-114.                           |
| MemAttr        | No                | Memory attribute. Determines the memory attributes associated with the transaction. See <i>Memory Attributes</i> on page 2-126.                                                                          |
| SnpAttr        | No                | Snoop attribute. Specifies the snoop attributes associated with the transaction. See <i>Snoop Attribute</i> on page 2-132.                                                                               |
| DoDWT          | Yes               | Do Direct Write Transfer. Supports Direct Write-data Transfer and the handling of Combined Writes. See <i>Do Direct Write Transfer, DoDWT</i> on page 13-430.                                            |
| SnoopMe        | No                | Snoop Me. Indicates that Home must determine whether to send a snoop to the Requester during an Atomic transaction. See <i>Atomic transactions</i> on page 2-68.                                         |
| LikelyShared   | No                | Likely Shared. Provides an allocation hint for downstream caches. See <i>Likely Shared</i> on page 2-131.                                                                                                |
| SLCRepHint     | No                | System Level Cache Replacement Hint. Forwards cache replacement hints from the Requesters to the caches in the interconnect. See <i>SLC replacement hint</i> on page 11-363.                             |

Table 2-2 Request channel fields (continued)

| Field      | Affects structure | Description                                                                                                                                                                                                   |
|------------|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Excl       | No                | Exclusive access. Indicates that the corresponding transaction is an Exclusive access transaction. See <a href="#">Chapter 6 Exclusive accesses</a> .                                                         |
| Order      | Yes               | Order requirement. Determines the ordering requirement for this request with respect to other requests from the same agent. See <a href="#">Ordering on page 2-114</a> .                                      |
| Endian     | No                | Endianness. Indicates the endianness of data in the data packet for Atomic transactions. See <a href="#">Endianness on page 2-138</a> .                                                                       |
| TagOp      | Yes               | Tag Operation. Indicates the operation to be performed on the tags present in the corresponding DAT channel. See <a href="#">Tag Operation, TagOp on page 13-435</a> .                                        |
| TagGroupID | No                | TagGroupID. Precise contents are IMPLEMENTATION DEFINED. Typically expected to contain Exception level, TTBR value, and CPU identifier. See <a href="#">Tag Group Identifier, TagGroupID on page 13-435</a> . |
| TraceTag   | No                | Trace Tag. Provides extra support for the debugging, tracing, and performance measurement of systems. See <a href="#">Chapter 11 System Debug, Trace, and Monitoring</a> .                                    |
| MPAM       | No                | Memory System Performance Resource Partitioning and Monitoring. Efficiently utilizes the memory resources among users and monitors their use. See <a href="#">MPAM on page 11-365</a> .                       |
| RSVDC      | No                | User-defined. See <a href="#">Reserved for Customer Use, RSVDC on page 13-441</a> .                                                                                                                           |

### 2.2.2 Snoop request fields

Table 2-3 shows the Snoop request fields. Many of the Snoop request fields are the same as fields defined for the Request channel.

Table 2-3 Snoop request fields

| Field          | Affects structure | Description                                                                                                                                                              |
|----------------|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| QoS            | No                | Quality of Service priority. As defined in <i>Request channel fields</i> on page 2-33. See <i>Chapter 10 Quality of Service</i> .                                        |
| TxnID          | No                | Transaction ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                              |
| FwdNID         | No                | Forward Node ID. The node ID of the original Requester. See <i>Details of transaction identifier fields</i> on page 2-87.                                                |
| FwdTxnID       | No                | Forward Transaction ID. The transaction ID used in the Request by the original Requester. See <i>Details of transaction identifier fields</i> on page 2-87.              |
| StashLPID      | No                | Stash Logical Processor ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Stash messages</i> on page 7-300.                                           |
| StashLPIDValid | No                | Stash Logical Processor ID Valid. As defined in <i>Request channel fields</i> on page 2-33. See <i>Stash messages</i> on page 7-300.                                     |
| VMIDEExt       | No                | Virtual Machine ID Extension. See <i>DVM Operation types</i> on page 8-315.                                                                                              |
| SrcID          | No                | Source ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                                   |
| Opcode         | Yes               | Snoop opcode. See <i>Snoop request fields</i> on page 2-36 and <i>SNP channel opcodes</i> on page 13-425.                                                                |
| Addr           | No                | Address. The address of the memory location being accessed for Snoop requests. See <i>Address</i> on page 2-125 and <i>Address, Addr</i> on page 13-427.                 |
| NS             | No                | Non-secure or Secure access. As defined in <i>Request channel fields</i> on page 2-33. See <i>Non-secure bit</i> on page 2-125 and <i>Non-secure, NS</i> on page 13-427. |
| DoNotGoToSD    | No                | Do Not Go To SD state. Controls Snoop use of SD state. See <i>Do not transition to SD</i> on page 4-241.                                                                 |
| RetToSrc       | Yes               | Return to Source. Instructs the receiver of the snoop to return data with the Snoop response. See <i>Returning Data with Snoop response</i> on page 4-240.               |
| TraceTag       | No                | Trace Tag. As defined in <i>Request channel fields</i> on page 2-33. See <i>Chapter 11 System Debug, Trace, and Monitoring</i> .                                         |
| MPAM           | No                | Memory System Performance Resource Partitioning and Monitoring. As defined in <i>Request channel fields</i> on page 2-33. See <i>MPAM</i> on page 11-365.                |

###### — Note —

This specification does not define a TgtID field for the Snoop request. See *Target ID determination for Snoop Request messages* on page 3-154.

### 2.2.3 Data fields

Table 2-4 describes the fields associated with a Data packet. Data packets can be sent on the RDAT or WDAT channels. The fields in a Data packet do not affect the transaction structure.

Table 2-4 Data packet fields

| Field      | Description                                                                                                                                                                                  |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| QoS        | Quality of Service priority. As defined in <i>Request channel fields</i> on page 2-33. See <i>Chapter 10 Quality of Service</i> .                                                            |
| TgtID      | Target ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                                                       |
| SrcID      | Source ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                                                       |
| TxnID      | Transaction ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                                                  |
| HomeNID    | Home Node ID. The node ID of the target of the CompAck response to be sent from the Requester. See <i>Details of transaction identifier fields</i> on page 2-87.                             |
| CBusy      | Completer Busy. Indicates the current level of activity at the Completer. See <i>Completer Busy</i> on page 11-367.                                                                          |
| DBID       | Data Buffer ID. The ID provided to be used as the TxnID in the response to this message. See <i>Details of transaction identifier fields</i> on page 2-87 and <i>Ordering</i> on page 2-114. |
| Opcode     | Data opcode. Indicates, for example, if the data packet is related to a Read transaction, a Write transaction, or a Snoop transaction. See <i>DAT channel opcodes</i> on page 13-426.        |
| RespErr    | Response Error status. Indicates the error status associated with a data transfer. See <i>Chapter 6 Exclusive accesses</i> and <i>Error response fields</i> on page 9-335.                   |
| Resp       | Response status. Indicates the cache line state associated with a data transfer. See <i>Response types</i> on page 4-197.                                                                    |
| FwdState   | Forward State. Indicates the cache line state associated with a data transfer to the Requester from the receiver of the snoop. See <i>Forward State, FwdState</i> on page 13-438.            |
| DataPull   | Data Pull. Indicates the inclusion of an implied Read request in the Data response. See <i>Snoop requests and Data Pull</i> on page 7-294.                                                   |
| DataSource | Data Source. The value indicates the source of the data in a read Data response. See <i>Data Source indication</i> on page 11-360.                                                           |
| CCID       | Critical Chunk Identifier. Replicates the address offset of the original Transaction request. See <i>Data transfer</i> on page 2-134.                                                        |
| DataID     | Data Identifier. Provides the address offset of the data provided in the packet. See <i>Data transfer</i> on page 2-134.                                                                     |
| BE         | Byte Enable. For a data write, or data provided in response to a snoop, indicates which bytes are valid. See <i>Data transfer</i> on page 2-134.                                             |
| Data       | Data payload. See <i>Data transfer</i> on page 2-134.                                                                                                                                        |

Table 2-4 Data packet fields (continued)

| Field     | Description                                                                                                                                         |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| DataCheck | Data Check. Detects data errors in the DAT packet. See <a href="#">Data Check on page 9-348</a> .                                                   |
| Poison    | Poison. Indicates that a set of data bytes has previously been corrupted. See <a href="#">Poison on page 9-347</a> .                                |
| TagOp     | Tag Operation. As defined in <a href="#">Request channel fields on page 2-33</a> . See <a href="#">Tag Operation, TagOp on page 13-435</a> .        |
| Tag       | Memory Tag. Provides sets of 4-bit tags, each associated with an aligned 16-byte of data. See <a href="#">Tag on page 13-435</a> .                  |
| TU        | Tag Update. Indicates which of the Allocation Tags must be updated. See <a href="#">Tag Update, TU on page 13-435</a> .                             |
| TraceTag  | Trace Tag. As defined in <a href="#">Request channel fields on page 2-33</a> . See <a href="#">Chapter 11 System Debug, Trace, and Monitoring</a> . |
| RSVDC     | User-defined. See <a href="#">Reserved for Customer Use, RSVDC on page 13-441</a> .                                                                 |

### 2.2.4 Response fields

Table 2-5 describes the fields associated with a Response packet.

Table 2-5 Response packet fields

| Field        | Description                                                                                                                                                               |
|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| QoS          | Quality of Service priority. As defined in <i>Request channel fields</i> on page 2-33. See <i>Chapter 10 Quality of Service</i> .                                         |
| TgtID        | Target ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                                    |
| SrcID        | Source ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                                    |
| TxnID        | Transaction ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Details of transaction identifier fields</i> on page 2-87.                               |
| CBusy        | Completer Busy. As defined in <i>Data fields</i> on page 2-37. See <i>Completer Busy</i> on page 11-367.                                                                  |
| DBID         | Data Buffer ID. As defined in <i>Data packet fields</i> on page 2-37. See <i>Details of transaction identifier fields</i> on page 2-87 and <i>Ordering</i> on page 2-114. |
| PGroupID     | Persistence Group ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Persistence Group Identifier, PGroupID</i> on page 13-418.                         |
| StashGroupID | Stash Group ID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Stash Group Identifier, StashGroupID</i> on page 13-419.                                 |
| PCrdType     | Protocol Credit Type. See <i>PCrdType</i> on page 2-147.                                                                                                                  |
| Opcode       | Response opcode. Specifies the response type. See <i>RSP channel opcodes</i> on page 13-424.                                                                              |
| RespErr      | Response Error status. As defined in <i>Data packet fields</i> on page 2-37. See <i>Chapter 6 Exclusive accesses</i> and <i>Error response fields</i> on page 9-335.      |
| Resp         | Response status. As defined in <i>Data packet fields</i> on page 2-37. See <i>Response types</i> on page 4-197.                                                           |
| FwdState     | Forward State. As defined in <i>Data packet fields</i> on page 2-37. See <i>Forward State, FwdState</i> on page 13-438.                                                   |
| DataPull     | Data Pull. As defined in <i>Data packet fields</i> on page 2-37. See <i>Snoop requests and Data Pull</i> on page 7-294.                                                   |
| TagOp        | Tag Operation. As defined in <i>Request channel fields</i> on page 2-33. See <i>Tag Operation, TagOp</i> on page 13-435.                                                  |
| TagGroupID   | TagGroupID. As defined in <i>Request channel fields</i> on page 2-33. See <i>Tag Group Identifier, TagGroupID</i> on page 13-435.                                         |
| TraceTag     | Trace Tag. As defined in <i>Request channel fields</i> on page 2-33. See <i>Chapter 11 System Debug, Trace, and Monitoring</i> .                                          |

## 2.3 Transaction structure

This section describes the ways that a transaction can complete. It shows all the permitted options that can be used by the various components that participate in a transaction.

All transaction types, except PCrdReturn and PrefetchTgt, can have a Retry sequence at the start of the transaction. For ease of presentation, the Retry sequence is described separately, see [Retry on page 2-76](#).

Other independent transactions may need to be performed to complete certain transactions, such as a snoop or memory transaction. These transactions are described separately in the later section, [Home Initiated transactions on page 2-77](#).

Some transactions from Home to Subordinate support the use of a separate ReturnNID and ReturnTxnID field, which allow certain responses to be returned to the original Requester rather than the Home. It is permitted for the Home to set the ReturnNID and ReturnTxnID fields, such that they are equal to the SrcID and TxnID. This means all responses are returned to the Home. In this instance, the transaction from Home to Subordinate is considered as if it were an independent transaction. See [Home Initiated transactions on page 2-77](#) for more details.

Some messages in this section are described as Optional. This means that whether or not the particular message is included in the transaction flow is determined by a characteristic of the transaction, typically a field or opcode in the request. This does not mean that the sender of the message can choose whether or not it wishes to send the message.

The term Requester is always used to refer to the original Requester of a transaction in this section. This does not mean an intermediate agent that issues a secondary request to complete the original transaction. The term Requester always refers to a Request Node, RN-F or RN-I.

In this section, an arrow containing multiple message labels within a diagram indicates any one of the messages can be sent in a flow. Requirements of when a particular message can be used in the transaction flow can be derived from elsewhere in the specification.

The flows described in this section are intended to include a complete description of the messages that can be included in a transaction flow. It does not include the following:

- The channel that is used for a particular transaction. This information can be derived from elsewhere in the specification.
- A description of when a transaction can be issued or what the reason is for using a particular transaction.
- A description of which combinations of fields can be used in a request. Request fields are only highlighted when they affect the options for completing a transaction.

Dependencies described in this section use the following approach:

- An implicit dependency exists for each component when it first participates in a transaction sequence. With the exception of the original Requester, any other component must receive a first message associated with a transaction before it can send any subsequent messages for that transaction.
- Where a component sends multiple messages associated with the same transaction, it is assumed that component can send the messages in any order and they can be received in any order, unless an explicit dependency is described.
- Data transfers are shown in the diagrams as a single message. This message can consist of multiple data transfers, see [Data transfer on page 2-134](#) for more details. Where a dependency is described, the dependency is from the first data transfer received, except when it is explicitly stated to be different.
- Where a required or permitted dependency exists in one direction between two components, a dependency in the opposite direction is not permitted. The text in this section only describes the dependency in one direction.
- The amount of detail in a dependency rule is context dependent. In some instances where the source of the dependency and what is dependent is obvious, then the agents are not included.

- For any agent that has one or more outputs:
  - If the agent is the original Requester of the transaction, dependencies are described for each input to that agent.
  - If the agent is not the original Requester of the transaction, dependencies are described for each input to that agent after the first input that agent received. Every output is considered dependent on the first input.
- This section does not describe all dependencies across different transactions, even when they are both to the same address. See *Ordering on page 2-114* and *Hazard conditions on page 4-242*.

The conventions used to describe actions in this section are:

### Issues

Used only for the first message in a transaction, for example “The Requester issues a WriteNoSnp request...”.

### Sends

A message sent by an agent in a direction away from the Requester.

### Sends a downstream

A message relayed by an intermediate agent in a direction away from the Requester, for example “The Home sends a downstream Read request to the Subordinate”.

### Returns

A message sent by an agent in a direction towards the Requester.

### Provides

A message sent by an agent in response to a snoop, for example “...provides a snoop response”.

#### Permitted, but not required

The action is neither encouraged nor discouraged, and is compliant in either case.

#### Not permitted

The action described would cause non-compliance to the specification. For example, “it is not permitted to wait for...before sending...”.

### 2.3.1 Read transactions

The types of read transaction are:

- Allocating Read
- Non-allocating Read

#### Allocating Read

Figure 2-1 on page 2-42 shows the possible transaction flows for an Allocating Read transaction.

![](2154b1d6543a43735a7724180fff5586_img.jpg)

Sequence diagram titled "Allocating Read" showing interactions between Requester, Home, Subordinate, and Snoopee.

The sequence starts with Requester sending a request to Home (labeled `ReadClean, ReadNotSharedDirty, ReadShared, ReadUnique, ReadPreferUnique, MakeReadUnique`).

Flow 1: `alt` block (Combined response from Home)

- Requester sends `CompData` to Home.

Flow 2: `alt` block (Separate Data and Response from Home)

- Requester sends `RespSepData` to Home.
- Requester sends `DataSepResp` to Home.

Flow 3: `alt` block (Combined response from Subordinate)

- Requester sends `ReadNoSnp` to Subordinate.
- Subordinate sends `opt [Order != 00] ReadReceipt` to Home.
- Requester sends `CompData` to Home.

Flow 4: `alt` block (Response from Home, Data from Subordinate)

- Requester sends `RespSepData` to Home.
- Requester sends `ReadNoSnpSep` to Subordinate.
- Subordinate sends `opt [Order != 00] ReadReceipt` to Home.
- Requester sends `DataSepResp` to Home.

Flow 5: `alt` block (Forwarding snoop)

- Requester sends `SnpFwd` to Snoopee.

Flow 6: `alt` block (Response to Snoopee)

- Flow 6a: `alt` block (With response to Home)

- Requester sends `CompData` to Home.
- Home sends `SnpRespFwdwd` to Snoopee.

- Flow 6b: `alt` block (With data to Home)

- Requester sends `CompData` to Home.
- Home sends `SnpRespDataFwdwd` to Snoopee.

- Flow 6c: `alt` block (Failed, must use alternative)

- Requester sends `SnpResp` to Snoopee.
- Snoopee sends `Use alternative` to Home.

- Flow 6d: `alt` block (Failed, must use alternative)

- Requester sends `SnpRespData, SnpRespDataPil` to Snoopee.
- Snoopee sends `Use alternative` to Home.

Flow 7: `alt` block (MakeReadUnique only)

- Requester sends `Comp` to Home.
- Home sends `CompAck` to Requester.

Figure 2-1 Allocating Read

The sequence for the Allocating Read transaction is:

- The transaction starts with the Requester issuing an Allocating Read request to the Home.  
  The initial request is one of the following:
  - ReadClean
  - ReadNotSharedDirty
  - ReadShared
  - ReadUnique
  - ReadPreferUnique
  - MakeReadUnique

- Alternatives 1-6 show different ways that the Home can process the transaction:

##### 1. **Combined response from Home**

The Home returns a combined response and read data, CompData, to the Requester.

Typically, this option is used by the Home when it can return data and response at the same time. An example is when the data is cached locally.

##### 2. **Separate data and response from Home**

The Home returns a separate response, RespSepData, and read data, DataSepResp, to the Requester.

Typically, this option is used by the Home when it can return a response quicker than it can provide the data.

##### 3. **Combined response from Subordinate**

- The Home sends a downstream read request, ReadNoSnp, to the Subordinate.

- Optionally, when the Home requests a ReadReceipt response, the Subordinate returns a read receipt, ReadReceipt, to the Home.

- The Subordinate returns a combined response and read data, CompData, to the Requester.

Typically, this option is used by the Home either to reduce the message count or reduce design complexity.

##### 4. **Response from Home, Data from Subordinate**

- The Home returns a separate response, RespSepData, to the Requester.

- The Home sends a downstream read data only request, ReadNoSnpSep, to the Subordinate.

- Optionally, when the Home requests a ReadReceipt response, the Subordinate returns a read receipt, ReadReceipt, to the Home.

It is permitted, but not required, for the Home to wait for ReadReceipt from the Subordinate before sending RespSepData to the Requester.

- The Subordinate returns read data, DataSepResp, to the Requester.

Typically, this option is used by the Home when it can return a response quickly, but it does not have the data available and requires the Subordinate to return the data.

###### — Note —

In many circumstances, the Requester receives RespSepData far in advance to DataSepResp. The Requester is permitted to send the CompAck response after receiving RespSepData without waiting for DataSepResp. The prompt response from the Requester, and potentially receiving ReadReceipt around the same time, permits the Home to complete the transaction faster than when using combined completion and data responses from the Subordinate.

##### 5. **Forwarding snop**

- The Home requests a Snoopee to forward read data, Snp\*Fwd, to the Requester. See [Request transactions and corresponding Snoop requests on page 4-194](#) to determine which Snp\*Fwd transactions can be used.

Typically, this option is used by the Home when the data is not cached locally and it determines that a Snoopee is likely to have a copy.

- Alternatives 5a-5d show how the Snoopee can process the transaction:

###### **Alt 5a. With response to Home**

- The Snoopee returns a combined response and read data, CompData, to the Requester.

- The Snoopee provides a snop response, SnpRespFwded, to the Home.

Typically, this option is used by the Snoopee when it can forward data to the Requester and is not required to provide a copy of data to the Home.

###### **Alt 5b. With data to Home**

- The Snoopee returns a combined response and read data, CompData, to the Requester.
- The Snoopee provides a snoop response with data, SnpRespDataFwded, to the Home.

###### — Note —

Typically, this option is used by the Snoopee when it can forward data to the Requester but it also has to provide a copy of data to the Home. For example, this can happen when the Snoopee holds a Dirty copy of the cache line, but the data returned to the Requester must be Clean. This can also happen when the Home has requested a copy of the data.

###### **Alt 5c. Failed, must use alternative**

The Snoopee provides a snoop response, SnpResp, to the Home.  
The Home must use another alternative described in this section to complete the transaction to the Requester.

###### **Alt 5d. Failed, must use alternative**

The Snoopee provides a snoop response with data, SnpRespData or SnpRespDataPt, to the Home.  
The Home must use another alternative described in this section to complete the transaction to the Requester.

##### **6. MakeReadUnique only**

The Home returns a completion response, Comp, to the Requester.

This option is only applicable for a MakeReadUnique transaction when a read data message is not required.

- The transaction ends when the Requester sends a completion acknowledge, CompAck, to the Home.  
  The CompAck must only be sent after a CompData or RespSepData is received.  
  It is permitted, but not required, to wait for DataSepResp before sending CompAck.

#### Non-allocating Read

Figure 2-2 on page 2-45 shows the possible transaction flows for a Non-allocating Read transaction.

![](f2c40bfbb63eaf7fd84888bdbf1a0a51_img.jpg)

Non-allocating Read

Requester → Home: ReadNoSnp, ReadOnce, ReadOnceCleanInvalid, ReadOnceMakeInvalid

alt

[1. Combined response from Home]

opt [Order != 00] → Home: ReadReceipt

CompData ← Home

[2. Separate Data and Response from Home]

RespSepData ← Home

DataSepResp ← Home

[3. Combined response from Subordinate]

opt [Order != 00] → Subordinate: ReadReceipt

ReadNoSnp → Subordinate

opt [Order != 00] → Subordinate: ReadReceipt

CompData ← Subordinate

[4. Response from Home, Data from Subordinate]

RespSepData ← Home

ReadNoSnpSep → Subordinate

opt [Order != 00] → Subordinate: ReadReceipt

DataSepResp ← Subordinate

[5. Forwarding(snoop)]

opt [Order != 00] → Snoop: ReadReceipt

Snp\*Fwd ← Snoop

alt

[5a. with response to Home]

CompData ← Home

SnpRespFwded ← Snoop

[5b. with data to Home]

CompData ← Home

SnpRespDataFwded ← Snoop

[5c. Failed, must use alternative]

SnpResp ← Snoop

Use alternative ← Snoop

[5d. Failed, must use alternative]

SnpRespData, SnpRespDataPI ← Snoop

Use alternative ← Snoop

opt [ExpCompAck == 1] → Home: CompAck

Figure 2-2 Non-allocating Read

The sequence for the Non-allocating Read transactions is:

- The transaction starts with the Requester issuing a Read request to the Home.

The Non-allocating Read transactions are:

- ReadNoSnp
- ReadOnce
- ReadOnceCleanInvalid
- ReadOnceMakeInvalid

The request contains the following fields which affect the transaction flow:

- Order
- ExpCompAck

- Alternatives, 1-6 show how the Home can process the transaction. For a description of the typical use of the different alternatives, see [Allocating Read on page 2-41](#).

##### 1. **Combined response from Home**

- Optionally, when the original request has an ordering requirement, the Home returns a read receipt, ReadReceipt, to the Requester.
- The Home returns a combined response and read data, CompData, to the Requester.

##### 2. **Separate data and response from Home**

The Home returns a separate response, RespSepData, and read data, DataSepResp, to the Requester. This alternative cannot be used if the request has an ordering requirement and a completion acknowledgement is not required.

##### 3. **Combined response from Subordinate**

- Optionally, when the original request has an ordering requirement, the Home returns a read receipt, ReadReceipt, to the Requester.
- The Home sends a downstream read request, ReadNoSnp, to the Subordinate.
- Optionally, when the Home requests a ReadReceipt response, the Subordinate returns ReadReceipt to the Home.

The Home must do this when a completion acknowledgement is not required.

It is permitted, but not required, for the Home to wait for ReadReceipt from the Subordinate before returning ReadReceipt to the Requester.

- The Subordinate returns a combined response and read data, CompData, to the Requester.

This alternative cannot be used if the request has an ordering requirement and a completion acknowledgement is not required.

##### 4. **Response from Home, data from Subordinate**

- The Home returns a separate response, RespSepData, to the Requester and sends a downstream read data only request, ReadNoSnpSep, to the Subordinate.
- Optionally, when the Home requests a ReadReceipt response, the Subordinate returns a read receipt, ReadReceipt, to the Home. The Home must do this when a completion acknowledgement is not required.

It is permitted, but not required, for the Home to wait for ReadReceipt from the Subordinate before returning RespSepData to the Requester.

- The Subordinate returns read data, DataSepResp, to the Requester.

This alternative cannot be used if the request has an ordering requirement and a completion acknowledgement is not required.

##### 5. **Forwarding snoop**

- Optionally, when the original request has an ordering requirement, the Home returns a read receipt, ReadReceipt, to the Requester.
- The Home requests a Snoop to forward read data, Snp\*Fwd, to the Requester.

See [Request transactions and corresponding Snoop requests on page 4-194](#) to determine which Snp\*Fwd transactions can be used.

- The alternatives, 5a-5d, show how the Snoopee can process the transaction:
  - **Alt 5a. With response to Home**
    - The Snoopee provides a combined response and read data, CompData, to the Requester.
    - The Snoopee provides a snoop response, SnpRespFwded, to the Home.
  - **Alt 5b. With data to Home**
    - The Snoopee provides a combined response and read data, CompData, to the Requester.
    - The Snoopee provides a Snoop response with data, SnpRespDataFwded, to the Home.
  - **Alt 5c. Failed, must use alternative**
    - The Snoopee provides a snoop response, SnpResp, to the Home.
    - The Home must use another alternative described in this section to complete the transaction to the Requester.
  - **Alt 5d. Failed, must use alternative**
    - The Snoopee provides a snoop response with data, SnpRespData or SnpRespDataPl, to the Home.
    - The Home must use another alternative described in this section to complete the transaction to the Requester.
- If the original request has ExpCompAck asserted, the Requester must only provide a CompAck response after the following:
  - At least one CompData packet is received.
  - RespSepData, if the request does not have an ordering requirement. In this case, it is permitted but not required to wait for DataSepResp.
  - RespSepData and at least one DataSepResp packet, if the request has an ordering requirement.

If the original request has an ordering requirement, it is permitted, but not required, for the Requester to wait for ReadReceipt before sending CompAck.

Table 2-6 lists the permitted DMT and DCT transactions for ReadNoSnp and ReadOnce\* from a Request Node. The following key is used:

| Y | Yes, permitted                           |
|---|------------------------------------------|
| N | No, not permitted                        |
| - | The flow is not used in this transaction |

Table 2-6 Permitted DMT and DCT for ReadNoSnp and ReadOnce\* from an RN

| Order [1:0] | ExpCompAck | DMT | DCT | Notes                                                                                                                                                                                                                                  |
|-------------|------------|-----|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 00          | 0          | Y   | Y   | Home does not need to be notified of transaction completion.<br>For DMT, Home must obtain the Request Accepted response from SN to ensure the request to SN is not given a RetryAck response.                                          |
|             | 1          | Y   | Y   | Home does not need to be notified of transaction completion.<br>For DMT, Home can ensure the request to SN is not given a RetryAck response by either obtaining the Request Accepted response from SN or waiting for CompAck response. |
| 01          | -          | -   | -   | Not permitted.                                                                                                                                                                                                                         |
| 10          | 0          | N   | Y   | For DCT, Home uses the SnpRespFwded or SnpRespDataFwded snoop response to determine transaction completion.                                                                                                                            |
| 11          | 1          | Y   | Y   | For DMT, Home uses the CompAck response to determine transaction completion.<br>For DCT, Home uses the SnpRespFwd or SnpRespDataFwd snoop response to determine transaction completion.                                                |

### 2.3.2 Write Transactions

The types of write transactions are:

- Immediate Write
- Write Zero
- CopyBack write

#### Immediate write

Figure 2-3 on page 2-50 shows the possible transaction flows for an Immediate Write transaction.

![](8ed84fe370c3350b72cbb13d1b3a7b15_img.jpg)

Immediate Write

Requester, Home, Subordinate

alt [1. DWT]

alt [2. No DWT, no CompAck]

alt [2a1. Separate responses from the Home]

alt [2a2. Combined response from the Home]

alt [2b1. TagMatch from Home]

alt [2b2. TagMatch from Subordinate]

alt [2b2a. Separate responses from the Subordinate]

alt [2b2b. Combined response from the Subordinate]

alt [3. No DWT, with CompAck]

alt [3a1. Separate responses from the Home]

alt [3a2. Combined response from the Home]

alt [3b1. Separate response from the Requester]

alt [3b2. Combined response from the Requester]

alt [3c1. TagMatch from Home]

alt [3c2. TagMatch from Subordinate]

alt [3c2a. Separate responses from the Subordinate]

alt [3c2b. Combined response from the Subordinate]

Figure 2-3 Immediate Write

The sequence for Immediate Write transactions is:

- The transaction starts with the Requester issuing an Immediate Write request to the Home.

The Immediate Write transactions are:

- WriteNoSnpPtl
- WriteNoSnpFull
- WriteUniquePtl
- WriteUniqueFull
- WriteUniquePtlStash
- WriteUniqueFullStash

Snoop requests that are generated to complete these transactions are considered as independent transactions from the Home and are not shown in this flow. Write requests that are generated to downstream Subordinates, which are not part of the DWT flow, are considered as independent transactions and are not shown in this flow. See *Home Initiated transactions on page 2-77* for more details of independent transactions from the Home. Stash snoop requests that are generated to complete the WriteUniquePtlStash or WriteUniqueFullStash transactions are described in the later section on Stash transactions, see *Stash transactions on page 2-69*.

The request contains the following fields which affect the transaction flow:

- ExpCompAck
- TagOp

- The Home can choose to complete the transaction using DWT or without DWT. The remainder of the transaction flow will also depend on whether the original request requires a completion acknowledge response, as determined by the ExpCompAck field. The combinations are described in alternatives 1-3:

##### 1. **DWT**

The Home uses DWT.

- The Home sends a downstream write request, WriteNoSnpPtl or WriteNoSnpFull, with DoDWT = 1 to the Subordinate.
- The Subordinate returns a data request, DBIDResp, to the Requester.
- The Requester sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate.  
  The Requester must only send this after it has received DBIDResp.
- The Subordinate returns a completion response, Comp, to the Home.  
  It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning Comp to the Home.
- The Home returns a completion response, Comp, to the Requester.  
  It is permitted, but not required, for the Home to wait for Comp from the Subordinate before returning Comp to the Requester.
- Optionally, when the request requires a TagMatch response, the Subordinate returns a tag match response, TagMatch, to the Requester.  
  It is permitted, but not required, to wait for write data before returning TagMatch.

##### 2. **No DWT, no CompAck**

The Home does not use DWT for a request that does not require a completion acknowledge, CompAck.

- The Home has two alternatives to send the completion response and the data request response to the Requester.

###### **Alt 2a1. Separate responses from the Home**

The Home does both the following:

- Returns a data request, DBIDResp or DBIDRespOrd, to the Requester.
- Returns a completion response, Comp, to the Requester.  
  It is permitted, but not required, to wait for write data before returning Comp.

###### **Alt 2a2. Combined responses from the Home**

The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

- The Requester sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Home. The Requester must only send this after it has received DBIDResp, DBIDRespOrd, or CompDBIDResp.
- Optionally, when the request requires a TagMatch response, the Home has two alternatives.

###### **Alt 2b1. TagMatch from Home**

The Home returns a tag match response, TagMatch, to the Requester.

It is permitted, but not required, to wait for write data before returning TagMatch.

###### **Alt 2b2. TagMatch from Subordinate**

- The Home sends a downstream write request, WriteNoSnpPtl or WriteNoSnpFull, with DoDWT = 0 to the Subordinate. The Subordinate has two alternatives to send return data request and completion response to the Home.

###### **Alt 2b2a. Separate responses from the Subordinate**

The Subordinate does both the following:

- Returns data request, DBIDResp, to the Home.
- Returns a completion response, Comp, to the Home. It is permitted, but not required, for the Subordinate to wait for write data from the Home before returning Comp to the Home.

###### **Alt 2b2b. Combined response from the Subordinate**

The Subordinate returns a combined data request and completion response, CompDBIDResp, to the Home.

- The Home sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate. The Home must only send this after it has received DBIDResp or CompDBIDResp.
- The Subordinate returns a tag match response, TagMatch, to the Requester. It is permitted, but not required, to wait for write data before returning TagMatch.

##### **3. No DWT, with CompAck**

The Home does not use DWT for a request that does require a completion acknowledge, CompAck.

- The Home has two alternatives to return the completion response and the data request response to the Requester.

###### **Alt 3a1. Separate response from the Home**

The Home does both the following:

- Returns a data request, DBIDResp or DBIDRespOrd, to the Requester.
- Returns a completion response, Comp, to the Requester.

It is permitted, but not required, to wait for write data before returning Comp.

###### **Alt 3a2. Combined response from the Home**

The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

- The Requester has two alternatives to send write data and completion acknowledge to the Home.

###### **Alt 3b1. Separate response from the Requester**

The Requester does both the following:

- Sends write data, NCBWrData, or a write cancellation, WriteDataCancel, to the Home.

The Requester must only send this after it has received DBIDResp, DBIDRespOrd or CompDBIDResp.

- Sends a completion acknowledge, CompAck, to the Home.

The Requester must only send this after it has received Comp or CompDBIDResp.

It is permitted, but not required, to wait for DBIDResp or DBIDRespOrd before sending CompAck.

It is permitted, but not expected, to wait for TagMatch before returning CompAck.

###### **Alt 3b2. Combined response from the Requester**

The Requester sends a combined write data and completion acknowledge, NCBWrDataCompAck, to the Home.

The Requester must only send this after it has received CompDBIDResp or both DBIDResp/DBIDRespOrd and Comp.

- Optionally, when the request requires a TagMatch response, the Home has two alternatives to return the response.

###### **Alt 3c1. TagMatch from Home**

The Home returns a tag match response, TagMatch, to the Requester.

It is permitted, but not required, to wait for write data before returning TagMatch.

###### **Alt 3c2. TagMatch from Subordinate**

- The Home sends a downstream write request, WriteNoSnpPtl or WriteNoSnpFull, with DoDWT = 0 to the Subordinate. The Subordinate has two alternatives to return data request and completion response to the Home.

###### **Alt 3c2a. Separate responses from Subordinate**

The Subordinate does both the following:

- Returns a data request, DBIDResp, to the Home.
- Returns a completion response, Comp, to the Home.

It is permitted, but not required, for the Subordinate to wait for write data before sending Comp to the Home.

###### **Alt 3c2b. Combined response from Subordinate**

The Subordinate returns a combined data request and completion response, CompDBIDResp, to the Home.

- The Home sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate.
- The Home must only send this after it has received DBIDResp or CompDBIDResp.
- The Subordinate returns a tag match response, TagMatch, to the Requester.

It is permitted, but not required, to wait for write data before returning TagMatch.

The Completer of a Write transaction is permitted to return a Comp response as soon as it receives a WriteDataCancel response without dependency on either the processing of the write request or the completion of any snoops sent due to the write.

#### Write Zero

Figure 2-4 shows the possible transaction flows for a Write Zero transaction.

![Sequence diagram for Write Zero transaction. The Requester sends WriteNoSnpZero, WriteUniqueZero to the Home. The Home then performs an alt operation: 1. Separate response from Home: Home sends DBIDResp, DBIDRespOrd to Requester, and Comp to Requester. 2. Combined response from Home: Home sends CompDBIDResp to Requester.](201de44da5d99899a8cf58eac2fa7bc9_img.jpg)

Sequence diagram for Write Zero transaction. The Requester sends WriteNoSnpZero, WriteUniqueZero to the Home. The Home then performs an alt operation: 1. Separate response from Home: Home sends DBIDResp, DBIDRespOrd to Requester, and Comp to Requester. 2. Combined response from Home: Home sends CompDBIDResp to Requester.

Figure 2-4 Write Zero

- The transaction starts with the Requester issuing a Write Zero request to the Home.

  The Write Zero transactions are:

  - WriteUniqueZero
  - WriteNoSnpZero
- The Home has two alternatives to send the completion response and the data request response to the Requester.
  1. **Separate response from Home**
     - The Home returns a data request response, DBIDResp or DBIDRespOrd, to the Requester.
     - The Home returns a completion response, Comp, to the Requester.
  2. **Combined response from Home**

     The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

##### CopyBack Write

Figure 2-5 shows the possible transaction flows for a CopyBack Write transaction.

![](1bc1bf231ada31f57cd9f0d8791b784b_img.jpg)

Sequence diagram titled "Copyback Write" showing interactions between a Requester and a Home.

The Requester initiates the transaction by sending messages to the Home: WriteBackPtl, WriteBackFull, WriteCleanFull, WriteEvictFull, and WriteEvictOrEvict.

The Home responds using an `alt` (alternative) structure:

1. **Combined response from Home**: The Home sends CompDBIDResp back to the Requester. The Requester then sends CopyBackWrData back to the Home.
2. **For WriteEvictOrEvict Only**: The Home sends Comp back to the Requester. The Requester then sends CompAck back to the Home.

Figure 2-5 CopyBack Write

The sequence for CopyBack Write is:

- The transaction starts with the Requester issuing a CopyBack Write request to the Home.

The CopyBack Write transactions are:

- WriteBackPtl
- WriteBackFull
- WriteCleanFull
- WriteEvictFull
- WriteEvictOrEvict

- The Home can complete any transaction using one of the following alternatives:

1. **Combined response from Home**

This alternative must be used for:

- WriteBackPtl
- WriteBackFull
- WriteCleanFull
- WriteEvictFull

This alternative can be used for WriteEvictOrEvict transactions.

Typically, it is used for a WriteEvictOrEvict transaction when the Home wants to cache a copy of the cache line.

- The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

- The Requester sends write data, CopyBackWrData, to the Home.

The Requester must only send this after it has received CompDBIDResp.

1. **For WriteEvictOrEvict Only**

The Home can complete a WriteEvictOrEvict transaction using the second alternative.

Typically, it is used for a WriteEvictOrEvict transaction when the Home does not want to cache a copy of the cache line.

- The Home returns a completion response, Comp, to the Requester.

- The Requester sends a completion acknowledge, CompAck, to the Home.

The Requester must only send this after it has received Comp.

##### Combined Immediate Write and CMO

Figure 2-6 shows the possible transaction flows for a Combined Write and CMO transaction. This only covers Non-persist Cache Maintenance Operations, see *Combined Immediate Write and Persist CMO* on page 2-59 for transaction flows for a Combined Immediate Write and Persist CMO transaction.

![](b4b7023ccc81c5f4ebfd3ccb58361529_img.jpg)

Combined Immediate Write and CMO

Requester, Home, Subordinate

WriteNoSnpPitCleanInv, WriteNoSnpFullCleanInv, WriteNoSnpPitCleanSh, WriteNoSnpFullCleanSh, WriteUniquePitCleanSh, WriteUniqueFullCleanSh

alt

[1. Combined Write to Subordinate with DWT]

WriteNoSnpPitCleanInv, WriteNoSnpFullCleanInv, WriteNoSnpPitCleanSh, WriteNoSnpFullCleanSh (DoDWT = 1)

DBIDResp

NCBWrData, WriteDataCancel

Comp

Comp

CompCMO

[2. Non-combined write with DWT to Subordinate]

WriteNoSnpPit, WriteNoSnpFull (DoDWT = 1)

DBIDResp

NCBWrData, WriteDataCancel

Comp

CompCMO

[3. No DWT]

alt

[3a1. Separate responses from Home]

DBIDResp, DBIDRespOrd

Comp

[3a2. Combined response from Home]

CompDBIDResp

alt

[3b1. No CompAck required]

NCBWrData, WriteDataCancel

[3b2. CompAck required]

alt

[3b2a. Separate response from Requester]

NCBWrData, WriteDataCancel

CompAck

[3b2b. Combined response from Requester]

NCBWrDataCompAck

CompCMO

Figure 2-6 Combined Immediate Write and CMO

The sequence for the Combined Immediate Write with CMO transactions is:

- The transaction starts with the Requester issuing a Combined Write and CMO request to the Home. The Combined Immediate Write and CMO transactions are:
  - WriteNoSnpPtlCleanInv
  - WriteNoSnpPtlCleanSh
  - WriteNoSnpFullCleanInv
  - WriteNoSnpFullCleanSh
  - WriteUniquePtlCleanSh

Snoop requests that are generated to complete these transactions are considered as independent transactions from the Home and are not shown in this flow. Write requests that are generated to downstream Subordinates, which are not part of the DWT flow, are considered as independent transactions and are not shown in this flow. Also, CMO requests that only return responses to the Home and are generated to downstream Subordinates are considered independent transactions. See [Home Initiated transactions on page 2-77](#) for more details on independent transactions from the Home. See [Home to Subordinate Write transactions on page 2-78](#) for more details on independent Combined Write and CMO transactions from the Home.

The request contains the following fields which affect the transaction flow:

- Opcode
- ExpCompAck

###### **Note**

A TagOp value of Match is not permitted in a Combined Immediate Write and CMO transaction, therefore no TagMatch responses are permitted and the TagOp field does not affect the transaction flow.

- The Home has three alternatives to choose from in order to complete the transaction:
  - Combined Write with DWT to Subordinate.
  - Non-combined Write with DWT to Subordinate.
  - Without DWT.

The three approaches are described in the alternatives 1-3.

- The remainder of the transaction flow will also depend on whether the original request required a completion acknowledge, as determined by the ExpCompAck.

##### **1. Combined Write to Subordinate with DWT**

The Home uses a Combined Write with DWT.

- The Home sends a downstream combined write request with DoDWT = 1 to the Subordinate.
- The Subordinate returns a data request, DBIDResp, to the Requester.
- The Requester sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate. The Requester must only send this after it has received DBIDResp.
- The Subordinate returns a completion response, Comp, to the Home. It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning Comp to the Home.
- The Home returns a completion response, Comp, to the Requester. It is permitted, but not required, for the Home to wait for Comp from the Subordinate before returning Comp to the Requester.
- The Subordinate returns a CMO completion response, CompCMO, to the Home. It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning CompCMO to the Home.

- The Home returns a CMO completion response, CompCMO, to the Requester. It is permitted, but not required, for the Home to wait for Comp or CompCMO from the Subordinate before returning CompCMO to the Requester. If there is an observer downstream of the Home, then the Home must wait for the CompCMO response from the Subordinate before returning CompCMO to the Requester.

2. **Non-combined Write with DWT to Subordinate**

The Home uses a Non-combined Write with DWT.

- The Home sends a downstream WriteNoSnpPtl or WriteNoSnpFull, with DoDWT = 1 to the Subordinate.
- The Subordinate returns a data Request, DBIDResp, to the Requester.
- The Requester sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate. The Requester must only send this after it has received DBIDResp.
- The Subordinate returns a completion response, Comp, to the Home. It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning Comp to the Home.
- The Home returns a completion response, Comp, to the Requester. It is permitted, but not required, for the Home to wait for Comp from the Subordinate before returning Comp to the Requester.
- The Home returns a CMO completion response, CompCMO, to the Requester. It is permitted, but not required, for the Home to wait for Comp from the Subordinate before returning CompCMO to the Requester.

3. **No DWT**

- The Home does not use DWT.
- The Home has two alternatives to request write data.

**Alt 3a1. Separate responses from Home**

The Home does both the following:

- Returns a data request, DBIDResp or DBIDRespOrd, to the Requester.
- Returns a completion response, Comp, to the Requester.

It is permitted, but not required, to wait for write data before returning Comp.

**Alt 3a2. Combined response from Home**

The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

- The Requester has several alternatives to send write data depending on whether the transaction requires a completion acknowledge.

**Alt 3b1. No CompAck required**

A completion acknowledge, CompAck, is not required and the Requester sends write data, NCBWrData, or a write cancellation, WriteDataCancel, to the Home. The Requester must only send this after it has received DBIDResp, DBIDRespOrd or CompDBIDResp.

**Alt 3b2. Separate response from Requester**

A completion acknowledge is required. The Requester has two alternatives to send write data and completion acknowledge to the Home.

**Alt 3b2a. Separate response from Requester**

The Requester does both the following:

- Sends write data, NCBWrData, or a write cancellation, WriteDataCancel, to the Home. The Requester must only send this after it has received DBIDResp, DBIDRespOrd, or CompDBIDResp.

- Sends CompAck to the Home.  
  The Requester must only send this after it has received Comp or CompDBIDResp.

It is not permitted to wait for CompCMO before sending CompAck.

###### **Alt 3b2b. Combined response from Requester**

The Requester sends a combined write data and completion acknowledge, NCBWrDataCompAck, to the Home.

The Requester must only send this after it has received CompDBIDResp or both DBIDResp/DBIDRespOrd and Comp.

- The Home returns a CMO completion response, CompCMO, to the Requester.  
  It is permitted, but not required, for the Home to wait for write data from the Requester before returning CompCMO.

##### Combined Immediate Write and Persist CMO

Figure 2-7 on page 2-60 shows the possible transaction flows for Combined Immediate Write and Persist CMO transaction.

![](99ff399927193b5527d8283e2a74747b_img.jpg)

Combined Immediate Write and Persist CMO

alt

[1. Combined Write to Subordinate with DWT]

WriteNoSnpP#CleanS#PerSep, WriteNoSnpFullCleanS#PerSep, WriteNoSnpP#CleanS#PerSep, WriteNoSnpFullCleanS#PerSep

DBDIResp

NCBWDta, WriteDataCancel

Comp

CompCMO

Persist

[2. Non-combined write with DWT to Subordinate]

WriteNoSnpP#, WriteNoSnpFull  
(DWDWT = 1)

DBDIResp

NCBWDta, WriteDataCancel

Comp

CompCMO

Persist

alt

[a. Persist CMO to Subordinate]

ClearSharedPersistSep

Comp

CompCMO

Persist

[b. No CMO to Subordinate as part of transaction]

alt

[b21. Separate response from Home]

CompCMO

Persist

[b22. Combined response from Home]

CompPersist

[c. No DWT]

alt

[c1. Separate responses from Home]

DBDIResp, DBDIRespOrd

Comp

[c2. Combined response from Home]

CompDBDIResp

alt

[b1. No CompAck required]

NCBWDta, WriteDataCancel

[b2. CompAck required]

alt

[b2a. Separate response from Requester]

NCBWDta, WriteDataCancel

CompAck

[b2b. Combined response from Requester]

NCBWDtaDataCompAck

alt

[b1. Combined write without DWT to Subordinate]

WriteNoSnpP#CleanS#PerSep, WriteNoSnpFullCleanS#PerSep  
(DWDWT = 0)

alt

[b1a. Separate responses from Subordinate]

DBDIResp

Comp

[b1b. Combined response from Subordinate]

CompDBDIResp

NCBWDta, WriteDataCancel

CompCMO

Persist

[b2. All CMO responses from Home]

alt

[b2a. Separate response from Home]

CompCMO

Persist

[b2b. Combined response from Home]

CompPersist

[c3. Only CMO transaction to Subordinate]

ClearSharedPersistSep

Comp

CompCMO

Persist

Figure 2-7 Combined Immediate Write and Persist CMO

The sequence for Combined Immediate Write and Persist CMO is:

- The transaction starts with the Requester issuing a Combined Immediate Write and Persist CMO request to the Home.

The Combined Immediate Write and Persist CMO transactions are:

- WriteNoSnpPtlCleanShPerSep
- WriteNoSnpFullCleanShPerSep
- WriteUniquePtlCleanShPerSep
- WriteUniqueFullCleanShPerSep

Snoop requests that are generated to complete these transactions are considered as independent transactions from the Home and are not shown in this flow. Write requests that are generated to downstream Subordinates, which are not part of the DWT flow, are considered as independent transactions and are not shown in this flow. Also, CMO requests that only return responses to the Home and are generated to downstream Subordinates are considered independent transactions. See [Home Initiated transactions on page 2-77](#) for more details on independent transactions from the Home. See [Home to Subordinate Write transactions on page 2-78](#) for more details on independent Combined Write and CMO transactions from the Home.

The request contains the following fields which affect the transaction flow:

- Opcode
- ExpCompAck

— **Note** —

A TagOp value of Match is not permitted in a Combined Immediate Write and Persist CMO transaction, therefore no TagMatch responses are permitted and the TagOp field does not affect the transaction flow.

- The Home can choose to complete the transaction using a:

- Combined Write with DWT to the Subordinate.
- Non-combined Write with DWT to the Subordinate.
- Without DWT.

The three approaches are described in alternatives 1-3.

The remainder of the transaction flow will depend on whether the original request required a completion acknowledge, as determined by the ExpCompAck field.

##### 1. **Combined Write to Subordinate with DWT**

- The Home sends a downstream combined write request with DoDWT = 1 to the Subordinate.
- The Subordinate returns a data request, DBIDResp, to the Requester.
- The Requester sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate.  
  The Requester must only send this after it has received DBIDResp.
- The Subordinate returns a completion response, Comp, to the Home.  
  It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning Comp to the Home.
- The Home returns a completion response, Comp, to the Requester.  
  It is permitted, but not required, for the Home to wait for Comp from the Subordinate before returning Comp to the Requester.
- The Subordinate returns a CMO completion response, CompCMO, to the Home.  
  It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning CompCMO to the Home.

- The Home returns a CMO completion response, CompCMO, to the Requester. It is permitted, but not required, for the Home to wait for Comp or CompCMO from the Subordinate before returning CompCMO to the Requester. If there is an observer downstream of the Home, the Home must wait for the CompCMO response from the Subordinate before returning CompCMO to the Requester.
- The Subordinate returns a persist response, Persist, to the Requester. It is permitted, but not required, to wait for write data before returning Persist.

2. **Non-combined write with DWT to Subordinate**

- The Home sends a downstream non-combined write request, WriteNoSnpPtl or WriteNoSnpFull, with DoDWT = 1 to the Subordinate.
- The Subordinate returns a data request, DBIDResp, to the Requester.
- The Requester sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate. The Requester must only send this after it has received DBIDResp.
- The Subordinate returns a completion response, Comp, to the Home. It is permitted, but not required, for the Subordinate to wait for write data from the Requester before returning Comp to the Home.
- The Home returns a completion response, Comp, to the Requester. It is permitted, but not required, for the Home to wait for Comp from the Subordinate before returning Comp to the Requester.
- The Home has two alternatives to send the CMO responses to the Requester.

  **Alt 2a. Persist CMO to Subordinate**

  - The Home sends a downstream request, CleanSharedPersistSep, to the Subordinate.
  - The Subordinate returns a completion response, Comp, to the Home.
  - The Home returns a CMO completion response, CompCMO, to the Requester. If there is an observer downstream of the Home, then Home must wait for the Comp response from the Subordinate before returning CompCMO to the Requester.
  - The Subordinate returns a persist response, Persist, to the Requester.

  **Alt 2b. No CMO to Subordinate as part of transaction**

  The Home sends all the CMO responses to the Requester. The Home has two alternatives to do this.

  **Alt 2b1. Separate responses from Home**

  The Home does both the following:

  - Returns a CMO completion response, CompCMO, to the Requester.
  - Returns a persist response, Persist, to the Requester.

  **Alt 2b2. Combined response from Home**

  The Home returns a combined completion and persist response, CompPersist, to the Requester.

3. **No DWT**

- The Home does not use DWT.
- The Home has two alternatives to request write data.

###### **Alt 3a1. Separate responses from Home**

The Home does both of the following:

- Returns a data request, DBIDResp or DBIDRespOrd, to the Requester.
- Returns a completion response, Comp, to the Requester.

It is permitted, but not required, to wait for write data before returning Comp.

###### **Alt 3a2. Combined response from Home**

The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

- The Requester has several alternatives to send write data depending on whether the transaction requires a completion acknowledge.

###### **Alt 3b1. No CompAck required**

The Requester sends write data, NCBWrData, or a write cancellation, WriteDataCancel, to the Home.

The Requester must only send this after it has received DBIDResp, DBIDRespOrd, or CompDBIDResp.

###### **Alt 3b2. CompAck required**

A completion acknowledge response, CompAck, is required. The Requester has two alternatives to send write data and CompAck to the Home.

###### **Alt 3b2a. Separate response from Requester**

The Requester does both the following:

- Sends write data, NCBWrData, or a write cancellation, WriteDataCancel, to the Home.

The Requester must only send this after it has received DBIDResp, DBIDRespOrd, or CompDBIDResp.

- Sends a completion acknowledge, CompAck, to the Home.

The Requester must only send this after it has received Comp or CompDBIDResp.

It is not permitted to wait for CompCMO or Persist before sending CompAck.

###### **Alt 3b2b. Combined response from Requester**

The Requester sends a combined write data and completion acknowledge, NCBWrDataCompAck, to the Home.

The Requester must only send this after it has received CompDBIDResp, or both DBIDResp/DBIDRespOrd and Comp.

It is not permitted to wait for CompCMO or Persist before sending NCBWrDataCompAck.

- The Home has several alternatives to complete the remainder of the transaction.

###### **Alt 3c1. Combined Write without DWT to Subordinate**

- The Home sends a Combined Write without DWT to the Subordinate.
- The Subordinate has two alternatives to request write data.

###### **Alt 3c1a. Separate responses from Subordinate**

The Subordinate does both the following:

- Returns a data request, DBIDResp, to the Home.
- Returns a completion response, Comp, to the Home.

It is permitted, but not required, to wait for write data before returning Comp.

###### **Alt 3c1b. Combined response from Subordinate**

The Subordinate returns a combined data request and completion response, CompDBIDResp, to the Home.

- The Home sends write data, NCBWrdData, or a cancellation, WriteDataCancel, to the Subordinate.  
  The Home must only send this after it has received DBIDResp or CompDBIDResp.
- The Subordinate returns a CMO completion response, CompCMO, to the Home.  
  It is permitted, but not required, to wait for write data before returning CompCMO.
- The Home returns a CMO completion response, CompCMO, to the Requester.  
  It is permitted, but not required, for the Home to wait for CompCMO from the Subordinate before returning CompCMO to the Requester.
- The Subordinate returns a persist response, Persist, to the Requester.  
  It is permitted, but not required, to wait for write data before returning Persist.

###### **Alt 3c2. All CMO transactions from Home**

The Home has two alternatives to send all CMO responses to the Requester.

###### **Alt 3c2a. Separate responses from Home**

The Home does both the following:

- Returns a CMO completion response, CompCMO, to the Requester.
- Returns a persist response, Persist, to the Requester.

###### **Alt 3c2b. Combined response from Home**

The Home returns a combined completion and persist response, CompPersist, to the Requester.

###### **Alt 3c3. Only CMO transactions to Subordinate**

- The Home sends a downstream request, CleanSharedPersistSep, to the Subordinate.

Typically, this alternative would only be used where a write to the Subordinate has been previously sent as an independent transaction.

- The Subordinate returns a completion response, Comp, to the Home.
- The Home returns a CMO completion response, CompCMO, to the Requester.

If there is an observer downstream of the Home, then Home must wait for the Comp response from the Subordinate before returning CompCMO to the Requester.

- The Subordinate returns a persist response, Persist, to the Requester.

##### Combined CopyBack Write and CMO

Figure 2-8 shows the possible transaction flows for a Combined CopyBack Write and CMO transaction.

![](509a054727400bc6d424bb2a559b8cfc_img.jpg)

Combined CopyBack Write and CMO

alt

[1. Without Persist]

- WriteBackFullCleanInv, WriteBackFullCleanSh, WriteCleanFullCleanSh
- CompDBIDResp
- CopyBackWrData
- CompCMO

[2. With Persist]

- WriteBackFullCleanShPerSep, WriteCleanFullCleanShPerSep
- CompDBIDResp
- CopyBackWrData

alt

[2a. Persist from Home]

alt

[2a1 Separate response from Home]

- CompCMO
- Persist

[2a2. Combined response from Home]

- CompPersist

[2b. Persist from Subordinate]

- WriteNoSnpPllCleanShPerSep, WriteNoSnpFullCleanShPerSep

alt

[2b1. Separate response]

- DBIDResp
- Comp

[2b2. Combined response]

- CompDBIDResp
- NCBWrData, WriteDataCancel
- CompCMO

[2c. Only CMO transaction to Subordinate]

- CleanSharedPersistSep
- Comp
- CompCMO
- Persist

Figure 2-8 Combined CopyBack Write and CMO

The sequence for Combined CopyBack and CMO is:

The Combined CopyBack write and CMO transactions are:

- WriteBackFullCleanInv
- WriteBackFullCleanSh
- WriteCleanFullCleanSh
- WriteBackFullCleanShPerSep
- WriteCleanFullCleanShPerSep

Write requests that are generated to downstream Subordinates and not part of the DWT or persist flow. These write requests are considered as independent transactions and are not shown in this flow. CMO requests that are generated to downstream Subordinates, which only return responses to the Home, are considered as independent transactions and are not shown in this flow. See [Home Initiated transactions on page 2-77](#) for more details on independent transactions from the Home. See [Home to Subordinate Combined Write and CMO transactions on page 2-80](#) for more details on independent Combined Write and CMO transactions from the Home.

The request contains the following field which affects the transaction flow:

- Opcode

There are two alternatives for a Requester issuing a Combined CopyBack write and CMO request to the Home.

##### 1. **Without Persist**

The Requester issues a Combined CopyBack Write and CMO request without Persist response.

The transactions that do not have a Persist response are WriteBackFullCleanInv, WriteBackFullCleanSh, and WriteCleanFullCleanSh.

- The Requester issues a request to the Home.
- The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.
- The Requester sends write data, CopyBackWrData, to the Home.  
  The Requester must only send this after it has received CompDBIDResp.
- The Home returns a CMO completion response, CompCMO, to the Requester.  
  It is permitted, but not required, to wait for write data before returning CompCMO.

##### 2. **With Persist**

The Requester issues a Combined CopyBack Write and CMO request with Persist response.

The transactions that have a Persist response include WriteBackFullCleanShPerSep and WriteCleanFullCleanShPerSep.

- The Requester issues a request to the Home.
- The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.
- The Requester sends write data, CopyBackWrData, to the Home.  
  The Requester must only send this after it has received CompDBIDResp.

The Home has three alternatives to complete the transaction, with the persist response either coming from the Home or from the Subordinate.

###### **Alt 2a. Persist from Home**

The Home has two alternatives to send the CMO completion response and persist response.

It is permitted, but not required, for the Home to wait for write data before returning CompCMO, Persist, or CompPersist.

###### **Alt 2a1 Separate response from Home**

- Returns a CMO completion response, CompCMO, to the Requester.
- Returns a persist response, Persist, to the Requester.

###### **Alt 2a2 Combined response from Home**

The Home returns a combined CMO completion response and persist response, CompPersist, to the Requester.

###### **Alt 2b. Persist from Subordinate**

When a Combined Write is sent to the Subordinate and the Persist response is returned to the Requester, the following happens:

- The Home sends a downstream write request, WriteNoSnpPtlCleanShPerSep or WriteNoSnpFullCleanShPerSep, to the Subordinate.  
  It is permitted, but not required, for the Home to wait for write data before sending the downstream write request.
- The Subordinate has two alternatives to return the completion response and the data request response to the Home.

###### **Alt 2b1. Separate response**

The Subordinate does both the following:

- Returns a data request, DBIDResp, to the Home.
- Returns a completion response, Comp, to the Home.

It is permitted, but not required, to wait for write data before returning Comp.

###### **Alt 2b2. Combined response**

The Subordinate returns a combined data request and completion response, CompDBIDResp, to the Home.

- The Home sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate.

The Home must only send this after it has received DBIDResp or CompDBIDResp.

- The Subordinate returns a CMO completion response, CompCMO, to the Home.

It is permitted, but not required, to wait for write data before returning CompCMO.

- The Home returns a CMO completion response, CompCMO, to the Requester.

It is permitted, but not required, for the Home to wait for CompCMO from the Subordinate before returning CompCMO to the Requester.

- The Subordinate returns a persist response, Persist, to the Requester.

It is permitted, but not required, to wait for write data before returning Persist.

###### **Alt 2c. Only CMO transaction to Subordinate**

When a persist CMO is sent to the Subordinate and the Persist response is returned to the Requester, the following happens:

- The Home sends a downstream request, CleanSharedPersistSep, to the Subordinate.

Typically, this alternative would only be used where a write to the Subordinate has been previously sent as an independent transaction or the write has been canceled.

- The Subordinate returns a completion response, Comp, to the Home.
- The Home returns a completion response, CompCMO, to the Requester.

If there is an observer downstream of the Home, then Home must wait for the Comp response from the Subordinate before returning CompCMO to the Requester.

- The Subordinate returns a persist response, Persist, to the Requester.

### 2.3.3 Atomic transactions

Figure 2-9 shows the possible transaction flows for an Atomic transaction.

![](7c0a9511fa02b6c2c125ff5be465186e_img.jpg)

Sequence Diagram: Atomic Transactions

Participants: Requester, Home

Flow:

1. Requester sends `AtomicStore` to Home.
2. Home sends `Comp` back to Requester.
3. Home sends `CompDBIDResp` back to Requester.
4. Home sends `NCBWrData` back to Requester.
5. Home sends `TagMatch` back to Requester (Optional).

Alternative Flows:

- **[1a. Separate responses]**: Home sends `DBIDResp, DBIDRespOrd` back to Requester.
- **[1b. Combined response]**: Home sends `Comp, CompDBIDResp` back to Requester.

Flow for [2. Other Atomic Transactions]:

1. Requester sends `AtomicLoad/Swap/Compare` to Home.
2. Home sends `DBIDResp, DBIDRespOrd` back to Requester.
3. Home sends `NCBWrData` back to Requester.
4. Home sends `CompData` back to Requester.
5. Home sends `TagMatch` back to Requester (Optional).

Figure 2-9 Atomic Transactions

The sequence for the Atomic transaction is:

- The Requester has two alternatives to complete the transaction, depending on the request type.

The Atomic transactions are:

- AtomicStore
- AtomicLoad
- AtomicSwap
- AtomicCompare

The Requester alternatives are:

1. **AtomicStore**

For an AtomicStore transaction:

- The Requester sends an AtomicStore request to the Home.
- The Home has two alternatives to send the completion response and the data request response to the Requester.

##### **Alt 1a. Separate responses**

The Home does both the following:

- Returns a data request, DBIDResp or DBIDRespOrd, to the Requester.
- Returns a completion response, Comp, to the Requester.

It is permitted, but not required, to wait for write data before returning Comp.

##### **Alt 1b. Combined response**

The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.

- The Requester sends write data, NCBWrData, to the Home.

The Requester must only send this after it has received DBIDResp, DBIDRespOrd, or CompDBIDResp.

- Optionally, when the request requires a TagMatch response, the Home returns a tag match response, TagMatch, to the Requester.

It is permitted, but not required, to wait for write data before returning TagMatch.

#### **2. Other Atomic transactions**

For an AtomicLoad, AtomicSwap, or AtomicCompare transaction:

- The Requester sends an AtomicLoad, AtomicSwap, or AtomicCompare request to the Home.

- The Home sends a data request response, DBIDResp or DBIDRespOrd, to the Requester.

- The Requester sends write data, NCBWrData, to the Home.

The Requester must only send this after it has received DBIDResp or DBIDRespOrd. The Requester must not wait to receive CompData before write data is sent.

- The Home returns a combined data and completion response, CompData, to the Requester.

It is permitted, but not required, to wait for write data before returning CompData.

- Optionally, when the request requires a TagMatch response, the Home returns a tag match response, TagMatch, to the Requester.

It is permitted, but not required, to wait for write data before returning TagMatch.

### **2.3.4 Stash transactions**

Figure 2-10 on page 2-70 shows the possible transaction flows for stash transactions.

![](ad5d2a8873e05b8dcc418cf609192c78_img.jpg)

Sequence Diagram: Stashing

Participants: Requester, Home, Stashee

1. Write with Stash Hint

- Requester sends `WriteUniquePitStash, WriteUniqueFullStash` to Home.
- Home sends `See Immediate Write for details of WriteUnique completion.` to Requester.

2. Independent Stash without StashDone response

- Home sends `StashOnceUnique, StashOnceShared` to Stashee.
- Stashee sends `opt` to Home.
- Home sends `[1a. SnpUniqueStash]` to Stashee.
- Stashee sends `SnpUniqueStash` to Home.
- Home sends `alt` to Stashee.
- Home sends `[1a1. No DataPull]` to Stashee.
- Stashee sends `SnpResp, SnpRespData, SnpRespDataPf (No DataPull)` to Home.
- Home sends `[1a2. DataPull]` to Stashee.
- Stashee sends `SnpResp, SnpRespData, SnpRespDataPf (DataPull)` to Home.
- Home sends `See Allocating Read for details of read completion.` to Stashee.
- Home sends `[1b. Other stashing snoops]` to Stashee.
- Stashee sends `SnpMakeInvalidStash, SnpStashUnique, SnpStashShared` to Home.
- Home sends `alt` to Stashee.
- Home sends `[1b1. No DataPull]` to Stashee.
- Stashee sends `SnpResp (No DataPull)` to Home.
- Home sends `[1b2. DataPull]` to Stashee.
- Stashee sends `SnpResp (DataPull)` to Home.
- Home sends `See Allocating Read for details of read completion.` to Stashee.

3. Independent Stash with StashDone response

- Home sends `StashOnceSepUnique, StashOnceSepShared` to Stashee.
- Stashee sends `opt` to Home.
- Home sends `[2a. No DataPull]` to Stashee.
- Stashee sends `SnpResp (No DataPull)` to Home.
- Home sends `[2b. DataPull]` to Stashee.
- Stashee sends `SnpResp (DataPull)` to Home.
- Home sends `See Allocating Read for details of read completion.` to Stashee.

4. Separate response from Home

- Home sends `Comp` to Requester.
- Home sends `StashDone` to Requester.

5. Combined response from Home

- Home sends `CompStashDone` to Requester.

Figure 2-10 Stash transactions

The Stash transactions are:

- WriteUniquePtlStash
- WriteUniqueFullStash
- StashOnceUnique
- StashOnceShared
- StashOnceSepUnique
- StashOnceSepShared

The following can affect transaction flow:

- It is permitted for the Home to ignore the Stash request and not perform any stash snoops.
- The Stashee is permitted to ignore the Stash request and not request a data pull to complete the transaction.
- StashOnceSepUnique and StashOnceSepShared can have a separate StashDone response or combined CompStashDone response.

There are three alternatives for the Requester to send a stash request to the Home:

#### 1. **A write with stash hint.**

- A write with stash hint starts the transaction.  
  The write with stash hint transactions are:
  - WriteUniquePtlStash
  - WriteUniqueFullStash
- The WriteUnique uses the same transaction flows as an Immediate Write, see [Immediate write on page 2-49](#) for details.
- The Home can optionally send a stash snoop request.

##### **Alt 1a. SnpUniqueStash**

- The Home sends SnpUniqueStash to the Stashee.  
  Typically the Home sends SnpUniqueStash for a partial line write. Other snoops, including other stash snoops, are permitted.
- The Stashee has two alternatives to respond to the stash snoop request.

##### **Alt 1a1. No DataPull**

Not request a data pull

##### **Alt 1a2 DataPull**

Request a data pull.

The completion of a request with data pull is identical to the completion of an Allocating Read transaction, see [Allocating Read on page 2-41](#) for details.

##### **Alt 1b. Other stash snoops**

- Send SnpMakeInvalidStash, SnpStashShared, or SnpStashUnique, to the Stashee.  
  Typically, the Home sends SnpMakeInvalidStash for a full line write. Other snoops, including other stash snoops, are permitted.
- The Stashee has two alternatives to respond to the stash snoop request.

###### **Alt 1b1. No DataPull**

Not request a data pull.

###### **Alt 1b2. DataPull**

Request a data pull.

The completion of a request with data pull is identical to the completion of an Allocating Read transaction, see [Allocating Read on page 2-41](#) for details.

#### 2. **An independent stash request, without StashDone response.**

- An independent stash request, without a StashDone response starts the transaction.

The independent stash requests without a StashDone response, are:

- — StashOnceUnique
- — StashOnceShared

• The Home can optionally send a stash snoop request, SnpStashUnique or SnpStashShared, to the Stashee.

Typically the Home sends SnpStashUnique when the original request is StashOnceUnique and SnpStashShared when the original request is StashOnceShared.

- — The Stashee has two alternatives to respond to the stash snoop request.

##### **Alt 2a. No DataPull**

Not request a data pull.

##### **Alt 2b. DataPull**

Request a data pull.

The completion of a request with data pull is identical to the completion of an Allocating Read transaction, see *Allocating Read on page 2-41* for details.

• The transaction completes with the Home returning a completion response, Comp, to the original Requester.

It is permitted, but not required, to wait for the stash transaction to complete before the Comp response is returned.

#### **3. An independent stash request, with a StashDone response.**

• An independent stash request, with a StashDone response begins the transaction.

The independent stash requests, with a StashDone response, are:

- — StashOnceSepUnique
- — StashOnceSepShared

• The Home can optionally send a stash snoop request, SnpStashUnique or SnpStashShared, to the Stashee.

Typically the Home sends SnpStashUnique when the original request is StashOnceSepUnique and SnpStashShared when the original request is StashOnceSepShared.

- — The Stashee has two alternatives to respond to the stash snoop request.

##### **Alt3a1. No DataPull**

Not request a data pull.

##### **Alt 3a2. DataPull**

Request a data pull.

The completion of a request with data pull is identical to the completion of an Allocating Read transaction, see *Allocating Read on page 2-41* for further details.

• The Home has two alternatives to complete the transaction.

##### **Alt 3b1. Separate response from Home**

The Home does both the following:

- Returns a completion response, Comp, to the Requester.
- Returns a stash done response, StashDone, to the Requester.

It is permitted, but not required, to wait for the stash transaction to complete before either response is returned.

##### **Alt 3b2. Combined response from Home**

The Home returns a combined completion and stash done response, CompStashDone, to the Requester.

It is permitted, but not required, to wait for the stash transaction to complete before the CompStashDone response is returned.

### 2.3.5 Dataless transactions

Figure 2-11 shows the transaction flow for a Dataless transaction.

![](89b3389b2c4fa1b452cf2b5daa5f82ad_img.jpg)

Figure 2-11 is a sequence diagram illustrating the Dataless Transactions flow between the Requester, Home, and Subordinate.

The overall flow is structured by an **alt** (alternative) block, defining three main transaction types:

1. **Transactions without CompAck or Persist:** The Requester sends `CleanInvalid`, `MakeInvalid`, `CleanShared`, `CleanSharedPersist`, or `Evict` to the Home. The Home returns a completion response, `Comp`, to the Requester.
2. **Transactions with CompAck:** The Requester sends `CleanUnique` or `MakeUnique` to the Home. The Home returns `Comp` to the Requester. The Requester then sends `CompAck` to the Home.
3. **Transactions with Persist:** The Requester sends `CleanSharedPersistSep` to the Home. This transaction is further broken down into three sub-branches:
   - **3a. Separate response from Home:** The Home returns `Comp` to the Requester. The Requester sends `Persist` to the Home.
   - **3b. Combined response from Home:** The Home returns `CompPersist` to the Requester.
   - **3c. Response from Home and Subordinate:** The Home returns `CleanSharedPersistSep` to the Requester. The Requester sends `Comp` to the Home. The Home returns `Comp` to the Requester. The Requester sends `Persist` to the Home.

Figure 2-11 Dataless Transactions

The Dataless transactions are:

- `CleanUnique`
- `MakeUnique`
- `Evict`
- `CleanInvalid`
- `MakeInvalid`
- `CleanShared`
- `CleanSharedPersist`
- `CleanSharedPersistSep`

The Non-stash Dataless transaction flow depends on the request type:

1. **`CleanInvalid`, `MakeInvalid`, `CleanShared`, `CleanSharedPersist`, or `Evict` transactions**
   - The Requester sends the request to the Home.
   - The Home returns a completion response, `Comp`, to the Requester.
2. **`CleanUnique` or `MakeUnique` transactions**
   - The Requester sends the request to the Home.
   - The Home returns a completion response, `Comp`, to the Requester.
   - The Requester sends a completion acknowledge, `CompAck`, to the Home.
   - The Requester must only send this after it has received `Comp`.

#### 3. CleanSharedPersistSep transaction

- The Requester sends the request to the Home.
- The Home has three alternatives to complete the transaction.

##### Alt 3a. Separate responses from the Home

The Home does both the following:

- Returns a completion response, Comp, to the Requester.
- Returns a persist response, Persist, to the Requester.

##### Alt 3b. Combined response from Home

The Home returns a combined completion and persist response, CompPersist, to the Requester.

##### Alt 3c. Response from Home and Subordinate

With the Persist response from the Subordinate, the following happens:

- The Home sends a downstream request, CleanSharedPersistSep, to the Subordinate.
- The Subordinate returns a completion response, Comp, to the Home.
- The Home returns a completion response, Comp, to the Requester.

If there is an observer downstream of the Home, the Home must wait for the Comp response from the Subordinate before returning the Comp response to the Requester.

- The Subordinate returns a persist response, Persist, to the Requester

### 2.3.6 Prefetch transactions

Figure 2-12 shows the transaction flow for a Prefetch transaction.

![Diagram illustrating Prefetch Transactions. The diagram shows two parallel paths, both labeled 'Prefetch'. Each path consists of a Requester and a Subordinate. A dashed arrow labeled 'PrefetchTgt' connects the Requester to the Subordinate in both paths.](05ee48477993259334bf37e51c0c37ca_img.jpg)

Diagram illustrating Prefetch Transactions. The diagram shows two parallel paths, both labeled 'Prefetch'. Each path consists of a Requester and a Subordinate. A dashed arrow labeled 'PrefetchTgt' connects the Requester to the Subordinate in both paths.

Figure 2-12 Prefetch Transactions

The sequence for the Prefetch transaction is:

- The Requester sends a PrefetchTgt request directly to the Subordinate.

— Note —

No response is given.

—

### 2.3.7 DVM transactions

Figure 2-13 shows the transaction flows for a DVM transaction.

![Sequence diagram showing DVM transactions between Requester and Home. The Requester sends DVMOp to Home. The Home then handles three alternatives: 1. Non-sync DVMOp with separate response (DBIDResp, NCBWrData, Comp). 2. Non-sync DVMOp with combined response (CompDBIDResp, NCBWrData). 3. Sync DVMOp (DBIDResp, NCBWrData, Comp).](26f6e6fd981d9bcf4ab4100aebb0400b_img.jpg)

Sequence diagram showing DVM transactions between Requester and Home. The Requester sends DVMOp to Home. The Home then handles three alternatives: 1. Non-sync DVMOp with separate response (DBIDResp, NCBWrData, Comp). 2. Non-sync DVMOp with combined response (CompDBIDResp, NCBWrData). 3. Sync DVMOp (DBIDResp, NCBWrData, Comp).

Figure 2-13 DVM Transactions

Snoop requests that are generated to complete a DVM transaction are considered as independent transactions from the Home and are not shown in this flow. See [Home to Snoopee DVM transactions on page 2-85](#) for more details.

The sequence for the DVM transaction is:

- The transaction starts with the Requester issuing a DVMOp request to the Home.
- The Home has three alternatives to send the completion response and the data request response to the Requester.
  1. **Non-sync DVMOp with separate response**  
     If the DVMOp is a Non-sync DVMOp, the Home can return separate responses.
     - The Home returns a data request, DBIDResp, to the Requester.
     - The Requester sends write data, NCBWrData, to the Home.  
       The Requester must only send this after it has received DBIDResp.
     - The Home returns a completion response, Comp, to the Requester.  
       It is permitted, but not required, to wait for write data before returning Comp.
  2. **Non-sync DVMOp with combined response**  
     If the DVMOp is a Non-sync DVMOp, the Home can return combined responses.
     - The Home returns a combined data request and completion response, CompDBIDResp, to the Requester.
     - The Requester sends write data, NCBWrData, to the Home.  
       The Requester must only send this after it has received CompDBIDResp.

#### 3. Sync DVMOp

If the DVMOp is a Sync DVMOp, the Home must return separate responses.

- The Home returns a data request, DBIDResp, to the Requester.
- The Requester sends write data, NCBWrData, to the Home.  
  The Requester must only send this after it has received DBIDResp.
- The Home returns a completion response, Comp, to the Requester.  
  The Home must only return this after it has received write data.

### 2.3.8 Retry

Figure 2-14 shows the possible transaction flows for a Retry sequence.

![Sequence diagram titled 'Retry' showing interactions between Requester and Completer. The flow starts with Requester sending 'Request without Credit' to Completer. Completer sends 'RetryAck' back to Requester. Requester sends 'PCrdGrant' to Completer. An 'alt' block follows, containing two options: (1) 'Request resent' (Requester sends 'Request with Credit' to Completer, then Completer sends 'PCrdReturn' back to Requester) and (2) 'Request cancelled' (Completer sends 'PCrdReturn' directly to Requester).](c51b46bece9e94eff9615851747f31cc_img.jpg)

Sequence diagram titled 'Retry' showing interactions between Requester and Completer. The flow starts with Requester sending 'Request without Credit' to Completer. Completer sends 'RetryAck' back to Requester. Requester sends 'PCrdGrant' to Completer. An 'alt' block follows, containing two options: (1) 'Request resent' (Requester sends 'Request with Credit' to Completer, then Completer sends 'PCrdReturn' back to Requester) and (2) 'Request cancelled' (Completer sends 'PCrdReturn' directly to Requester).

Figure 2-14 Retry Transactions

A request transaction is first sent without a *Protocol Credit* (P-Credit). If the transaction cannot be accepted at the Completer, a RetryAck response is given indicating that the transaction is not accepted and can be sent again when an appropriate credit is provided. When the transaction is sent a second time, with a credit, it is guaranteed to be accepted.

The sequence for the Retry transaction is:

- The Requester issues a request without credit.
- The Completer returns a retry response, RetryAck, to the Requester.
- The Completer returns a protocol credit grant, PCrdGrant, to the Requester.  
  Typically the protocol credit grant is returned a significant time after the Retry response. However, it is permitted for the two responses to be returned in any order.
- The Requester has two alternatives to conclude the Retry sequence. This step must only occur after the Requester has received both RetryAck and PCrdGrant.
  1. **Resend the original request.**  
     The Requester issues a request with credit.
  2. **Cancel the request and return the credit.**  
     The Requester sends a protocol credit return, PCrdReturn, to the Completer.

### 2.3.9 Home Initiated transactions

The Home Initiated transactions are:

- [Home to Subordinate Read transactions](#)
- [Home to Subordinate Write transactions on page 2-78](#)
- [Home to Subordinate Combined Write and CMO transactions on page 2-80](#)
- [Home to Subordinate Atomic transactions on page 2-82](#)
- [Home to Subordinate Dataless transactions on page 2-81](#)
- [Home to Snoopee transactions on page 2-84](#)
- [Home to Snoopee DVM transactions on page 2-85](#)

#### Home to Subordinate Read transactions

Figure 2-15 shows the possible transaction flows for a Home to Subordinate Read transaction.

![Sequence diagram titled 'Home Read' showing interactions between Home and Subordinate. The diagram is enclosed in an 'alt' combined fragment, representing two possible transaction flows: 1. Combined response from Subordinate, and 2. Separate response from Subordinate. Flow 1: Home sends ReadNoSnp to Subordinate. Subordinate returns ReadNoSnp. If Order != 00, Subordinate optionally returns ReadReceipt, followed by CompData returned to Home. Flow 2: Home sends ReadNoSnpSep to Subordinate. Subordinate returns ReadNoSnpSep. If Order != 00, Subordinate optionally returns ReadReceipt, followed by DataSepResp returned to Home.](fd6ee6f896324983fe3a8e9ee6c534b3_img.jpg)

Sequence diagram titled 'Home Read' showing interactions between Home and Subordinate. The diagram is enclosed in an 'alt' combined fragment, representing two possible transaction flows: 1. Combined response from Subordinate, and 2. Separate response from Subordinate. Flow 1: Home sends ReadNoSnp to Subordinate. Subordinate returns ReadNoSnp. If Order != 00, Subordinate optionally returns ReadReceipt, followed by CompData returned to Home. Flow 2: Home sends ReadNoSnpSep to Subordinate. Subordinate returns ReadNoSnpSep. If Order != 00, Subordinate optionally returns ReadReceipt, followed by DataSepResp returned to Home.

Figure 2-15 Home Read Transactions

The supported transactions are ReadNoSnp and ReadNoSnpSep.

The transaction flow depends on the transaction type.

1. **Combined response from Subordinate**
   - For a ReadNoSnp transaction, the Home issues the request to the Subordinate.
   - Optionally, when the request has Order set to non-zero the Subordinate returns a ReadReceipt response.
   - The Subordinate returns a combined completion response and read data, CompData, to the Home.
2. **Separate responses from Subordinate**
   - For a ReadNoSnpSep transaction, the Home issues the request to the Subordinate.
   - Optionally, when the request has Order set to non-zero, the Subordinate returns a ReadReceipt response.
   - The Subordinate returns read data, DataSepResp, to the Home.

#### Home to Subordinate Write transactions

Figure 2-16 shows the possible transaction flows for a Home to Subordinate Write transaction.

![](92f8a2dda0aa6e2c03e3fe24131ab6fe_img.jpg)

Sequence diagram illustrating Home to Subordinate Write transactions.

The diagram shows interactions between the Home and the Subordinate.

1. The Home sends `WriteNoSnpPtl` or `WriteNoSnpFull` to the Subordinate.

2. The Subordinate handles the request using an `alt` (alternative) structure:

- **[1. Separate response]**: The Subordinate returns `DBIDResp` and `Comp` to the Home.
- **[2. Combined response]**: The Subordinate returns `CompDBIDResp` to the Home.

3. The Home sends `NCBWrData` or `WriteDataCancel` to the Subordinate.

4. The Subordinate handles optional responses using an `opt` (optional) structure:

- **[Optional TagMatch response]**: The Subordinate returns `TagMatch` to the Home.

Figure 2-16 Home Write Transactions

The sequence for the Home to Subordinate Write transaction is:

- The transaction starts with the Home issuing a `WriteNoSnpPtl` or `WriteNoSnpFull` request to the Subordinate.
- The Subordinate has two alternatives to return the completion response and the data request response to the Home.
  1. **Separate response**

     The Subordinate does both the following:

     - Returns a Data request response, `DBIDResp`, to the Home.
     - Returns a completion response, `Comp`, to the Home.

     It is permitted, but not required, to wait for write data before returning `Comp`.
  2. **Combined response**

     The Subordinate returns a combined data request and completion response, `CompDBIDResp`, to the Home.
- The Home sends write data, `NCBWrData`, or a cancellation, `WriteDataCancel` to the Subordinate.

  The Home must only send this after it has received `DBIDResp` or `CompDBIDResp`.
- Optionally, when the request requires a `TagMatch` response, the Subordinate returns a `Tag match` response, `TagMatch`, to the Home.

  It is permitted, but not required, to wait for write data before returning `TagMatch`.

##### Home to Subordinate Write Zero transactions

Figure 2-17 shows the possible transaction flows for a Home to Subordinate Write Zero transaction.

![](b11f4bc2bbfc46968de10a8ad2a8902f_img.jpg)

Sequence diagram illustrating Home to Subordinate Write Zero transactions.

The diagram shows the Home initiating a `WriteNoSnpZero` message to the Subordinate. The Subordinate then performs an `alt` (alternative) operation:

1. **Separate response from Home:** The Subordinate sends `DBIDResp` and `Comp` messages back to the Home.
2. **Combined response from Home:** The Subordinate sends `CompDBIDResp` back to the Home.

Figure 2-17 Home to Subordinate Write Zero

The sequence for Write Zero is:

- The transaction starts with the Home issuing a Write Zero request to the Subordinate.

The Write Zero transaction is:

— WriteNoSnpZero

- The Subordinate has two alternatives to return the completion response and data request response to the Home.

1. **Separate response from Home**

The Subordinate does both the following:

- Returns a data request response, `DBIDResp`, to the Home.
- Returns a completion response, `Comp`, to the Home.

1. **Combined response from Home**

The Subordinate returns a combined data request and completion response, `CompDBIDResp`, to the Home.

#### Home to Subordinate Combined Write and CMO transactions

Figure 2-18 shows the possible transaction flows for a Home to Subordinate Combined Write and CMO transaction.

![](8e21461e0c9384ec60322bedb1b1ab17_img.jpg)

Sequence diagram illustrating Home to Subordinate Combined Write and CMO transactions.

The Home sends a Combined Write and CMO request to the Subordinate, consisting of multiple write commands:

- WriteNoSnpPtlCleanInv
- WriteNoSnpFullCleanInv
- WriteNoSnpPtlCleanSh
- WriteNoSnpFullCleanSh
- WriteNoSnpPtlCleanShPerSep
- WriteNoSnpFullCleanShPerSep

The Subordinate processes the request and sends one of the following responses:

1. **Alt 1a. Separate responses from Subordinate**
   - DBIDResp
   - Comp
2. **Alt 1b. Combined response from Subordinate**
   - CompDBIDResp

The Home then sends NCBWrData or WriteDataCancel to the Subordinate.

The Subordinate also handles two alternative paths:

1. **Alt 2a. Non-persist CMO**
   - CompCMO
2. **Alt 2b. Persist CMO**
   - **Alt 2b1. Separate response from Subordinate**
     - CompCMO
     - Persist
   - **Alt 2b2. Combined response from Subordinate**
     - CompPersist

Figure 2-18 Home Combined Write and CMO Transactions

The sequence for the Home to Subordinate Combined Write with CMO transaction is:

- The transaction starts with the Home issuing a Combined Write and CMO request to the Subordinate. The Home Combined Write and CMO transactions are:
  - WriteNoSnpPtlCleanInv
  - WriteNoSnpFullCleanInv
  - WriteNoSnpPtlCleanSh
  - WriteNoSnpFullCleanSh
  - WriteNoSnpPtlCleanShPerSep
  - WriteNoSnpFullCleanShPerSep
- The Subordinate has two alternatives to send the completion response and the data request response to the Home.
  - **Alt 1a. Separate responses from Subordinate**

    The Subordinate does both the following:

    - Returns a data request, DBIDResp, to the Home.
    - Returns a completion response, Comp, to the Home.

    It is permitted, but not required, to wait for write data before returning Comp.
  - **Alt 1b. Combined response from Subordinate**

    The Subordinate returns a combined data request and completion response, CompDBIDResp, to the Home.
- The Home sends write data, NCBWrData, or a cancellation, WriteDataCancel, to the Subordinate. The Home must only send this after it has received DBIDResp or CompDBIDResp.

- There are two alternatives for the Subordinate to return the CMO response depending on whether or not a persist response, Persist, is required.

It is permitted, but not required, for the Subordinate to wait for write data before returning CompCMO, Persist, or CompPersist.

##### **Alt 2a. Non-persist CMO**

When a persist response is not required, the Subordinate returns a CMO completion response, CompCMO, to the Home.

##### **Alt 2b. Persist CMO**

When a persist response is required, the Subordinate has two alternatives to send the CMO completion response and persist response.

##### **Alt 2b1. Separate response from Subordinate**

The Subordinate does both the following:

- Returns a CMO completion response, CompCMO, to the Home.
- Returns a persist response, Persist, to the Home.

###### **Alt 2b2. Combined response from Subordinate**

The Subordinate returns a combined CMO completion response and persist response, CompPersist, to the Home.

#### Home to Subordinate Dataless transactions

Figure 2-19 shows the transaction flows for a Home to Subordinate Dataless transaction.

![Figure 2-19: Home to Subordinate Dataless Transactions. A sequence diagram showing interactions between Home and Subordinate. The diagram is divided into two main sections: 1. Transactions without separate Persist, and 2. Transactions with separate Persist. Both sections are enclosed in an 'alt' block. Section 1 shows Home sending CleanInvalid, MakeInvalid, CleanShared, CleanSharedPersist messages to Subordinate, followed by Subordinate sending Comp to Home. Section 2 shows Home sending CleanSharedPersistSep to Subordinate, followed by Subordinate sending Comp, Persist, and CompPersist messages to Home.](05af431fdb1e867f0ceaf93a68e4e3f2_img.jpg)

Figure 2-19: Home to Subordinate Dataless Transactions. A sequence diagram showing interactions between Home and Subordinate. The diagram is divided into two main sections: 1. Transactions without separate Persist, and 2. Transactions with separate Persist. Both sections are enclosed in an 'alt' block. Section 1 shows Home sending CleanInvalid, MakeInvalid, CleanShared, CleanSharedPersist messages to Subordinate, followed by Subordinate sending Comp to Home. Section 2 shows Home sending CleanSharedPersistSep to Subordinate, followed by Subordinate sending Comp, Persist, and CompPersist messages to Home.

Figure 2-19 Home to Subordinate Dataless Transactions

The sequence for the Home to Subordinate Dataless transaction is:

- The transaction flow depends on the request type.

The Home Dataless transactions are:

- CleanInvalid
- MakeInvalid
- CleanShared
- CleanSharedPersist
- CleanSharedPersistSep

1. **Transactions without separate Persist:**  
   CleanInvalid, MakeInvalid, CleanShared, or CleanSharedPersist transaction
   - The Home sends the request to the Subordinate.
   - The Subordinate returns a completion response, Comp, to the Requester.
2. **Transactions with separate Persist:**  
   CleanSharedPersistSep transaction
   - The Home sends the request to the Subordinate.
   - The Subordinate has two alternatives to complete the transaction.

     **Alt 2a. Separate response from Subordinate**  
     The Subordinate does both the following:
     - Returns a completion response, Comp, to the Home.
     - Returns a persist response, Persist, to the Home.Use of separate completion response, Comp, and persist response, Persist, allows a Completer to send an early Comp without waiting for Persist. Typically, Persist takes much longer.
   - **Alt 2b. Combined response from Subordinate**  
     The Subordinate returns a combined completion and persist response, CompPersist, to the Home.

#### Home to Subordinate Atomic transactions

Figure 2-20 shows the possible transaction flows for a Home to Subordinate Atomic transactions.

![](a0f1c3f5f43cd5623462acd915d5ce76_img.jpg)

Sequence Diagram: Home Atomic transactions

The diagram illustrates the interaction between Home and Subordinate for atomic transactions, structured by an `alt` (alternative) block.

**Flow 1: Atomic Store**

- Home sends `AtomicStore` to Subordinate.
- Subordinate sends `DBIDResp` back to Home.
- Subordinate sends `Comp` back to Home.
- Subordinate sends `NCBWrData` back to Home.
- Subordinate sends `TagMatch` back to Home (optional, `opt` block).

**Flow 2: Not Atomic Store**

- Home sends `AtomicLoad/Swap/Compare` to Subordinate.
- Subordinate sends `DBIDResp` back to Home.
- Subordinate sends `NCBWrData` back to Home.
- Subordinate sends `CompData` back to Home.
- Subordinate sends `TagMatch` back to Home (optional, `opt` block).

Figure 2-20 Home Atomic transactions

The Atomic transactions the Home can issue are:

- AtomicStore
- AtomicLoad
- AtomicSwap
- AtomicCompare

When the Subordinate supports the execution of atomic operations, the Home is permitted to forward Atomic transactions to the Subordinate.

There are two alternatives for the Home to complete the transaction, depending on the request type.

##### 1. **AtomicStore**

- The Home sends an AtomicStore request to the Subordinate.
- The Subordinate has two alternatives to send the completion response and data request response to the Home.

###### **Alt 1a. Separate responses**

The Subordinate does both the following:

- Returns a data request, DBIDResp, to the Home.
- Returns a completion response, Comp, to the Home.

It is permitted, but not required, to wait for write data before returning Comp.

###### **Alt 1b. Combined response**

The Subordinate returns a combined data request and completion response, CompDBIDResp, to the Home.

- The Home sends write data, NCBWrData, to the Subordinate.

The Home must only send this after it has received DBIDResp or CompDBIDResp. The Home must not wait for Comp before sending write data.

- Optionally, when the request requires a tag match response, the Subordinate returns a TagMatch response to the Home.

It is permitted, but not required, to wait for write data before returning TagMatch.

##### 2. **Not AtomicStore**

- The Home sends an AtomicLoad, AtomicSwap, or AtomicCompare request to the Subordinate.

- The Subordinate sends a data request response, DBIDResp, to the Home.

- The Home sends write data, NCBWrData, to the Subordinate.

The Home must only send this after it has received DBIDResp. The Home must not wait to receive CompData before write data is sent.

- The Subordinate returns a combined data and completion response, CompData, to the Home.

It is permitted, but not required, to wait for write data before returning CompData.

- Optionally, when the request requires a TagMatch response, the Subordinate returns a tag match response, TagMatch, to the Home.

It is permitted, but not required, to wait for write data before returning TagMatch.

#### Home to Snoopee transactions

Figure 2-21 shows the possible transaction flows for a Home to Snoopee transaction.

![Sequence diagram titled 'Home Snoop' showing the interaction between Home and Snoopee. The Home sends a message 'Snp', SnpFwd' to Snoopee. Snoopee then performs an 'alt' (alternative) operation. Alternative 1, labeled '[1. Response to home]', involves Snoopee sending 'SnpResp' back to Home. Alternative 2, labeled '[2. Data to home]', involves Snoopee sending 'SnpRespData, SnpRespDataPlt' back to Home.](d461c6341beba90844ef785469cd757f_img.jpg)

Sequence diagram titled 'Home Snoop' showing the interaction between Home and Snoopee. The Home sends a message 'Snp', SnpFwd' to Snoopee. Snoopee then performs an 'alt' (alternative) operation. Alternative 1, labeled '[1. Response to home]', involves Snoopee sending 'SnpResp' back to Home. Alternative 2, labeled '[2. Data to home]', involves Snoopee sending 'SnpRespData, SnpRespDataPlt' back to Home.

Figure 2-21 Home Snoop Transactions

The following transactions must use this transaction flow.

- SnpOnce
- SnpClean
- SnpNotSharedDirty
- SnpShared
- SnpUnique
- SnpPreferUnique
- SnpCleanShared
- SnpCleanInvalid
- SnpMakeInvalid

The following transactions are also permitted to use this transaction flow.

- SnpOnceFwd
- SnpCleanFwd
- SnpNotSharedDirtyFwd
- SnpSharedFwd
- SnpUniqueFwd
- SnpPreferUniqueFwd

The sequence the Home to Snoopee transaction is:

- The transaction starts with the Home issuing a Snoop request to the Snoopee.
- The Snoopee has two alternatives to complete the transaction.
  1. The Snoopee provides a snoop response, SnpResp, to the Home. This is the only permitted alternative for a SnpMakeInvalid transaction.
  2. The Snoopee provides a snoop response with data, SnpRespData or SnpRespDataPlt.

##### Home to Snoopee DVM transactions

Figure 2-22 shows the transaction flow for a Home to Snoopee DVM transaction, SnpDVMOp.

![](57261b803cf2db0e8feca169cb2c416b_img.jpg)

Figure 2-22 illustrates the Home DVM Snoop transaction flow. The diagram shows two pairs of entities: Home and Snoopee. The top pair represents the initial state, and the bottom pair represents the state after the transaction completes.

The sequence of messages is as follows:

1. The Home entity sends two Snoop DVM Operations (SnpDVMOp) to the Snoopee entity.
2. The Snoopee entity sends a Snoop Response (SnpResp) back to the Home entity.

The diagram visually represents the flow of these messages between the Home and Snoopee entities.

Figure 2-22 Home DVM Snoop

The sequence for the Home to Snoopee DVM transaction is:

- The Home issues two Snoop DVM requests, SnpDVMOp, to the Snoopee.
- The Snoopee provides a single Snoop response, SnpResp.

The Snoopee must only provide the Snoop response after it has received both Snoop DVM requests.

## 2.4 Transaction identifier fields

Each transaction consists of a number of different packets that are transferred across the interconnect. A set of identifier fields, within a packet, are used to provide additional information about a packet. The different identifier fields are:

### **Target Identifier (TgtID), Source Identifier (SrcID)**

These identifiers route packets across the interconnect. See [Details of transaction identifier fields](#) on page 2-87 and [Chapter 3 Network Layer](#).

### **Transaction Identifier (TxnID), Data Buffer Identifier (DBID), Return Transaction Identifier (ReturnTxnID), Forward Transaction Identifier (FwdTxnID)**

These fields relate all the packets associated with a single transaction. See [Details of transaction identifier fields](#) on page 2-87.

### **Data Identifier (DataID), Critical Chunk Identifier (CCID)**

These fields identify the individual data packets within a transaction. See [Data packetization](#) on page 2-136.

### **Logical Processor Identifier (LPID), Stash Logical Processor Identifier (StashLPID)**

These fields identify individual processing agents within a single Requestor. See [Logical Processor Identifier](#) on page 2-113.

### **Stash Node Identifier (StashNID)**

This field identifies the node that is the Stash target. See [Supporting REQ packet fields](#) on page 7-300.

### **Return Node Identifier (ReturnNID)**

This field identifies the recipient node for the Data response, Persist response, or TagMatch response. See [Details of transaction identifier fields](#) on page 2-87.

### **Forward Node Identifier (FwdNID)**

This field identifies the recipient node for the Data response. See [Details of transaction identifier fields](#) on page 2-87.

### **Home Node Identifier (HomeNID)**

This field is used to identify the recipient node for the CompAck response. See [Details of transaction identifier fields](#) on page 2-87.

### **Persistent Group Identifier (PGroupID)**

This field is used to identify different sets of CleanSharedPersistSep transactions. See [Details of transaction identifier fields](#) on page 2-87.

### **Stash Group Identifier (StashGroupID)**

This field is used to identify different sets of StashOnceSep transactions. See [Stash Group Identifier, StashGroupID](#) on page 13-419.

### **Tag Group Identifier (TagGroupID)**

This field is used to identify different sets of Write transactions that require Tag Match operations to be performed. See [Tag Group Identifier, TagGroupID](#) on page 13-435.

## 2.5 Details of transaction identifier fields

This section describes the application of transaction identifier fields.

### 2.5.1 Target ID and Source ID

A transaction request includes a TgtID that identifies the target node, and a SrcID that identifies the source node. These IDs are used to route packets across the interconnect.

### 2.5.2 Transaction ID

A transaction request includes a TxnID that is used to identify the transaction from a given Requester. It is required that the TxnID, except for PrefetchTgt, must be unique for a given Requester. The Requester is identified by the SrcID. This ensures that any returning read data or response information can be associated with the correct transaction.

A 12-bit field is defined for the TxnID with the number of outstanding transactions being limited to 1024. A Requester is permitted to reuse a TxnID value after it has received either:

- All responses associated with a previous transaction that have used the same value.
- A RetryAck response for a previous transaction that used the same value.

*Transaction identifier field flows on page 2-92* gives more detailed rules for the different transaction types. The TxnID field is not applicable in a PrefetchTgt request and can take any value.

A value used in the TxnID field of a Request from Home to Subordinate can be reused by Home once all responses that are required to deallocate the request are received or a RetryAck response is received.

A transaction that is retried is not required to use the same TxnID. See *Request Retry on page 2-145*.

### 2.5.3 Return Node ID

A transaction request from Home to Subordinate includes a ReturnNID that is used to determine the TgtID for the following responses from the Subordinate Node:

- Data response
- DBIDResp response
- Persist response
- TagMatch response

Its value must be either the node ID of Home or the node ID of the original Requester.

ReturnNID is only applicable in a ReadNoSnp, ReadNoSnpSep, CleanSharedPersistSep, WriteNoSnp, Combined Write, and Atomic requests from Home to Subordinate. The field is inapplicable and must be set to zero in all other requests from Home to Subordinate.

ReturnNID is inapplicable and must be set to zero in all requests from Requester to Home and Requester to Subordinate.

The following are the expected and permitted values for the ReturnNID in requests from the Home Node to the Subordinate Node.

In ReadNoSnp, ReadNoSnpSep, and CleanSharedPersistSep:

- Expected value is the original Requester node ID but is permitted to be the Home Node ID.
- Used as the TgtID in CompData, DataSepResp and Persist responses.

In Atomic with TagOp *Invalid*:

- For AtomicStore, ReturnNID can take any value and the value is not used in any responses.
- For Non-store Atomics, the ReturnNID must be the Home Node ID. The value is used as the TgtID in CompData.

In Atomic with TagOp *Match*:

- ReturnNID must be the Home Node ID.
- The value is used as the TgtID in CompData and TagMatch responses.

In WriteNoSnp with TagOp not *Match*:

- When DoDWT = 0, the ReturnNID can take any value, and the value is not used in any responses.
- When DoDWT = 1, the ReturnNID value is expected to be the original Requester Node ID but is permitted to be the Home Node ID. Used as the TgtID in the DBIDResp response.

In WriteNoSnp with TagOp *Match*:

- Irrespective of the value of DoDWT, the ReturnNID value is expected to be the original Requester Node ID but is permitted to be the Home Node ID.
- When DoDWT = 0, the value is used as the TgtID in the TagMatch response only.
- When DoDWT = 1, the value is used as the TgtID in the DBIDResp and TagMatch responses.

In Non-PCMO Combined Write:

- When DoDWT = 0, the ReturnNID can take any value, and the value is not used in any responses.
- When DoDWT = 1, the ReturnNID value is expected to be the original Requester Node ID but is permitted to be the Home Node ID. Used as the TgtID in the DBIDResp response.

In WriteNoSnpFullClnShPer and WriteNoSnpPtlClnShPer:

- Irrespective of the value of DoDWT, the ReturnNID value is expected to be the original Requester Node ID but is permitted to be the Home Node ID.
- When DoDWT = 0, the value is used as the TgtID in the Persist response only.
- When DoDWT = 1, the value is used as the TgtID in the DBIDResp and Persist responses.

### 2.5.4 Return Transaction ID

A transaction request from Home to Subordinate also includes a ReturnTxnID field to convey the value of TxnID in the data response and the DBIDResp response from the Subordinate. Its value, when applicable, must be either:

- The TxnID generated by Home, when the ReturnNID is the node ID of the Home.
- The TxnID of the original Requester, when the ReturnNID is the node ID of the original Requester.

ReturnTxnID is only applicable in a ReadNoSnp, ReadNoSnpSep, WriteNoSnp, Combined Write, and Atomic requests from Home to Subordinate. The field is inapplicable and must be set to zero in all other requests from Home to Subordinate.

ReturnTxnID is inapplicable and must be set to zero in all requests from Requester to Home and Requester to Subordinate.

The following are the expected and permitted values for ReturnTxnID in requests from the Home Node to the Subordinate Node.

In ReadNoSnp and ReadNoSnpSep:

- Expected value is the original Requester TxnID but permitted to be the Home TxnID.
- Used as the TxnID in the CompData and DataSepResp responses.

In Atomic with TagOp *Invalid* or *Match*:

- For AtomicStore, the ReturnTxnID can take any value, and the value is not used in any response.
- For Non-store Atomic, the ReturnTxnID must be the Home TxnID. The value is used as the TxnID in the CompData response.

In WriteNoSnp with any TagOp value:

- When DoDWT = 0, ReturnTxnID can take any value, and the value is not used in any response.
- When DoDWT = 1, ReturnTxnID value is expected to be the original Requester TxnID but is permitted to be the Home TxnID. Used as the TxnID in the DBIDResp. response.

In Combined Write:

- When DoDWT = 0, ReturnTxnID can take any value, and the value is not used in any response.
- When DoDWT = 1, ReturnTxnID value is expected to be the original Requester TxnID but is permitted to be the Home TxnID. Used as the TxnID in the DBIDResp response.

### 2.5.5 Home Node ID

CompData includes the HomeNID field that is used by the Requester to identify the target of the CompAck that it might need to send in response to CompData. HomeNID is applicable in CompData and DataSepResp and is inapplicable and must be set to zero for all other Data messages.

###### Note

There is no functional requirement for the HomeNID and DBID fields in the DataSepResp response because the values that are provided in the RespSepData response are identical and can always be used. However, it is required that these values are included to help with debugging and protocol checking.

### 2.5.6 Persistence Group ID

A CleanSharedPersistSep and Combined Write with Persistent CMO (PCMO) request includes a PGroupID to identify the Persistence Group that the request belongs to. If a Requester has persistent CMO requests from different functional agents that it would like to identify for permanent persistent CMO handling, it can assign a different PGroupID value to each group of Persist requests. Use of this 8-bit field is applicable in CleanSharedPersistSep and Combined Write with PCMO transactions. It is also applicable in Persist and CompPersist responses. It is inapplicable and must be set to zero in all other requests and responses. See *Persistence Group Identifier, PGroupID* on page 13-418:

- PGroupID must be sent in the CleanSharedPersistSep request and a Combined Write request that includes a PCMO.
- The PGroupID value returned in the Persist response can be used by a Requester to separately track completions of Persist responses from each group.
- It is expected that a Requester that does not support multiple persistence groups sets the PGroupID value to zero.
- A Requester that is making use of PGroupID for passing a barrier typically will not reuse a PGroupID value until all the earlier sent CleanSharedPersistSep requests from that group have received Persist responses.
- The Completer is required to reflect back PGroupID in the Persist and CompPersist responses, and the responses of Combined Write requests that include a PCMO.
- The PGroupID field in the Comp and CompCMO response from both the Home and Subordinate is inapplicable and must be set to zero.

### 2.5.7 Forward Node ID

A Snoop request from Home to RN-F includes a FwdNID that is used to determine the TgtID for the Data response from the Snoopee. Its value must be the Node ID of the original Requester.

The FwdNID field is only applicable in:

- SnpSharedFwd
- SnpCleanFwd
- SnpOnceFwd
- SnpNotSharedDirtyFwd
- SnpUniqueFwd
- SnpPreferUniqueFwd

It is inapplicable and must be set to zero in all other snoop requests, except range-based TLBI DVM operations. For range-based TLBI operations, the bits in the field are used for DVM payload.

### 2.5.8 Forward Transaction ID

A Snoop request from Home to RN-F also includes a FwdTxnID field to convey the value of TxnID in the Data response from the Snoopee. Its value must be the TxnID of the original Request.

The FwdTxnID field is only applicable in:

- SnpSharedFwd
- SnpCleanFwd
- SnpOnceFwd
- SnpNotSharedDirtyFwd
- SnpUniqueFwd
- SnpPreferUniqueFwd

It is inapplicable and must be set to zero in all other snoop requests.

### 2.5.9 Data Buffer ID

The DBID field permits the Completer of a transaction to provide its own identifier for a transaction. The Completer sends a response that includes a DBID. The DBID value is used as the TxnID field value in the:

- WriteData response of Write, Combined Write, Atomic, and DVMOp transactions.
- CompData response of Stash transactions for Data Pull purposes.
- CompAck response of Read, Dataless, WriteNoSnp, WriteUnique and Non-CopyBack Combined Write transactions that include a CompAck response.

The DBID value used by a Completer in responses of a given transaction must be unique for a given Requester in the following cases:

- DBIDResp or DBIDRespOrd or CompDBIDResp for all Write transactions, except in WriteNoSnpZero and WriteUniqueZero.
- DBIDResp or DBIDRespOrd or CompDBIDResp for all Combined Write transactions.
- DBIDResp or DBIDRespOrd or CompDBIDResp for Atomic transactions.
- DBIDResp or DBIDRespOrd or CompDBIDResp for DVMOp transactions.
- CompData or RespSepData for Read transactions that include CompAck, except in the case when ReadOnce\* and ReadNoSnp do not use the resultant CompAck for deallocation of the request at Home.
- Comp for Dataless transactions that include CompAck.

The DBID value is applicable in the DataSepResp response to Read requests that include CompAck and it must be the same as the DBID value in the associated RespSepData response.

A Comp response message sent separate from a DBIDResp or DBIDRespOrd message for a Write transaction must include the same DBID field value in the Comp and DBIDResp or DBIDRespOrd message.

A Comp response message sent separate from a DBIDResp or DBIDRespOrd message for a Combined Write transaction must include the same DBID field value in the Comp and DBIDResp or DBIDRespOrd message.

A Comp response message sent separate from a DBIDResp or DBIDRespOrd message for an Atomic transaction is permitted, but is not required, to include the same DBID field value in the Comp and DBIDResp or DBIDRespOrd message.

A Completer is permitted, but not required, to use the same DBID value for two transactions with different Requesters. A Completer is permitted to reuse a DBID value after it has received all packets required to deallocate a previous transaction that has used the same value. *Transaction identifier field flows on page 2-92* gives more detailed rules for the different transaction types.

The DBID value used by a Snoop Completer in response to a Stash snoop that includes a Data Pull must be unique with respect to:

- The DBID values in other Snoop responses to Stash snoops that use Data Pull.
- The TxnID of any outstanding request from that Snoop Completer.

The Completer is not required to utilize the DBID field, and is permitted to set it to any value in:

- WriteNoSnpZero and WriteUniqueZero transactions.
- Read transactions without CompAck.
- Dataless transactions without CompAck.
- Snoop response to a Stash snoop that does not include a Data Pull.
- Snoop response to a Non-stash snoop.

###### — Note —

The advantage of using the DBID assigned by the Completer, instead of the TxnID assigned by the Requester, is that the Completer can use the DBID to index into its request structure instead of performing a lookup using TxnID and SrcID to determine which transaction write data or completion acknowledge is associated with which request.

If a Completer is using the same DBID value for different Requesters, which it must do if its operation requires more than 1024 DBID responses to be active at the same time, it must use SrcID with DBID to determine which request should be associated with a write data or response message.

The DBIDResp response is also used to provide certain ordering guarantees relating to the transaction. See *Transaction ordering on page 2-118*.

## 2.6 Transaction identifier field flows

This section shows the transaction identifier field flows for the different transaction types:

- [Read transactions on page 2-93](#)
- [Dataless transactions on page 2-101](#)
- [Write transactions on page 2-103](#)
- [D/MOp transaction on page 2-111](#)
- [Transaction requests with Retry on page 2-111](#)
- [Protocol Credit Return transaction on page 2-112](#)

In the associated figures:

- The fields included in each packet are:
  - For a Request packet: TgtID, SrcID, TxnID, StashNID, StashLPID, ReturnNID, ReturnTxnID, PGroupID, StashGroupID, and TagGroupID.
  - For a Response packet: TgtID, SrcID, TxnID, DBID, PGroupID, StashGroupID, and TagGroupID.
  - For a Data packet: TgtID, SrcID, TxnID, HomeNID, and DBID.
  - For a Snoop packet: SrcNID, TxnID, FwdNID, FwdTxnID, and StashLPID.
- All fields with the same color are the same value.
- The curved loop-back arrows show how the Requester and Completer use fields from earlier packets to generate fields for subsequent packets.
- A box containing an asterisk [\*] indicates when a field is first generated, that is, it indicates the agent that determines the original value of the field.
- A field enclosed in parentheses indicates that the value is effectively a fixed value. Typically this is the case for the SrcID field when a packet is sent, and the TgtID field when a packet arrives at its destination.
- A field that is crossed-out indicates that the field is not valid.
- It is permitted for the TgtID of the original transaction to be remapped by the interconnect to a new value. This is shown by a box containing the letter R. This is explained in more detail in [Chapter 3 Network Layer](#).

###### Note

An identifier field, in every packet sent, belongs to one of the following categories:

- New value. An asterisk indicates that a new value is generated.
- Generated from an earlier packet. A loop back arrow indicates the source.
- Fixed value. The value is enclosed in brackets.
- Not valid. The field is crossed-out.

In the following examples, any transaction identifiers that are not relevant for the example are sometimes omitted for clarity.

### 2.6.1 Read transactions

This section shows identifier field flows in Read transactions with and without Direct Data Transfer:

- *ID value transfer with DMT*
- *ID value transfer with DMT and separate Comp and Data on page 2-95*
- *ID value transfer with DCT on page 2-97*
- *ID value transfer without Direct Data Transfer on page 2-99*

#### ID value transfer with DMT

Figure 2-23 shows how the Target and Transaction ID values in the DMT transaction messages are derived. For example, the value of SrcID in the ReadNoSnp request from the interconnect is assigned by the interconnect. Whereas the ReturnNID, used as TgtID in the Data response, is set to the value of SrcID of the received Read request.

![Figure 2-23 ID value transfer in a DMT transaction. The diagram illustrates the flow of transaction identifiers (TgtID, SrcID, TxnID, ReturnNID, HomeNID, DBID) between the Requester (RN), Interconnect (ICN), and Server (SN) during a Direct Data Transfer (DMT) read transaction. The flow starts with RN sending a Read packet (containing TgtID, SrcID, TxnID) to ICN. ICN processes the request, generating a ReadNoSnp packet (containing TgtID, SrcID, TxnID, ReturnNID, ReturnTxnID) and a ReadReceipt (Optional) packet. The ReadNoSnp packet is sent to SN. SN sends a CompData packet (containing TgtID, SrcID, TxnID, ReturnNID, ReturnTxnID) back to ICN. ICN sends a CompData packet (containing TgtID, SrcID, TxnID, HomeNID, DBID) back to RN. RN sends a CompAck packet (containing TgtID, SrcID, TxnID, DBID) back to ICN. The diagram also shows the flow of identifiers for the CompData packet sent from SN to ICN, and the CompData packet sent from ICN to RN, highlighting the transfer of TgtID, SrcID, TxnID, ReturnNID, and ReturnTxnID.](9acfc25b29c0ce9239e2fac2350c527e_img.jpg)

Figure 2-23 ID value transfer in a DMT transaction. The diagram illustrates the flow of transaction identifiers (TgtID, SrcID, TxnID, ReturnNID, HomeNID, DBID) between the Requester (RN), Interconnect (ICN), and Server (SN) during a Direct Data Transfer (DMT) read transaction. The flow starts with RN sending a Read packet (containing TgtID, SrcID, TxnID) to ICN. ICN processes the request, generating a ReadNoSnp packet (containing TgtID, SrcID, TxnID, ReturnNID, ReturnTxnID) and a ReadReceipt (Optional) packet. The ReadNoSnp packet is sent to SN. SN sends a CompData packet (containing TgtID, SrcID, TxnID, ReturnNID, ReturnTxnID) back to ICN. ICN sends a CompData packet (containing TgtID, SrcID, TxnID, HomeNID, DBID) back to RN. RN sends a CompAck packet (containing TgtID, SrcID, TxnID, DBID) back to ICN. The diagram also shows the flow of identifiers for the CompData packet sent from SN to ICN, and the CompData packet sent from ICN to RN, highlighting the transfer of TgtID, SrcID, TxnID, ReturnNID, and ReturnTxnID.

Figure 2-23 ID value transfer in a DMT transaction

The required steps in the flow that Figure 2-23 shows are:

1. The Requester starts the transaction by sending a Request packet.

The identifier fields of the request are generated as follows:

- The TgtID is determined by the destination of the Request.

Note

The TgtID field can be remapped to a different value by the interconnect.

- The SrcID is a fixed value for the Requester.
- The Requester generates a TxnID field that is unique for that Requester.

1. The recipient Home Node in the interconnect generates a Request to the Subordinate Node. The identifier fields of the request are generated as follows:
   - The TgtID is set to the value required for the Subordinate.
   - The SrcID is a fixed value for the Home.
   - The TxnID is a unique value generated by the Home.
   - The ReturnNID is set to the same value as the SrcID of the original request.
   - The ReturnTxnID is set to the same value as the TxnID of the original request.
2. If the request to the Subordinate requires a ReadReceipt, the Subordinate provides the read receipt. The identifier fields of the ReadReceipt response are generated as follows:
   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Subordinate. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The DBID field is not valid.
3. The Subordinate provides the read data. The identifier fields of the Read data response are generated as follows:
   - The TgtID is set to the same value as the ReturnNID of the request.
   - The SrcID is a fixed value for the Subordinate. This also matches the TgtID received.
   - The TxnID is set to the same value as the ReturnTxnID of the request.
   - The HomeNID is set to the same value as the SrcID of the request.
   - The DBID is set to the same value as the TxnID of the request.
4. The Requester receives the read data and sends a completion acknowledge, CompAck, response. The identifier fields of the CompAck are generated as follows:
   - The TgtID is set to the same value as the HomeNID of the read data.
   - The SrcID is a fixed value for the Requester. This also matches the TgtID that was received.
   - The TxnID is set to the same value as the DBID of the read data.
   - The DBID field is not valid.

The CompAck response from Requester to Home is not required for all requests.

If the original request requires a ReadReceipt, the following additional step is included:

- The Home receives the Request packet and provides the read receipt. The identifier fields of the ReadReceipt response are generated as follows:
  - The TgtID is set to the same value as the SrcID of the request.
  - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
  - The TxnID is set to the same value as the TxnID of the request.
  - The DBID field is not valid.

*Details of transaction identifier fields on page 2-87* details when the TxnID value and DBID value can be reused.

#### ID value transfer with DMT and separate Comp and Data

Figure 2-24 shows how the identifier field values are derived in DMT transaction messages that use separate Comp and Data.

![Figure 2-24: ID value transfer in a DMT transaction with separate Comp and Data. The diagram shows the flow between Requester (RN), Interconnect (ICN), and Subordinate Node (SN). The ICN is enclosed by a dashed box. The flow starts with RN sending a Read packet to ICN. The Read packet contains TgtID, SrcID, and TxnID. ICN returns a ReturnNID and ReturnTxnID packet to RN. RN sends ReadNoSnpSep to SN. SN returns a packet containing TgtID, SrcID, TxnID, ReturnNID, and ReturnTxnID. RN sends RespSepData to ICN. ICN returns a packet containing TgtID, SrcID, TxnID, and DBID. RN sends CompAck to ICN. ICN returns a packet containing TgtID, SrcID, TxnID, and DBID. RN sends DataSepResp to ICN. ICN returns a packet containing TgtID, SrcID, TxnID, HomeNID, and DBID. The diagram illustrates how identifier fields are derived and transferred between the nodes.](578d2763eaf3edf3f1bd6657455ad54a_img.jpg)

Figure 2-24: ID value transfer in a DMT transaction with separate Comp and Data. The diagram shows the flow between Requester (RN), Interconnect (ICN), and Subordinate Node (SN). The ICN is enclosed by a dashed box. The flow starts with RN sending a Read packet to ICN. The Read packet contains TgtID, SrcID, and TxnID. ICN returns a ReturnNID and ReturnTxnID packet to RN. RN sends ReadNoSnpSep to SN. SN returns a packet containing TgtID, SrcID, TxnID, ReturnNID, and ReturnTxnID. RN sends RespSepData to ICN. ICN returns a packet containing TgtID, SrcID, TxnID, and DBID. RN sends CompAck to ICN. ICN returns a packet containing TgtID, SrcID, TxnID, and DBID. RN sends DataSepResp to ICN. ICN returns a packet containing TgtID, SrcID, TxnID, HomeNID, and DBID. The diagram illustrates how identifier fields are derived and transferred between the nodes.

Figure 2-24 ID value transfer in a DMT transaction with separate Comp and Data

The required steps in the flow that Figure 2-24 shows are:

1. The Requester starts the transaction by sending a Request packet. The identifier fields of the request are generated as follows:
   - The TgtID is determined by the destination of the Request.  
     **Note**  
     The TgtID field can be remapped to a different value by the interconnect.
   - The SrcID is a fixed value for the Requester.
   - The Requester generates a TxnID field that is unique for that Requester.
2. The recipient Home Node in the interconnect generates a request to the Subordinate Node. The identifier fields of the request are generated as follows:
   - The TgtID is set to the value required for the Subordinate.
   - The SrcID is a fixed value for the Home.
   - The TxnID is a unique value generated by the Home.
   - The ReturnNID is set to the same value as the SrcID of the original request.
   - The ReturnTxnID is set to the same value as the TxnID of the original request.

1. The recipient Home Node in the interconnect provides the separate Read response.

   The identifier fields of the read response are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Home.
   - The TxnID is set to the same value as the TxnID of the original request.
   - The DBID value is a unique value generated by the Home and is the same value as the TxnID in the request to the Subordinate.
2. The Requester receives the Read response and sends a completion acknowledge, CompAck, response.

   The identifier fields of the CompAck are generated as follows:

   - The TgtID is set to the same value as the SrcID of the read response.
   - The SrcID is a fixed value for the Requester.
   - The TxnID is set to the unique DBID value generated by the Home.
   - The DBID value is not valid.
3. The request to the Subordinate requires a ReadReceipt. The Subordinate provides the read receipt.

   The identifier fields of the ReadReceipt response are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Subordinate. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
4. The Subordinate provides the separate read data.

   The identifier fields of the read data are generated as follows:

   - The TgtID is set to the same value as the ReturnNID of the request.
   - The SrcID is a fixed value for the Subordinate. This also matches the TgtID received.
   - The TxnID is set to the same value as the ReturnTxnID of the request.
   - The HomeNID is set to the same value as the SrcID of the request.
   - The DBID is set to the same value as the TxnID of the request.

#### ID value transfer with DCT

Figure 2-25 shows how the identifier field values are derived in DCT transaction messages. In this example, the data is forwarded to a Request Node and a Snoop response is sent to HN-F with or without data.

![Figure 2-25 ID value transfer in a DCT transaction. The diagram illustrates the flow of transaction messages between Request Node (RN), Interconnect Node (ICN), and Request Node Forwarder (RN-F). The flow starts with RN sending a Read message to ICN. The Read message contains TgtID, SrcID, and TxnID. ICN generates a Snoop Forwarded (SnopFwd) message to RN-F, which contains TgtID, SrcID, TxnID, FwdTxnID, and FwdTxnID. ICN also sends CompData to RN. RN sends CompAck to HN-F. HN-F sends CompData to ICN. ICN generates a Snoop Response Forwarded (SnopRespFwded) message to RN-F, which contains TgtID, SrcID, TxnID, and DBID. RN-F sends CompData to ICN. ICN generates a Snoop Response Data Forwarded (SnopRespDataFwded) message to RN-F, which contains TgtID, SrcID, TxnID, and DBID. The diagram shows the flow of identifier fields (TgtID, SrcID, TxnID, FwdTxnID, HomeNID, DBID) across these nodes.](bb908297bfe73e2759a9dd88ae0506f9_img.jpg)

Figure 2-25 ID value transfer in a DCT transaction. The diagram illustrates the flow of transaction messages between Request Node (RN), Interconnect Node (ICN), and Request Node Forwarder (RN-F). The flow starts with RN sending a Read message to ICN. The Read message contains TgtID, SrcID, and TxnID. ICN generates a Snoop Forwarded (SnopFwd) message to RN-F, which contains TgtID, SrcID, TxnID, FwdTxnID, and FwdTxnID. ICN also sends CompData to RN. RN sends CompAck to HN-F. HN-F sends CompData to ICN. ICN generates a Snoop Response Forwarded (SnopRespFwded) message to RN-F, which contains TgtID, SrcID, TxnID, and DBID. RN-F sends CompData to ICN. ICN generates a Snoop Response Data Forwarded (SnopRespDataFwded) message to RN-F, which contains TgtID, SrcID, TxnID, and DBID. The diagram shows the flow of identifier fields (TgtID, SrcID, TxnID, FwdTxnID, HomeNID, DBID) across these nodes.

Figure 2-25 ID value transfer in a DCT transaction

The required steps in the flow that Figure 2-25 shows are:

1. The Requester starts the transaction by sending a Request packet. The identifier fields of the request are generated as follows:
   - The TgtID is determined by the destination of the Request.

   — Note —

   The TgtID field can be remapped to a different value by the interconnect.

   - The SrcID is a fixed value for the Requester.
   - The Requester generates a TxnID field that is unique for that Requester.
2. The recipient Home Node in the interconnect generates a Forwarding snoop to the RN-F node. The identifier fields of the snoop are generated as follows:
   - The SrcID is a fixed value for the Home.
   - The TxnID is a unique value generated by the Home.
   - The FwdTxnID is set to the same value as the SrcID of the original request.
   - The FwdTxnID is set to the same value as the TxnID of the original request.
3. The RN-F provides the read data. The identifier fields of the Read data response are generated as follows:
   - The TgtID is set to the same value as the FwdTxnID of the snoop.
   - The SrcID is a fixed value for the RN-F.
   - The TxnID is set to the same value as the FwdTxnID of the snoop.
   - The HomeNID is set to the same value as the SrcID of the snoop.
   - The DBID is set to the same value as the TxnID of the snoop.

1. The RN-F also provides a response to Home, either with or without read data.  
   The identifier fields of the response are generated as follows:
   - The TgtID is set to the same value as the SrcID of the snoop.
   - The SrcID is a fixed value for the RN-F.
   - The TxnID is set to the same value as the TxnID of the snoop.
   - The DBID field is not valid.
2. The Requester receives the read data and sends a completion acknowledge, CompAck, response.  
   The identifier fields of the CompAck are generated as follows:
   - The TgtID is set to the same value as the HomeNID of the read data.
   - The SrcID is a fixed value for the Requester. This also matches the TgtID that was received.
   - The TxnID is set to the same value as the DBID of the read data.
   - The DBID field is not valid.

###### — Note —

An optional ReadReceipt from the interconnect to Requester can also be included.

#### ID value transfer without Direct Data Transfer

This section gives an example of a Read identifier field flow without DMT or DCT and describes the use of the TxnID and DBID fields for Read transactions.

The Requester and Completer in this example are a Request Node and an HN-F respectively.

The identifier field flow includes an optional ReadReceipt response from the Completer, and an optional CompAck response from the Requester.

For Read transactions that include a CompAck response, the DBID is used by the Completer to associate the CompAck with the original transaction.

A Read transaction that does not include a CompAck response does not require a valid DBID field in the data response.

Figure 2-26 shows the ID value transfer.

![Figure 2-26 shows the ID value transfer in a Read request with ReadReceipt and CompAck. The flow starts with the Requester sending a ReadReq message to the Completer. The ReadReq message contains TgtID, SrcID, and TxnID fields. The Completer sends a ReadReceipt message back to the Requester. The ReadReceipt message contains TgtID, SrcID, TxnID, and DBID fields. The Requester then sends a CompAck message back to the Completer. The CompAck message contains TgtID, SrcID, TxnID, and DBID fields. The DBID field in the CompAck message is used to associate the response with the original transaction.](42f8207e27fec199e23a8854a8e96512_img.jpg)

Figure 2-26 shows the ID value transfer in a Read request with ReadReceipt and CompAck. The flow starts with the Requester sending a ReadReq message to the Completer. The ReadReq message contains TgtID, SrcID, and TxnID fields. The Completer sends a ReadReceipt message back to the Requester. The ReadReceipt message contains TgtID, SrcID, TxnID, and DBID fields. The Requester then sends a CompAck message back to the Completer. The CompAck message contains TgtID, SrcID, TxnID, and DBID fields. The DBID field in the CompAck message is used to associate the response with the original transaction.

Figure 2-26 ID value transfer in a Read request with ReadReceipt and CompAck

The required steps in the flow that Figure 2-26 shows are:

1. The Requester starts the transaction by sending a Request packet.

The identifier fields of the request are generated as follows:

- The TgtID is determined by the destination of the Request.

Note

The TgtID field can be re-mapped to a different value by the interconnect.

- The SrcID is a fixed value for the Requester.
- The Requester generates a TxnID field that is unique for that Requester.

1. If the transaction includes a ReadReceipt, the Completer receives the Request packet and provides the read receipt.

   The identifier fields of the ReadReceipt response are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The DBID field is not valid.
2. The Completer receives the Request packet and provides the read data.

   The identifier fields of the read data response are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The HomeNID is a fixed value for the Completer. This also matches the TgtID received.
   - The Completer generates a unique DBID value if ExpCompAck in the request is asserted.
3. The Requester receives the read data and sends a completion acknowledge, CompAck, response.

   The identifier fields of the CompAck are generated as follows:

   - The TgtID is set to the same value as the HomeNID of the read data.
   - The SrcID is a fixed value for the Requester. This also matches the TgtID that was received.
   - The TxnID is set to the same value as the DBID of the read data.
   - The DBID field is not valid.

### **2.6.2 Dataless transactions**

For Dataless transactions, with the exception of CleanSharedPersistSep and StashOnceSep, the use of identifier fields is similar to *[ID value transfer without Direct Data Transfer](#page-98-0)* on page 2-99. The only difference is that the response from the Completer to the Requester is sent as a single packet on the CRSP channel instead of multiple packets on the RDAT channel.

For StashOnceSep transactions, the StashGroupID value is sent in the request from the Request Node to the interconnect and the value is returned in the StashDone and CompStashDone responses. The TxnID value in the StashDone response is inapplicable and must be set to zero.

The description of ID value transfer in a CleanSharedPersistSep transaction follows.

#### **ID value transfer in a CleanSharedPersistSep transaction**

[Figure 2-27](#page-100-0) shows how the identifier field values are derived in CleanSharedPersistSep transaction messages that use separate Comp and Persist responses. In [Figure 2-27](#page-100-0), PCMOSep represents CleanSharedPersistSep.

![](3d9c6095cbd57a6fd5fe677f428d4a07_img.jpg)

**Figure 2-27 ID value transfer in a CleanSharedPersistSep transaction**

The required steps in the flow that [Figure 2-27](#page-100-0) shows are:

- 1. The Requester starts the transaction by sending a Request packet. The identifier fields of the Request are generated as follows:
  - The TgtID is determined by the destination of the Request.

**Note** The TgtID field can be remapped to a different value by the interconnect.

- The SrcID is a fixed value for the Requester.
- The Requester generates a TxnID value that is unique for that Requester. The TxnID value can be reused by the Requester after receiving the Comp response.
- The Requester generates a new PGroupID value, or reuses a PGroupID value currently in use.

1. The recipient Home Node in the interconnect generates a request to the Subordinate. The identifier fields of the request to the Subordinate Node are generated as follows:

   - The TgtID is set to the value required for the Subordinate.
   - The SrcID is a fixed value for the Home.
   - The TxnID is a unique value generated by the Home.
   - The TxnID value can be reused by the Home after receiving the Comp response.
   - The ReturnNID is set to the same value as the SrcID of the original request.
   - The ReturnTxnID is inapplicable and must be set to zero.
   - The PGroupID is set to the same value as the PGroupID of the original request.
2. The recipient Home Node in the interconnect sends a Comp response to the Requester. The identifier fields of the Comp response to the Requester are generated as follows:

   - The TgtID is set to the same value as the SrcID of the original request.
   - The SrcID is a fixed value for the Home.
   - The TxnID is set to the same value as the TxnID of the original request.
3. The recipient Home Node can optionally send a Persist response to the Requester. The identifier fields of the optional Persist response from the Home Node to the Requester, not shown in Figure 2-27 on page 2-101, are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Home Node.
   - The TxnID is inapplicable and must be set to zero.
   - The PGroupID is set to the same value as the PGroupID of the request.

   The recipient Home Node can optionally send a combined Comp/Persist response to the Requester, instead of separate Comp and Persist responses.

   The identifier fields in the Comp/Persist response are generated as follows:

   - The TgtID is set to the same value as the SrcID of the original request.
   - The SrcID is a fixed value for the Home.
   - The TxnID is set to the same value as the TxnID of the original request.
   - The PGroupID is set to the same value as the PGroupID of the original request.
4. The Subordinate Node generates a Comp to the Home Node. The identifier fields of the Comp response from the Subordinate Node are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Subordinate.
   - The TxnID is set to the same value as the TxnID of the request.
5. The Subordinate Node also generates a Persist response to either to the Requester or the Home. The identifier fields of the Persist response from the Subordinate Node are generated as follows:

   - The TgtID is set to the same value as the ReturnNID of the request.
   - The SrcID is a fixed value for the Subordinate.
   - The TxnID is inapplicable and must be set to zero.
   - The PGroupID is set to the same value as the PGroupID of the request.
6. The Subordinate Node can optionally send a combined Comp/Persist response to the Home Node, instead of separate Comp and Persist responses if the ReturnNID and SrcID of the request are the same value. The identifier fields of the Comp/Persist response from the Subordinate are generated as follows:

   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Subordinate.
   - The TxnID is set to the same value as the TxnID of the request.
   - The PGroupID is set to the same value as the PGroupID of the request.

### 2.6.3 Write transactions

This section describes the use of the TxnID and DBID fields for Write transactions:

- [CopyBack transaction](#)
- [WriteNoSnp transaction on page 2-105](#)
- [WriteUnique transaction on page 2-107](#)
- [StashOnce or StashOnceSep transaction on page 2-109](#)

#### CopyBack transaction

This section describes the use of the identifier fields for a CopyBack transaction.

Figure 2-28 shows the identifier value transfer.

![Figure 2-28 ID value transfer in a CopyBack transaction flow diagram. The flow starts with a Requester sending a CopyBack request (TxnID, SrcID, TgtID) to the Completer. The Completer sends a CompDBIDResp response (TxnID, SrcID, TgtID, DBID) back to the Requester. The Requester then sends a WriteData request (TxnID, SrcID, TgtID, DBID) to the Completer. The Completer sends a response (TxnID, SrcID, TgtID, DBID) back to the Requester. The diagram illustrates the transfer of TxnID, SrcID, TgtID, and DBID fields between the Requester and Completer.](fe2b982e7b73e8c8d5ba45509c306882_img.jpg)

Figure 2-28 ID value transfer in a CopyBack transaction flow diagram. The flow starts with a Requester sending a CopyBack request (TxnID, SrcID, TgtID) to the Completer. The Completer sends a CompDBIDResp response (TxnID, SrcID, TgtID, DBID) back to the Requester. The Requester then sends a WriteData request (TxnID, SrcID, TgtID, DBID) to the Completer. The Completer sends a response (TxnID, SrcID, TgtID, DBID) back to the Requester. The diagram illustrates the transfer of TxnID, SrcID, TgtID, and DBID fields between the Requester and Completer.

Figure 2-28 ID value transfer in a CopyBack

The required steps in the flow that Figure 2-28 shows are:

1. The Requester starts the transaction by sending a Request packet. The identifier fields of the request are generated as follows:
   - The TgtID is determined by the destination of the Request.

   **Note**

   The TgtID field can be remapped to a different value by the interconnect.

   - The SrcID is a fixed value for the Requester.
   - The Requester generates a unique TxnID field.
2. The Completer receives the Request packet and generates a CompDBIDResp response. The identifier fields of the response are generated as follows:
   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The Completer generates a unique DBID value.

1. The Requester receives the CompDBIDResp response and sends the write data. The identifier fields of the write data are generated as follows:
   - The TgtID is set to the same value as the SrcID of the CompDBIDResp response. This can be different from the original TgtID of the request if the value was remapped by the interconnect.
   - The SrcID is a fixed value for the Requester.
   - The TxnID is set to the same value as the DBID value provided in the CompDBIDResp response.
   - The DBID field in the write data is not used.
   - The TgtID, SrcID, and TxnID fields must be the same for all write data packets.

   After receiving the CompDBIDResp response, the Requester can reuse the same TxnID value used in the request packet for another transaction.
2. The Completer receives the write data and uses the TxnID field, which now contains the DBID value that the Completer generated. This helps to determine which transaction to associate the write data.

After receiving all write data packets, the Completer can reuse the same DBID value for another transaction.

#### WriteNoSnp transaction

This section describes the use of the identifier fields for a WriteNoSnp transaction.

Figure 2-29 does not show the Memory Tagging supported TagGroupID flow. For TagGroupID transfer details see *Write transactions on page 12-378 in Chapter 12 Memory Tagging*.

Figure 2-29 shows the identifier value transfer for separate Comp and DBIDResp. The Completer can opportunistically combine the Comp and DBIDResp into a single CompDBIDResp response. The Requester can opportunistically combine NCBWrData with CompAck.

![Figure 2-29 ID value transfer in a WriteNoSnp transaction flow diagram. The flow shows a Requester initiating a WriteNoSnp transaction, followed by a sequence of responses from the Completer. The flow includes WriteNoSnp, DBIDResp, NCBWrData, Comp, CompAck, and NCBWrDataCompAck. The diagram illustrates how identifier fields (TgtID, SrcID, TxnID, DBID) are reused or transferred between transactions, with some steps marked as Optional.](a2266c471758a61aa9eeab6aab8696b4_img.jpg)

Figure 2-29 ID value transfer in a WriteNoSnp transaction flow diagram. The flow shows a Requester initiating a WriteNoSnp transaction, followed by a sequence of responses from the Completer. The flow includes WriteNoSnp, DBIDResp, NCBWrData, Comp, CompAck, and NCBWrDataCompAck. The diagram illustrates how identifier fields (TgtID, SrcID, TxnID, DBID) are reused or transferred between transactions, with some steps marked as Optional.

Figure 2-29 ID value transfer in a WriteNoSnp

The uses of the identifier fields are the same as for a transaction with a combined response with the additional requirements that:

- The identifier fields used for the separate DBIDResp and Comp responses must be identical.
- The TxnID value must only be reused by a Requester when both the DBIDResp and Comp responses have been received.

The required steps in the flow that Figure 2-29 on page 2-105 shows are:

1. The Requester starts the transaction by sending a Request packet. The identifier fields of the request are generated as follows:
   - The TgtID is determined by the destination of the Request.

     — Note —

     The TgtID field can be remapped to a different value by the interconnect.
   - The SrcID is a fixed value for the Requester.
   - The Requester generates a unique TxnID field.
2. The Completer receives the Request packet and generates a DBIDResp response. The identifier fields of the response are generated as follows:
   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The Completer generates a unique DBID value.
3. The Requester receives the DBIDResp response and sends the write data. The identifier fields of the write data are generated as follows:
   - The TgtID is set to the same value as the SrcID of the DBIDResp response. This can be different from the original TgtID of the request if the value was remapped by the interconnect.
   - The SrcID is a fixed value for the Requester.
   - The TxnID is set to the same value as the DBID value provided in the DBIDResp response.
   - The DBID field in the write data is not used.
   - The TgtID, SrcID, and TxnID fields must be the same for all write data packets.
4. The Completer receives the write data and uses the TxnID field, which now contains the DBID value that the Completer generated, to determine which transaction the write data is associated with.
5. The Completer generates a Comp response when it has completed the transaction. The identifier fields of the Comp response must be the same as the DBIDResp response and are generated as follows:
   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The Completer uses the same DBID value as is used in the DBIDResp response.
6. The Requester sends a CompAck message, if the transaction requires it, after receiving DBIDResp or Comp. The identifier fields of the CompAck are generated as follows:
   - The TgtID is set to the same value as the SrcID of the DBIDResp or Comp response.
   - The SrcID is a fixed value for the Requester. This also matches the TgtID that was received.
   - The TxnID is set to the same value as the DBID of the DBIDResp or Comp response.
   - The DBID field is not valid.

After receiving both the Comp and DBIDResp response, the Requester can reuse the same TxnID value for another transaction.

After receiving all the write data packets, the Completer can reuse the same DBID value for another transaction.

— Note —

There is no ordering requirement between the separate DBIDResp and Comp responses. It is required that the values used are identical.

#### WriteUnique transaction

This section describes the use of the identifier fields for a WriteUnique transaction.

Figure 2-30 does not show the Memory Tagging supported TagGroupID flow. For TagGroupID transfer details see *Write transactions on page 12-378 in Chapter 12 Memory Tagging*.

Under certain circumstances, the WriteUnique transaction can also include a CompAck response from the Requester to the Completer. In this case, the additional rules for the use of the identifier fields are:

- The TgtID, SrcID, and TxnID identifier fields of the CompAck response from the Requester to the Completer must be the same as the fields used for the write data, that is:
  - The TgtID is set to the same value as the SrcID of the CompDBIDResp response. If separate Comp and DBIDResp responses are given, the TgtID is set to the same value as the SrcID of either the Comp or DBIDResp response because the SrcID value in both must be identical. However, this can be different from the original TgtID of the request if the value has been remapped by the interconnect.
  - The SrcID is a fixed value for the Requester.
  - The TxnID is set to the same value as the DBID value provided in the CompDBIDResp response. If separate Comp and DBIDResp responses are given, the TxnID is set to the same value as the DBID of either the Comp or DBIDResp response because the DBID value in both must be identical.
  - The DBID field in the WriteData and in the CompAck is not used.
  - If a combined WriteData and CompAck response is sent, then the TgtID is set to the same value as the SrcID in the Comp, DBIDResp, or CompDBIDResp, and the TxnID in the combined response is set to the same value as the DBID in Comp, DBIDResp, or CompDBIDResp.
- The Completer must receive all items of write data and the CompAck response before reusing the same DBID value for another transaction.

Figure 2-30 shows the identifier value transfer with a combined CompDBIDResp response.

![Figure 2-30 ID value transfer with a combined CompDBIDResp response. The diagram illustrates the flow of transaction identifiers (TgtID, SrcID, TxnID, DBID) between a Requester and a Completer across four transactions: WriteUnique, CompDBIDResp, WriteData, and CompAck. The Requester starts with TgtID (R) and TxnID. WriteUnique sends TgtID (R) and TxnID to the Completer. The Completer sends TgtID, SrcID, and TxnID back to the Requester. CompDBIDResp sends TgtID, SrcID, TxnID, and DBID back to the Requester. WriteData sends TgtID, TxnID, and DBID to the Completer. CompAck sends TgtID, SrcID, TxnID, and DBID back to the Requester.](a7e667227af01b0bd7f81d42ebae5c07_img.jpg)

Figure 2-30 ID value transfer with a combined CompDBIDResp response. The diagram illustrates the flow of transaction identifiers (TgtID, SrcID, TxnID, DBID) between a Requester and a Completer across four transactions: WriteUnique, CompDBIDResp, WriteData, and CompAck. The Requester starts with TgtID (R) and TxnID. WriteUnique sends TgtID (R) and TxnID to the Completer. The Completer sends TgtID, SrcID, and TxnID back to the Requester. CompDBIDResp sends TgtID, SrcID, TxnID, and DBID back to the Requester. WriteData sends TgtID, TxnID, and DBID to the Completer. CompAck sends TgtID, SrcID, TxnID, and DBID back to the Requester.

Figure 2-30 ID value transfer with a combined CompDBIDResp response

Figure 2-31 on page 2-108 shows the identifier value transfer with a combined WriteData and CompAck response.

![](fc7ea02351e757da3b2a8d1a49565e31_img.jpg)

Diagram illustrating ID value transfer between a Requester and a Completer, involving a combined WriteData and CompAck response.

**Requester (Initial State):** Contains TgtID (R), SrcID, and TxnID.

**Completer (Initial State):** Contains TgtID, SrcID, and TxnID.

The Requester sends a message to the Completer via the **WriteUnique** operation.

The Completer sends a message back to the Requester via the **CompDBIDResp** operation.

The Requester sends a message to the Completer via the **NCBWrDataCompAck** operation.

**Alternative combined WriteData and CompAck response:** The Requester sends a message to the Completer via the **NCBWrDataCompAck** operation.

**Requester (Final State):** Contains TgtID, SrcID, TxnID, and DBID.

**Completer (Final State):** Contains TgtID, SrcID, TxnID, and DBID.

Figure 2-31 ID value transfer with a combined WriteData and CompAck response

#### StashOnce or StashOnceSep transaction

This section describes the use of the identifier fields for a StashOnce or StashOnceSep transaction with DataPull.

Figure 2-32 shows the identifier value transfer.

![Figure 2-32 ID value transfer in a Stash transaction. The diagram illustrates the flow of transaction identifiers (TgtID, SrcID, TxnID, TxnNID, StashLPID, DBID, HomeNID) between the Requester (RN), Interconnect (ICN), and Response (RN-F) sides. The RN side shows the initial request packet (R) containing TgtID, SrcID, TxnID, StashNID, StashLPID, and StashGroupID. This packet is processed by StashOnce or StashOnceSep, leading to Comp, StashDone, or Comp and StashDone. The ICN side shows the request packet being processed, leading to various responses (Snp['Stash', SnpResp_I_Read, CompData, CompAck]). The RN-F side shows the response packet, which includes TgtID, SrcID, TxnID, StashLPID, and DBID. The diagram also indicates that the RN-F NID is the same as the StashNID.](23a46c14c46e8aadbc6d6e9ce82da227_img.jpg)

Figure 2-32 ID value transfer in a Stash transaction. The diagram illustrates the flow of transaction identifiers (TgtID, SrcID, TxnID, TxnNID, StashLPID, DBID, HomeNID) between the Requester (RN), Interconnect (ICN), and Response (RN-F) sides. The RN side shows the initial request packet (R) containing TgtID, SrcID, TxnID, StashNID, StashLPID, and StashGroupID. This packet is processed by StashOnce or StashOnceSep, leading to Comp, StashDone, or Comp and StashDone. The ICN side shows the request packet being processed, leading to various responses (Snp['Stash', SnpResp\_I\_Read, CompData, CompAck]). The RN-F side shows the response packet, which includes TgtID, SrcID, TxnID, StashLPID, and DBID. The diagram also indicates that the RN-F NID is the same as the StashNID.

Figure 2-32 ID value transfer in a Stash transaction

The required steps in the flow that Figure 2-32 shows are:

1. The Requester starts the transaction by sending a Stash request packet.

The identifier fields of the request are generated as follows:

- The TgtID is determined by the destination of the Request.

###### **Note**

The TgtID field can be remapped to a different value by the interconnect.

- The SrcID is a fixed value for the Requester.
- The Requester generates a TxnID field that is unique for that Requester.
- The Requester includes the StashNID field to indicate to which RN-F to send the Stash.
- The Requester includes the StashLPID field to indicate the logical processor within the RN-F.

2. The Home Node in the interconnect receives the Stash request packet and sends the Comp response to the Request Node.

The identifier fields of the Comp response are generated as follows:

- The TgtID is set to the same value as the SrcID of the request.
- The TxnID is set to the same value as the TxnID of the request.

3. The Home Node in the interconnect, for the StashOnceSep request, sends the StashDone response to the Request Node.

The identifier fields of the StashDone response are generated as follows:

- The TgtID is set to the same value as the SrcID of the request.
- The TxnID is not valid.
- StashGroupID is set to the same value as the StashGroupID of the request.

Alternatively for the StashOnceSep request, the Home Node in the interconnect sends the combined CompStashDone response instead of separate Comp and StashDone responses to the Request Node.

The identifier fields of the CompStashDone response are generated as follows:

- The TgtID is set to the same value as the SrcID of the request.
- The TxnID is set to the same value as the TxnID of the request.
- The StashGroupID is set to the same value as the StashGroupID of the request.

4. The Home Node in the interconnect generates a snoop with Stash to the appropriate RN-F.

The identifier fields of the request are generated as follows:

- The SrcID is a fixed value for the Home.
- The TxnID is a unique value generated by the Home.
- The StashLPID is set to the same value as the StashLPID of the original request.

— Note —  
A Snoop request does not include a TgtID field.

5. The snooped RN-F generates a Snoop response. In this example, it includes a Data Pull indication.

The identifier fields of the Snoop response are generated as follows:

- The TgtID is set to the same value as the SrcID of the request.
- The SrcID is a fixed value for the RN-F.
- The TxnID is set to the same value as the TxnID of the request.
- The DBID field is a unique value generated by the RN-F.

6. The Home provides the read data.

The identifier fields of the read Data response are generated as follows:

- The TgtID is set to the same value as the SrcID of the Snoop response.
- The SrcID is a fixed value for the Home.

— Note —  
In this example, the read data is being provided by the Home.

- The TxnID is set to the same value as the DBID of the Snoop response.
- The DBID field is a unique value generated by Home.
- The HomeNID is a fixed value for the Home.

7. The RN-F receives the read data and sends a completion acknowledge, CompAck, response.

The identifier fields of the CompAck are generated as follows:

- The TgtID is set to the same value as the HomeNID of the read data.
- The SrcID is a fixed value for the RN-F. This also matches the TgtID received.
- The TxnID is set to the same value as the DBID of the read data.
- The DBID field is not valid.

### 2.6.4 DVMOp transaction

The use of the TgtID, SrcID, TxnID, and DBID identifier fields for a DVMOp transaction is identical to that for the *WriteNoSnp transaction*.

### 2.6.5 Transaction requests with Retry

For transactions that receive a RetryAck response, there are specific rules on how the identifier fields are used. See *Request Retry* on page 2-145, for more details on the Retry mechanism, and *Protocol Credit Return transaction*, for rules about the return of unused credits.

Figure 2-33 shows the identifier value transfer.

![Figure 2-33 ID value transfer in a transaction request with retry. The diagram shows the flow between a Requester and a Completer, illustrating the transfer of TgtID, SrcID, TxnID, and DBID fields across Request, RetryAck, PCrdGrant, and Request with Credit messages. The Requester starts with TgtID (R), SrcID, and TxnID. The Completer starts with TgtID, SrcID, and TxnID. The Request message carries TgtID (R), SrcID, TxnID, and DBID. The RetryAck message carries TgtID, SrcID, TxnID, and DBID. The PCrdGrant message carries TgtID, SrcID, TxnID, and DBID. The Request with Credit message carries TgtID (R), SrcID, TxnID, and PCrdType. The Requester's initial state is shown with TgtID (R), SrcID, and TxnID. The Completer's initial state is shown with TgtID, SrcID, and TxnID.](87b13bef7934ac2dabb5969cf7c9def6_img.jpg)

Figure 2-33 ID value transfer in a transaction request with retry. The diagram shows the flow between a Requester and a Completer, illustrating the transfer of TgtID, SrcID, TxnID, and DBID fields across Request, RetryAck, PCrdGrant, and Request with Credit messages. The Requester starts with TgtID (R), SrcID, and TxnID. The Completer starts with TgtID, SrcID, and TxnID. The Request message carries TgtID (R), SrcID, TxnID, and DBID. The RetryAck message carries TgtID, SrcID, TxnID, and DBID. The PCrdGrant message carries TgtID, SrcID, TxnID, and DBID. The Request with Credit message carries TgtID (R), SrcID, TxnID, and PCrdType. The Requester's initial state is shown with TgtID (R), SrcID, and TxnID. The Completer's initial state is shown with TgtID, SrcID, and TxnID.

Figure 2-33 ID value transfer in a transaction request with retry

The required steps in the flow that Figure 2-33 shows are:

1. The Requester starts the transaction by sending a Request packet. The identifier fields of the request are generated as follows:

- The TgtID is determined by the destination of the Request.

Note

The TgtID field can be remapped to a different value by the interconnect.

- The SrcID is a fixed value for the Requester.
- The Requester generates a unique TxnID field.

1. The Completer receives the Request packet and determines that it is going to send a RetryAck response. The identifier fields of the RetryAck response are generated as follows:
   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID received.
   - The TxnID is set to the same value as the TxnID of the request.
   - The DBID field is not valid.
   - The Completer uses a PCrdType value that indicates the type of credit required to retry the transaction.
2. When the Completer is able to accept the retried transaction of a given PCrdType it sends a credit to the Requester, using the PCrdGrant response. The identifier fields of the PCrdGrant response are generated as follows:
   - The TgtID is set to the same value as the SrcID of the request.
   - The SrcID is a fixed value for the Completer. This also matches the TgtID of the request.
   - The TxnID field is not used and must be set to zero.
   - The DBID field is not used and must be set to zero.
   - The PCrdType value is set to the type required to issue the original transaction again.
3. The Requester receives the credit grant and reissues the original transaction by sending a Request packet. The identifier fields of the request are generated as follows:
   - The TgtID is set to either the same value as the SrcID of the RetryAck response, which is also the same as the SrcID of the PCrdGrant response, or the value used in the original request.
   - The SrcID is a fixed value for the Requester.
   - The Requester generates a unique TxnID field. This is permitted to be different from the original request that received a RetryAck response.
   - The PCrdType value is set to the PCrdType value in the RetryAck response to the original request, which is also the same as the PCrdType of the PCrdGrant response.

### 2.6.6 Protocol Credit Return transaction

A P-Credit Return transaction uses the PCrdReturn Request to return a granted, but no longer required, credit. The TgtID, SrcID, and TxnID requirements are:

- The Requester sends the Protocol Credit Return transaction by sending a PCrdReturn Request packet. The identifier fields of the request are generated as follows:
  - The TgtID must match the SrcID of the credit that was obtained.
  - The SrcID is a fixed value for the Requester.
  - The TxnID field is not used and must be set to zero.

The PCrdType must match the value of the PCrdType in the original PCrdGrant that was required to issue the original transaction again.

There is no response or use made of the DBID field associated with Protocol Credit Return transactions.

## 2.7 Logical Processor Identifier

This specification defines a *Logical Processor Identifier* (LPID) field within a transaction request. This field is used when a single Requester contains more than one logically separate processing agent.

The LPID must be set to the correct value for the following transactions:

- For any Non-snoopable Non-cacheable or Device access:
  - ReadNoSnp
  - WriteNoSnp
- For Exclusive accesses, that can be one of the following transaction types:
  - ReadClean
  - ReadShared
  - ReadNotSharedDirty
  - ReadPreferUnique
  - MakeReadUnique
  - CleanUnique
  - ReadNoSnp
  - WriteNoSnp

See [Chapter 6 Exclusive accesses](#) for further details.

For other transactions, the LPID value is permitted but not required to indicate the original logical processor that caused a transaction to be issued.

## 2.8 Ordering

This section describes the mechanisms that the protocol includes to support system ordering requirements. It contains the following subsections:

- *Multi-copy atomicity*
- *Completion response and ordering*
- *Completion acknowledgment on page 2-116*
- *Transaction ordering on page 2-118*

For the meaning of the terms EWA, Device, and Cacheable see *Memory Attributes on page 2-126*.

### 2.8.1 Multi-copy atomicity

The memory model used in this specification requires multi-copy atomicity. All compliant components must ensure that all write-type requests are multi-copy atomic. A write is defined as multi-copy atomic if both of the following conditions are true:

- All writes to the same location are serialized, that is, they are observed in the same order by all Requesters, although some Requesters might not observe all of the writes.
- A read of a location does not return the value of a write until all Requesters observe that write.

In this specification, two addresses are considered to be the same with respect to coherence, observability, and hazard if their cache line addresses and NS attribute are the same.

### 2.8.2 Completion response and ordering

Table 2-7 shows the Comp, RespSepData, CompData, or Persist response, which guarantees the ordering of a transaction with respect to later transactions, either from the same agent or from another agent.

Table 2-7 Completion response and ordering

| Transaction                            | Location                | Response                | Outcome                                                                                                                                                                                  |
|----------------------------------------|-------------------------|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Read                                   | Cacheable               | CompData or DataSepResp | The transaction is observable to a later transaction from any agent to the same location.                                                                                                |
|                                        | Cacheable               | RespSepData             | No earlier transaction will send a snoop to this Requester. All later transactions will send a snoop only if required after the Home receives the CompAck response for this transaction. |
|                                        | Non-cacheable or Device | RespSepData or CompData | The transaction is observable to a later transaction from any agent to the same endpoint address range.                                                                                  |
| Write or Atomic                        | Cacheable               | Comp or CompData        | The transaction is observable to a later transaction from any agent to the same location.                                                                                                |
|                                        | Non-cacheable or Device | Comp or CompData        | The transaction is observable to a later transaction from any agent to the same endpoint range.                                                                                          |
| Dataless<br>Except for<br>StashOnceSep |                         | Comp                    | The transaction is observable to a later transaction from any agent to the same memory location.                                                                                         |
| CleanSharedPersist                     |                         | Comp                    | Any data written earlier to the same memory location is made persistent.                                                                                                                 |

Table 2-7 Completion response and ordering (continued)

| Transaction                        | Location | Response  | Outcome                                                                                                                    |
|------------------------------------|----------|-----------|----------------------------------------------------------------------------------------------------------------------------|
| Combined Write                     |          | CompCMO   | CMO, PCMO, and write operations are observable to a later transaction from any agent to the same memory location.          |
|                                    |          | Comp      | The write operation is observable to a later transaction from any agent to the same endpoint address range.                |
| CleanSharedPersistSep              |          | Persist   | The data written earlier to the same memory location is made persistent.                                                   |
| Combined Write with Persistent CMO |          | Persist   | The data write in the Combined Write is made persistent. All earlier writes on the same line will also be made persistent. |
|                                    |          | Comp      | The Completer accepts the request and will not send a RetryAck response.                                                   |
| StashOnceSep                       |          | StashDone | The transaction is observable to a later transaction from any agent to the same memory location.                           |
|                                    |          | Comp      | The Completer accepts the request and will not send a RetryAck response.                                                   |

###### **Note**

The size of the endpoint address range is IMPLEMENTATION DEFINED.

In a combined *Ordered Write Observation* (OWO) Write request, if the write is canceled, that is, the Requester sends a WriteDataCancel, then the required cache maintenance on the write data is not carried out. The Requester must resend both the Write request and the CMO:

- If the combined request that had its write canceled is a Write with PCMO then:
  - The Persist response for the combined request does not indicate that the write data is made persistent.
  - The Requester must resend the PCMO either combined with the resent Write request or after the resent Write request succeeds.
- If the combined request that had its write canceled is a Write with CMO then:
  - The Requester must resend the CMO, either combined with the re-sent Write request or after the resent Write request succeeds.

###### **Note**

- The size of an endpoint address range is IMPLEMENTATION DEFINED. Typically, this is:
  - The size of a peripheral device, for a region used for peripherals.
  - The size of a cache line, for a region used for memory.
- A Cacheable location can be determined by the assertion of the MemAttr[2] Cacheable bit in the request. A Non-cacheable or Device location can be determined by the deassertion of the MemAttr[2] Cacheable bit in the request.

A component must only give a Comp or CompDBIDResp response when it is guaranteed that all observers will see the result of the atomic operation.

A Comp response in a canceled write only implies that the transaction loop is completed and makes no statement regarding the completion of coherency action initiated by the write. Therefore, the Completer is permitted to send a Comp as soon as it receives a WriteDataCancel response without dependency on either the processing of the write request or the completion of any snoops sent due to the write.

### 2.8.3 Completion acknowledgment

The relative ordering of transactions issued by a Requester, and Snoop transactions caused by transactions from different Requesters, is controlled by the use of a completion acknowledge, CompAck, response. This ensures that a Snoop transaction that is ordered after the transaction from the Requester is guaranteed to be received after the transaction response.

The sequencing of the completion of a Read transaction and the sending of CompAck is as follows:

1. An RN-F sends a CompAck after receiving Comp, RespSepData, or CompData, or both RespSepData and DataSepResp.
2. An HN-F, except in the case of ReadOnce\*, waits for CompAck before sending a subsequent snoop to the same address. For CopyBack transactions, WriteData acts as an implicit CompAck and an HN-F must wait for WriteData before sending a snoop to the same address.

This sequence guarantees that an RN-F receives completion for a transaction and a snoop to the same cache line in the same order as they are sent from an HN-F. This ensures transactions to the same cache line are observed in the correct order.

When an RN-F has a transaction in progress that uses CompAck, except for ReadNoSnp and ReadOnce\*, then it is guaranteed not to receive a Snoop request to the same address between the point that it receives Comp and the point that it sends CompAck.

For WriteNoSnp and WriteUnique transactions that require a CompAck message, a Request Node sends the CompAck after receiving the Comp, DBIDResp, or CompDBIDResp response.

The use of CompAck for a transaction is determined by the Request setting the ExpCompAck field in the original request. The rules for a Request Node setting the ExpCompAck field and generating a CompAck response are as follows:

- An RN-F must include a CompAck response in all Read transactions except ReadNoSnp and ReadOnce\*.
- Although not required, an RN-F is permitted to include a CompAck response in ReadNoSnp and ReadOnce\* transactions.
- An RN-F must not include a CompAck response in StashOnce\*, CMO, Atomic, or Evict transactions.
- An RN-I or RN-D is permitted, but not required, to include a CompAck response in Read transactions.
- An RN-I or RN-D must not include a CompAck response in Dataless or Atomic transactions.
- A Request Node that wants to make use of DMT must include a CompAck response in ordered ReadNoSnp and ReadOnce\* transactions.
- For Write transactions, CompAck can only be used for WriteUnique and WriteNoSnp transactions when they require Ordered Write Observation guarantees. See *Streaming Ordered Write transactions* on page 2-122.
- For WriteEvictOrEvict, ExpCompAck must be set to one indicating the transaction will include a CompAck when the Completer sends a Comp instead of a CompDBIDResp.

For transactions between a Request Node and a Home Node, where the Home Node is the Completer, the Home Node must support the use of CompAck for all transactions that are required or permitted to use CompAck.

A Subordinate Node is not required to support the use of CompAck.

A Requester, such as an HN-F or HN-I that communicates with an SN-F or SN-I respectively, must not send a CompAck response.

Table 2-8 shows the Request types that require a CompAck response, and the corresponding Requester types that are required to provide that response. The following key is used:

| Y | Yes, permitted    |
|---|-------------------|
| N | No, not permitted |
| O | Optional          |
| - | Not applicable    |

Table 2-8 Requester CompAck requirement

| Request type        | CompAck Required |            |
|---------------------|------------------|------------|
|                     | RN-F             | RN-D, RN-I |
| ReadNoSnp           | O                | O          |
| ReadOnce*           | O                | O          |
| ReadClean           | Y                | -          |
| ReadNotSharedDirty  | Y                | -          |
| ReadShared          | Y                | -          |
| ReadUnique          | Y                | -          |
| ReadPreferUnique    | Y                | -          |
| MakeReadUnique      | Y                | -          |
| CleanUnique         | Y                | -          |
| MakeUnique          | Y                | -          |
| CleanShared         | N                | N          |
| CleanSharedPersist* | N                | N          |
| CleanInvalid        | N                | N          |
| MakeInvalid         | N                | N          |
| WriteBack           | N                | -          |
| WriteClean          | N                | -          |
| WriteUnique         | O                | O          |
| WriteUniqueZero     | N                | N          |
| Evict               | N                | -          |
| WriteEvictFull      | N                | -          |
| WriteEvictOrEvict   | Y                | -          |
| WriteNoSnp          | O                | O          |
| WriteNoSnpZero      | N                | N          |
| Atomics             | N                | N          |
| StashOnce*          | N                | N          |

In a Combined Write transaction, the CompAck requirement is the same as the CompAck requirement for the type of Write in the Combined Write transaction.

### 2.8.4 Ordering semantics of RespSepData and DataSepResp

When a Requester receives the first DataSepResp, it can consider the Read transaction to be globally observed, because there is no action which can modify the read data received.

When a Requester receives a RespSepData response from Home, the request that it applies to has been ordered at Home and the Requester will not receive any snoops for transactions that are scheduled before it. The Home, before sending RespSepData response to the Requester, must ensure that no Snoop transactions are outstanding to that Requester to the same address. Receiving of RespSepData does not guarantee that Home has completed snooping of other agents in the system.

When the Requester gives a completion acknowledge, CompAck, response, this Requester is indicating that it will accept responsibility to hazard snoops for any transaction that is scheduled after it. The following rules apply:

- For all transactions, except as described immediately below, the CompAck must be sent after the RespSepData response is received. It is permitted, but not required, to wait for the DataSepResp response before the CompAck is given.
- For ReadOnce and ReadNoSnp transactions with an ordering requirement, that is, Order field is set to 0b10 or 0b11 and ExpCompAck field is asserted, it is required that the CompAck is given only after both DataSepResp and RespSepData responses are received.
- The Requester must wait to receive both RespSepData and DataSepResp before issuing another request to the same address.

###### — Note —

It is required that CompAck must not be given when only DataSepResp is received.

### 2.8.5 Transaction ordering

In addition to using a Comp response to order a sequence of requests from a Requester, this specification also defines mechanisms for ordering of requests between an RN, HN pair and an HN-I, SN-I pair. Between an HN-F, SN-F pair and HN-I, SN-I pair, the order field is used to obtain a Request Accepted acknowledgment.

Requester Order between an RN, HN pair and an HN-I, SN-I pair is supported by the Order field in a request. The Order field indicates that the transaction requires one of the following forms of ordering:

#### **Request Order**

This guarantees the order of multiple transactions, from the same agent, to the same address location.

#### **Endpoint Order**

This guarantees the order of multiple transactions, from the same agent, to the same endpoint address range.

#### **Ordered Write Observation, OWO**

This guarantees the observation order by other agents in the system, for a sequence of Write transactions from a single agent.

#### **Request Accepted**

This guarantees that the Completer will send a positive acknowledgment only when it has accepted the Read request.

Table 2-9 shows the Order field encodings.

Table 2-9 Order value encodings

| Order[1:0] | Description                             | Permitted between             |
|------------|-----------------------------------------|-------------------------------|
| 0b00       | No ordering required                    | All                           |
| 0b01       | Request accepted                        | HN-F to SN-F and HN-I to SN-I |
|            | Reserved                                | RN to HN                      |
| 0b10       | Request Order/Ordered Write Observation | RN to HN <sup>a</sup>         |
|            | Request Order                           | HN-I to SN-I                  |
|            | Reserved                                | HN-F to SN-F                  |
| 0b11       | Endpoint Order                          | RN to HN and HN-I to SN-I     |
|            | Reserved                                | HN-F to SN-F                  |

a. Request Order when ExpCompAck = 0.

Ordered Write Observation when ExpCompAck = 1.

#### Ordering requirements

A Requester that changes the ordering requirements of a transaction to a stronger ordering requirement, is required to be consistent in changing the ordering requirement of Request Order to Endpoint Order on all its transactions.

The Order field must only be set to a non-zero value for the following transactions:

- ReadNoSnp
- ReadNoSnpSep
- ReadOnce<sup>a</sup>
- WriteNoSnp
- WriteNoSnp+CMO
- WriteNoSnpZero
- WriteUnique
- WriteUnique+CMO
- WriteUniqueZero
- Atomic

When a ReadNoSnp or ReadOnce<sup>a</sup> transaction requires Request Order or Endpoint Order:

- The Requester requires a ReadReceipt to determine when it can send the next ordered request.
- At the Completer a ReadReceipt means the request has reached the next ordering point that will maintain requests in the order they were received:
  - For requests that require Request Order, it will maintain order between requests to the same address from the same source.
  - For requests that require Endpoint Order, it will maintain order between requests to the same endpoint address range from the same source.
- A Completer that is capable of sending separate Non-data and Data-only responses can send RespSepData response instead of ReadReceipt and achieve the same functional behavior.

When a WriteNoSnp, WriteNoSnpZero or a Non-snoopable Atomic transaction requires Request Order or Endpoint Order:

- The Requester requires a DBIDResp or DBIDRespOrd to determine when it can send the next ordered request.

- The Completer sending a DBIDResp or DBIDRespOrd response means that a data buffer is available, and that the Write request has reached a PoS that will maintain requests in the order they were received:
  - For requests that require Request Order, it will maintain order between requests to the same address from the same source.
  - For requests that require Endpoint Order, it will maintain order between requests to the same endpoint address range from the same source.

When a WriteUnique transaction without ExpCompAck asserted, or a WriteUniqueZero or a Snoopable Atomic transaction require Request Order:

- The Requester requires a DBIDResp or DBIDRespOrd to determine when it can send the next ordered request.
- The Completer sending a DBIDResp or DBIDRespOrd response means that it will maintain order between requests to the same address from the same source.

Additionally, when a Completer sends DBIDRespOrd for a request with a no order or Request Order requirement, the Completer guarantees to order all subsequent no order or Request Order received requests to the same address from the same source against this request, where these later received requests are of any transaction type, not necessarily Write transactions. When the write includes a CMO, the order is guaranteed against both the write and the CMO.

When a WriteUnique or WriteNoSnp transaction requires Ordered Write Observation:

- CompAck is required. The Request Node must assert ExpCompAck.
- The Request Node requires a DBIDResp or DBIDRespOrd.
- The Completer is a PoS. A PoS sending DBIDResp or DBIDRespOrd means:
  - A data buffer is available.
  - The PoS guarantees that the completion of the coherence action on this write does not depend on completion of the coherence action on a subsequent write that requires Ordered Write Observation.
  - The write is not made visible until CompAck is received.

All architectural mechanisms applicable to increasing streaming efficiency and corresponding constraints are defined in *Streaming Ordered Write transactions* on page 2-122.

When a ReadNoSnp or ReadNoSnpSep has the Order field set to 0b01, a ReadReceipt response from the Completer guarantees that the Completer has accepted the request and will not send a RetryAck response.

#### Read Request Order example

Figure 2-34 shows the request ordering of three Read requests.

![](9600eb9b09749d5b8a30898a75407ac8_img.jpg)

Sequence Diagram (Figure 2-34) illustrating the request ordering of three Read requests between the Request Node (RN) and the Home Node (HN).

The sequence shows the following steps:

1. RN sends ReadNoSnp-1 to HN. HN responds with Request accepted.
2. RN sends ReadReceipt-1 to HN.
3. RN sends ReadNoSnp-2 to HN. HN responds with Request gets a Retry response.
4. RN sends RetryAck-2 to HN.
5. RN sends PCrdGrant to HN.
6. RN sends ReadNoSnp-2 to HN.
7. RN sends ReadReceipt-2 to HN.
8. RN sends ReadNoSnp-3 to HN.
9. RN sends ReadReceipt-3 to HN.

Annotations:

- ReadNoSnp-2 is sent after ReadReceipt-1 is received.
- ReadNoSnp-2 waits for a CreditGrant.
- ReadNoSnp-3 continues waiting for ReadNoSnp-2 to make progress.
- ReadNoSnp-3 is sent after Read Receipt-2 is received.

Figure 2-34 Series of ordered Read requests

Three ordered requests are sent from Request Node to Home Node as follows:

1. The Request Node sends the ReadNoSnp-1 request to the Home Node.
2. The Home Node accepts the request and returns the ReadReceipt-1 response to the Request Node.
3. After the ReadReceipt-1 response is received, the Request Node sends the ReadNoSnp-2 request to the Home Node.
4. The Home Node cannot immediately accept the ReadNoSnp-2 request and returns the RetryAck-2 response to the Request Node.
5. The Request Node must now wait for a PCrdGrant to be sent from the Home Node before resending the ReadNoSnp-2 request. The Request Node does not send ReadNoSnp-3 at this point, as it wants to order ReadNoSnp-3 behind ReadNoSnp-2. This ordering requires that ReadNoSnp-2 must be accepted at the Home Node before ReadNoSnp-3 is sent to the Home Node.
6. After receipt of an appropriate PCrdGrant, the Request Node resends the ReadNoSnp-2 request.
7. The Home Node accepts the request and returns a ReadReceipt-2 response to the Request Node.

1. After receipt of the ReadReceipt-2 response, the Request Node sends the ReadNoSnp-3 request to the Home Node.
2. The Home Node accepts the request and returns the ReadReceipt-3 response to the Request Node.
3. The Home Node completes the Request transactions by sending a combined completion and Data response to the Request Node for each request.

###### **Note**

Figure 2-34 on page 2-121 shows a single ordered stream of three reads from the Request Node. However, a Request Node can have multiple streams of reads, in which case requests must be ordered within a stream, but ordering dependency does not exist between streams. One example of this is when the streams are from different threads within the Request Node. In this case, the Request Node waits for the ReadReceipt of the previous request from the same thread only before sending out the next ordered request from that stream.

#### CopyBack Request order

An RN-F must wait for the CompDBIDResp response to be received for an outstanding CopyBack transaction before issuing another request to the same cache line. It is permitted for an Atomic transaction with SnoopMe asserted to be issued before the CompDBID response is received for an outstanding CopyBack to the same cache line.

#### Streaming Ordered Write transactions

The architectural mechanisms applicable to increasing *Ordered Write Observation* (OWO) Write streaming efficiency, and the corresponding constraints, are applicable to WriteUnique and WriteNoSnp transactions only.

If a Requester requires a sequence of Write transactions to be observed in the same order as they are issued, then the Requester can wait for completion for a write before issuing the next write in the sequence. Such an observation ordering is typically termed Ordered Write Observation. This specification provides a mechanism termed Streaming Ordered Writes to more efficiently stream such ordered Write transactions.

The Streaming Ordered Write mechanism relies on the use of the OWO ordering requirement and CompAck. Responsibilities of Requesters and HN-F when utilizing the Streaming Ordered Write solution are:

- The Requester must set the Order field to 0b10 and set ExpCompAck on the Write request.
- The Ordered Write Observation requirement in a Write request indicates to the HN-F that the completion of coherence action on this write must not depend on completion of coherence action on a subsequent write.
- The Requester must wait for DBIDResp, DBIDRespOrd, CompDBIDResp, or Comp for a Write transaction before sending the next Write request.
- The Requester, after receiving DBIDResp, DBIDRespOrd, CompDBIDResp, or Comp for the corresponding write, as well as Comp responses for all earlier related ordered writes, must send a CompAck response. If write data is to be sent, then the Requester is permitted to combine the CompAck with the WriteData response into a NCBWrDataCompAck response. When the Requester combines CompAck with the WriteData response it must send a combined response for all WriteData transfers. The method by which a Requester determines if a group of ordered writes are related is IMPLEMENTATION DEFINED.

###### **Note**

Waiting to send CompAck until all prior ordered writes have received their Comp responses ensures that they have completed their operations at their respective HN-Fs and any Requester observing the write for which CompAck is sent will also observe all prior ordered writes.

- The Requester that receives DBIDResp\* and is ready to send CompAck must not wait for Comp to send CompAck.
- HN-F must wait for a CompAck response from the Request Node before deallocating a Write transaction and making the write visible to other observers.

#### **Optimized Streaming Ordered Write transactions**

The writes in this section refer to WriteUnique or WriteNoSnp only. The Streaming Ordered Writes mechanism can be further optimized. If a previously sent write is to a different target then the Requester does not need to wait for the DBIDResp\* for the request before sending the next ordered write. However, if the interconnect can remap the Tg1ID, then the Requester must presume that all Write transactions are targeting the same HN-F and must not use the optimized version of the Streaming Ordered Writes flow.

An implementation using an optimized or non-optimized Streaming Ordered Writes solution must avoid deadlock and livelock situations.

###### — Note —

- A technique for avoiding resource-related deadlock or livelock issues is to limit Streaming Ordered Writes optimization to one Requester in the system. All other Requesters in the system can use the Streaming Ordered Writes solution without the optimization.
- In a typical system, the optimized Streaming Ordered Writes solution is most beneficial to an RN-I that is a conduit for PCIe style, non-relaxed order, Snoopable writes. In most systems, one RN-I hosting this type of PCIe traffic is adequate.
- OWO Writes can be used by more than one Requester by making use of WriteDataCancel messages to avoid resource related deadlocks and livelocks.

Figure 2-35 shows a typical transaction flow in which an RN-I uses Streaming Ordered WriteUnique transactions. This flow prevents a read acquiring the new value of Write-B before Write-A has completed.

— Note —

For clarity, in Figure 2-35 the Write-B DBIDResp\* and the NCBWrData flow is omitted.

![](44657db229e0cbc8745919e278cc7592_img.jpg)

Sequence Diagram illustrating Streaming Ordered WriteUnique transactions flow between RN-F1, RN-F2, HN-F, and RN-I.

Key messages and flow:

- At RN-I, WriteUnique-A is sent.
- At RN-I, Request B is sent after receiving DBIDResp for request A.
- At HN-F, DBIDResp-A is sent.
- At HN-F, NCBWrData-A is sent.
- At HN-F, WriteUnique-B is sent.
- At RN-F1, SnpCleanInvalid-A is sent.
- At RN-F1, SnpResp\_I-A is sent.
- At RN-F2, SnpCleanInvalid-A is sent.
- At RN-F2, SnpResp\_I-B is sent.
- At RN-F1, SnpCleanInvalid-B is sent.
- At RN-F1, SnpResp\_I-B is sent.
- At HN-F, SnpCleanInvalid-B is sent.
- At HN-F, Comp-B is sent.
- At HN-F, Comp-A is sent.
- At RN-I, CompAck-A is sent.
- At RN-I, CompAck-B is sent.
- CompAck for B is not sent until the Comp for A is received.

Figure 2-35 Streaming Ordered WriteUnique transactions flow

## 2.9 Address, Control, and Data

A transaction includes attributes defining the manner in which the transaction is handled by the interconnect. These include the address, memory attributes, snoop attributes, and data formatting. Each attribute is defined in this section.

In this section, unless explicitly stated otherwise, a reference to a Write transaction includes both the individual Write transaction and the corresponding Combined Write transaction.

### 2.9.1 Address

This specification supports:

- *Physical Address (PA)* of 44 to 52 bits, in one bit increments.
- *Virtual Address (VA)* of 49 to 53 bits.

The REQ and SNP packet Addr fields are specified as follows:

- REQ channel: Address[(MPA-1):0]
- SNP channel: Address[(MPA-1):3]

MPA is the Maximum PA supported.

Table 2-10 shows the relationship between the physical address field width and the supported virtual address.

Table 2-10 Addr field width and supported PA and VA size

| REQ Addr field width in bits | Maximum address supported in bits |    |
|------------------------------|-----------------------------------|----|
|                              | PA                                | VA |
| 44                           | 44                                | 49 |
| 45                           | 45                                | 51 |
| 46 to 52                     | 46 to 52                          | 53 |

See *DVMOp and SnpDVMOp packet* on page 8-317 for DVM payload mapping in the REQ and SNP fields with different Addr field widths.

The Req\_Addr\_Width parameter is used to specify the maximum physical address in bits that is supported by a component. Valid values for this parameter are 44 to 52, when not specified, the parameter takes the default value of 44.

### 2.9.2 Non-secure bit

Secure and Non-secure transactions are defined to support Secure and Non-secure operating states.

This bit is defined so that when it is asserted the transaction is identified as a Non-secure transaction.

For Snoopable transactions, this field can be considered as an additional address bit that defines two address spaces: a Secure address space, and a Non-secure address space. Any aliasing between the Secure and Non-secure address spaces must be handled correctly.

###### Note

Hardware coherency does not manage coherency between Non-Secure and Secure address spaces.

The Non-secure assertion requirements are:

- Can be asserted in any Read, Dataless, Write and Atomic transaction.
- Can be asserted in PrefetchTgt transaction.
- Is not applicable in the DVMOp or PCrdReturn transaction, and must be set to zero.

### 2.9.3 Memory Attributes

The *Memory Attributes* (MemAttr) consist of *Early Write Acknowledgment* (EWA), Device, Cacheable, and Allocate.

#### EWA

EWA indicates whether the Write completion response for a transaction:

- Is permitted to come from an intermediate point in the interconnect, such as a Home Node.
- Must come from the final endpoint that a transaction is destined for.

If EWA is asserted, the Write completion response for the transaction can come from an intermediate point or from the endpoint. A completion that comes from an intermediate point must provide the same guarantees required by a Comp as described in *Completion response and ordering on page 2-114*.

If EWA is deasserted, the write completion response for the transaction must come from the endpoint.

##### Note

It is permitted for an implementation not to use the EWA attribute. In this instance, completion must be given from the endpoint.

The EWA assertion requirements are:

- Can take any value in a ReadNoSnp and ReadNoSnpSep transaction.
- Can take any value in a WriteNoSnp transaction.
- Can take any value in CMO transactions.
- Can take any value in Atomic transactions.
- Must be asserted in any Read or Dataless transaction that is not a ReadNoSnp, ReadNoSnpSep, or CMO transaction.
- Must be asserted in any Write transaction that is not a WriteNoSnp transaction.
- Is inapplicable and must be set to zero in the DVMOp or PCrdReturn transactions.
- Is inapplicable and can take any value in the PrefetchTgt transaction.

#### Device

Device attribute indicates if the memory type is either Device or Normal.

#### Device memory type

Device memory type must be used for locations that exhibit side-effects. Use of Device memory type for locations that do not exhibit side-effects is permitted.

The requirements for a transaction to a Device type memory location are:

- A Read transaction must not read more data than requested.
- Prefetching from a Device memory location is not permitted.
- A read must get its data from the endpoint. A read must not be forwarded data from a write to the same address location that completed at an intermediate point.
- Combining requests to different locations into one request, or combining different requests to the same location into one request, is not permitted.
- Writes must not be merged.
- Writes to Device memory that obtain completion from an intermediate point must make the write data visible to the endpoint in a timely manner.

Accesses to Device memory must use the following types, exclusive variants are permitted:

- Read accesses to a Device memory location must use ReadNoSnp.
- Write accesses to a Device memory location must use either WriteNoSnpFull or WriteNoSnpPtl.
- CMO transactions are permitted to Device memory locations.
- Atomic transactions are permitted to Device memory locations.
- The PrefetchTgt transaction is not permitted to Device memory locations. The MemAttr field is inapplicable and can take any value in the PrefetchTgt transaction.

#### Normal memory type

Normal memory type is appropriate for memory locations that do not exhibit side-effects.

Accesses to Normal memory do not have the same restrictions regarding prefetching or forwarding as Device type memory:

- A Read transaction that has EWA asserted can obtain read data from a Write transaction that has sent its completion from an intermediate point and is to the same address location.
- Writes can be merged.

Any Read, Dataless, Write, PrefetchTgt, or Atomic transaction type can be used to access a Normal memory location. The transaction type used is determined by the memory operation to be accomplished, and the Snoopable attributes.

#### Cacheable

The Cacheable attribute indicates if a transaction must perform a cache lookup:

- When Cacheable is asserted, the transaction must perform a cache lookup.
- When Cacheable is deasserted, the transaction must access the final destination.

The Cacheable attribute value requirements are:

- Must not be asserted for any Device memory transaction.
- Must be asserted for any Read transaction except for ReadNoSnp and ReadNoSnpSep.
- Must be asserted for any Dataless transaction except for CleanShared, CleanSharedPersist\*, CleanInvalid, MakeInvalid.
- Must be asserted for any Write transaction, except WriteNoSnpFull and WriteNoSnpPtl.
- Can take any value for ReadNoSnp, ReadNoSnpSep, WriteNoSnpFull, and WriteNoSnpPtl to a Normal memory location.
- Can take any value for CleanShared, CleanSharedPersist\*, CleanInvalid, and MakeInvalid.
- Can take any value for an Atomic transaction.
- Is inapplicable and must be set to zero in DVMOp and PCrdReturn transactions.
- Is inapplicable and can take any value in the PrefetchTgt transaction.

###### Note

In a transaction that can take any Cacheable value, the value is typically determined from the page table attributes.

#### Allocate

The Allocate attribute is an allocation hint and indicates the recommended allocation policy for a transaction:

- If Allocate is asserted, it is recommended that the transaction is allocated into the cache for performance reasons. However, it is permitted to not allocate the transaction.
- If Allocate is deasserted, it is recommended that the transaction is not allocated into the cache for performance reasons. However, it is permitted to allocate the transaction.

The Allocate attribute value requirements are:

- Can be asserted for transactions, except for ReadOnceMakeInvalid, that have the Cacheable attribute asserted.
- Must be asserted for the WriteEvictFull transaction.

###### Note

A Requester can convert a WriteEvictFull with the Allocate bit not asserted to an Evict transaction.

- Must not be asserted for Device memory transactions.
- Must not be asserted for Normal Non-cacheable memory transactions.
- Is inapplicable and must be set to zero in DVMOp, PCrdReturn, and Evict transactions.
- Is inapplicable and can take any value in the PrefetchTgt transaction.

#### Propagation of Attr

The MemAttr bits EWA, Device, Cacheable, and Allocate must be preserved on a request from the Home Node to the Subordinate Node that is sent in response to a request to the Home Node. The only exception to this rule is when the downstream memory is known to be Normal, then the Device field value can be set to 0b0 to indicate Normal.

The SnpAttr attribute bit value in a request from the Home Node to the Subordinate Node must always be set to 0b0.

When the write and CMO transactions in a received Combined Write request transaction are separated, the Write transaction inherits the MemAttr and SnpAttr values of the original combined request. The separated CMO transaction SnpAttr and Cacheable bits must be set to the most pervasive to affect all caches at RN-F nodes and caches downstream.

For a ReadNoSnp or WriteNoSnp generated within the interconnect due to a Prefetch from Home or an eviction from the System cache:

- MemAttr bits EWA, Cacheable, and Allocate must all be set to 0b1.
- Device field value must be set to 0b0 to indicate Normal.
- SnpAttr field value must be set to 0b0 to indicate Non-snoopable.

### 2.9.4 Transaction attribute combinations

Table 2-11 lists the legal combinations of MemAttr, SnpAttr, and Order field values and the equivalent ARM memory type. The Order field is described in [Ordering on page 2-114](#).

Table 2-11 Legal combinations of MemAttr, SnpAttr, and Order field values

|   | MemAttr[3:0] |                               |     |     | Order[1:0] |                  | ARM Memory Type  |   |                                           |
|---|--------------|-------------------------------|-----|-----|------------|------------------|------------------|---|-------------------------------------------|
|   | [1]          | [3]                           | [2] | [0] | [1]        | [0]              |                  |   |                                           |
| 1 | Device       | 0                             | 0   | 0   | 0          | 0                | 1                | 1 | Device nRnE                               |
|   |              | 0                             | 0   | 1   | 0          | 0                | 1                | 1 | Device nRE                                |
|   |              | 0                             | 0   | 1   | 0          | 0                | 0/1 <sup>a</sup> | 0 | Device RE                                 |
|   |              | All other values <sup>b</sup> |     |     |            |                  |                  |   | Not valid                                 |
| 0 |              | 0                             | 0   | 0   | 0          | 0                | 0/1 <sup>a</sup> | 0 | Non-cacheable Non-bufferable <sup>c</sup> |
|   |              | 0                             | 0   | 1   | 0          | 0                | 0/1 <sup>a</sup> | 0 | Non-cacheable Bufferable                  |
|   |              | 0                             | 1   | 1   | 0          | 0                | 0/1 <sup>a</sup> | 0 | Non-snoopable WriteBack No-allocate       |
|   |              | 1                             | 1   | 1   | 0          | 0                | 0/1 <sup>a</sup> | 0 | Non-snoopable WriteBack Allocate          |
|   |              | 0                             | 1   | 1   | 1          | 0/1 <sup>d</sup> | 0/1 <sup>a</sup> | 0 | Snoopable WriteBack No-allocate           |
|   |              | 1                             | 1   | 1   | 1          | 0/1 <sup>d</sup> | 0/1 <sup>a</sup> | 0 | Snoopable WriteBack Allocate              |
|   |              | All other values <sup>b</sup> |     |     |            |                  |                  |   | Not valid                                 |

1. Order = 0b10 is permitted in ReadOnce\*, WriteUnique, ReadNoSnp, WriteNoSnp and Atomic transactions only.
2. Order = 0b01 is not used for transactions' ordering. See [Transaction ordering on page 2-118](#).
3. Non-cacheable Non-bufferable is an AXI memory type, not an ARM memory type.
4. See [Likely Shared on page 2-131](#).

#### Memory type

This section specifies the required behavior for each of the memory types that Table 2-11 on page 2-129 shows.

##### Device nRnE

The required behavior for Device nRnE memory type is:

- The write response must be obtained from the final destination.
- Read data must be obtained from the final destination.
- A read must not fetch more data than is required.
- A read must not be prefetched.
- Writes must not be merged.
- A write must not write to a larger address range than the original transaction.
- All Read and Write transactions from the same source to the same endpoint must remain ordered.

##### Device nRE

The required behavior for the Device nRE memory type is the same as for the Device nRnE memory type except that the write response can be obtained from an intermediate point.

##### Device RE

The required behavior for the Device RE memory type is the same as for the Device nRE memory type except that:

- Read and Write transactions from the same source to the same endpoint need not remain ordered.
- Read and Write transactions from the same source to addresses that overlap must remain ordered.

#### Normal Non-cacheable Non-bufferable

The required behavior for the Normal Non-cacheable Non-bufferable memory type is:

- The write response must be obtained from the final destination.
- Read data must be obtained from the final destination.
- Writes can be merged.
- Read and Write transactions from the same source to addresses that overlap must remain ordered.

#### Normal Non-cacheable Bufferable

The required behavior for the Normal Non-cacheable Bufferable memory type is:

- The write response can be obtained from an intermediate point.
- Write transactions must be made visible at the final destination in a timely manner.

**Note**  
There is no mechanism to determine when a Write transaction is visible at its final destination.

- Read data must be obtained either from:
  - The final destination.
  - A Write transaction that is progressing to its final destination.If read data is obtained from a Write transaction:
  - It must be obtained from the most recent version of the write.
  - The data must not be cached to service a later read.
- Writes can be merged.
- Read and Write transactions from the same source to addresses that overlap must remain ordered.

**Note**  
For a Normal Non-cacheable Bufferable read, data can be obtained from a Write transaction that is still progressing to its final destination. This is indistinguishable from the Read and Write transactions propagating to arrive at the final destination at the same time. Read data returned in this manner does not indicate that the Write transaction is visible at the final destination.

#### Write-Back No-allocate

The required behavior for the Write-Back No-allocate memory type is:

- The Write response can be obtained from an intermediate point.
- Write transactions are not required to be made visible at the final destination.
- Read data can be obtained from an intermediate cached copy.
- Reads can be prefetched.
- Writes can be merged.
- A cache lookup is required for Read and Write transactions.
- Read and Write transactions from the same source to addresses that overlap must remain ordered.
- The No-allocate attribute is an allocation hint, that is, it is a recommendation to the memory system that, for performance reasons, the transaction is not allocated. However, the allocation of the transaction is not prohibited.

#### Write-Back Allocate

The required behavior for the Write-Back Allocate memory type is the same as for Write-Back No-allocate memory. However, in this case, the allocation hint is a recommendation to the memory system that, for performance reasons, the transaction is allocated.

### 2.9.5 Likely Shared

The LikelyShared attribute is a cache allocation hint. When asserted this attribute indicates that the requested data is likely to be shared by other Request Nodes within the system. This acts as a hint to shared system level caches that the allocation of the cache line is recommended for performance reasons.

There is no required behavior associated with this transaction attribute.

The LikelyShared assertion requirements are:

- Can be asserted in:
  - ReadClean
  - ReadNotSharedDirty
  - ReadShared
  - StashOnceUnique, StashOnceSepUnique
  - StashOnceShared, StashOnceSepShared
  - WriteUniquePtl
  - WriteUniqueFull
  - WriteUniqueZero
  - WriteUniquePtlStash
  - WriteUniqueFullStash
  - WriteBackFull
  - WriteCleanFull
  - WriteEvictFull
  - WriteEvictOrEvict

- Must not be asserted in any other Read, Write, or Combined Write transaction.
- Must not be asserted in any Dataless or Atomic transaction.
- Is not applicable in DVMOp or PCrdReturn transaction, and must be set to zero.
- Is not applicable in PrefetchTgt transaction and can take any value.

### 2.9.6 Snoop Attribute

The *Snoop Attribute* (SnpAttr) field indicates if a transaction requires snooping.

Table 2-12 shows the SnpAttr field encodings.

Table 2-12 SnpAttr field encodings

| SnpAttr | Snoop attribute |
|---------|-----------------|
| 0       | Non-snoopable   |
| 1       | Snoopable       |

Table 2-13 shows the snoop attributes for the different transaction types. The following key is used:

| Y   | Yes, permitted |
|-----|----------------|
| -   | Not permitted  |
| n/a | Not applicable |

Table 2-13 Snoop attributes for the different transaction types

| Transaction                                                                                        | Non-snoopable    | Snoopable        |
|----------------------------------------------------------------------------------------------------|------------------|------------------|
| ReadNoSnp, ReadNoSnpSep                                                                            | Y                | -                |
| ReadOnce*, ReadClean, ReadShared, ReadNotSharedDirty, ReadUnique, ReadPreferUnique, MakeReadUnique | -                | Y                |
| CleanUnique, MakeUnique, StashOnce                                                                 | -                | Y                |
| CleanShared, CleanSharedPersist*, CleanInvalid, MakeInvalid                                        | Y                | Y                |
| Evict                                                                                              | -                | Y                |
| WriteNoSnp                                                                                         | Y                | -                |
| WriteBack, WriteClean, WriteEvictFull                                                              | -                | Y                |
| WriteUnique                                                                                        | -                | Y                |
| Atomic transactions                                                                                | Y                | Y                |
| DVMOp                                                                                              | n/a <sup>a</sup> | n/a <sup>a</sup> |
| PrefetchTgt                                                                                        | n/a <sup>b</sup> | n/a <sup>b</sup> |

1. Not applicable, SnpAttr bit is used as a Domain Identifier in DVM transactions, see *DVM domain* on page 8-321.
2. Not applicable, can take any value.

The SnpAttr field value in a CMO, in an Atomic, and in ReadNoSnp and ReadNoSnpSep from Home to Subordinate, must be set to zero, irrespective of the field value in the Request from the original Requester to Home. In Write and Combined Write transactions from Home to Subordinate, the bit position for the SnpAttr field is used for the DoDWT field. See *Home to Subordinate Write transactions* on page 2-78 and *Home to Subordinate Combined Write and CMO transactions* on page 2-80.

###### Note

For transactions that can take more than one value of SnpAttr, the value is typically determined from page table attributes.

### 2.9.7 Mismatched Memory attributes

It is permitted for two different agents to access the same location using mismatched MemAttr or SnpAttr values, at the same point in time.

Memory accesses from the different agents made with mismatched snoopability or cacheability attributes are considered as software protocol errors. A software protocol error can cause loss of coherency and result in the corruption of data values. It is required that the system does not deadlock on a software protocol error, and that transactions always make forward progress.

A software protocol error for an access in one 4KB memory region must not cause data corruption in a different 4KB memory region.

For locations held in Normal memory, the use of appropriate software cache maintenance can be used to return memory locations to a defined state.

The use of mismatched memory attributes can result in an RN-F observing a Snoop transaction to the same address that it is performing a ReadNoSnp or WriteNoSnp transaction to. In this situation there is no defined relationship between the Snoop transaction and the transaction that the RN-F has issued.

## 2.10 Data transfer

Read transactions, Write transactions, Atomic transactions, and Snoop responses with data, include a data payload. This section defines the data alignment rules, and the data bytes that are accessed for different combinations of address, transaction size, and memory type.

In this section, unless explicitly stated otherwise, a reference to a Write transaction includes both the individual Write transaction and the corresponding Combined Write transaction.

### 2.10.1 Data size

The Size field in a packet is used, in combination with other fields, to determine the number of bytes transferred. Table 2-14 shows the Size field value encodings. Snoop transactions do not include a Size field. All snoop data transfers are 64-byte.

Table 2-14 Size field value encodings

| Size[2:0] | Bytes    |
|-----------|----------|
| 0b000     | 1        |
| 0b001     | 2        |
| 0b010     | 4        |
| 0b011     | 8        |
| 0b100     | 16       |
| 0b101     | 32       |
| 0b110     | 64       |
| 0b111     | Reserved |

### 2.10.2 Bytes access in memory

The MemAttr[1] bit field determines if the memory type is Device or Normal. See [Memory Attributes on page 2-126](#). The bytes that are accessed are determined by the memory type as follows:

#### Normal memory

Transactions with a Normal memory type access the number of bytes defined by the Size field. Data access is from the Aligned\_Address, that is, the transaction address rounded down to the nearest Size boundary, and ends at the byte before the next Size boundary.

This is calculated as:

Start\_Address = Addr field value.

Number\_Bytes =  $2^{\text{Size}}$  field value.

INT(x) = Rounded down integer value of x.

Aligned\_Address = (INT(Start\_Address / Number\_Bytes)) x Number\_Bytes.

The bytes accessed are from (Aligned\_Address) to (Aligned\_Address + Number\_Bytes) - 1.

#### Device

Transactions with a Device memory type access the number of bytes from the transaction address up to the byte before the next Size boundary.

The bytes accessed are from (Start\_Address) to (Aligned\_Address + Number\_Bytes) - 1.

For Write transactions to Device locations, byte enables must only be asserted for the bytes that are accessed. See [Byte Enables on page 2-135](#).

### 2.10.3 Byte Enables

Byte Enables, also referred to as BE, are used alongside Write transactions, and Snoop responses with Data.

In this section, unless explicitly stated otherwise, a reference to a Write transaction includes both the individual Write transaction and the corresponding Combined Write transaction.

For Write transactions, an asserted byte enable indicates that the associated data byte is valid and must be updated in memory or cache. A deasserted byte enable indicates that the associated data byte is not valid and must not be updated in memory or cache.

In WriteData and Snoop response Data a byte enable value of zero must set the associated data byte value to zero.

For all Write transactions, byte enables that are not within the data window, specified by Addr and Size, must be deasserted.

A Requester must deassert all BE values in CopyBackWrData\_I and WriteDataCancel packets.

The following Write transactions must have all byte enables asserted during the data transfers, except when the write data is a CopyBackWrData\_I packet:

- WriteNoSnpFull
- WriteBackFull
- WriteCleanFull
- WriteEvictFull
- WriteUniqueFull
- WriteUniqueFullStash

The following Write transactions are permitted to have any combination of byte enables asserted during the data transfers. This includes asserting all and asserting none:

- WriteBackPtl
- WriteUniquePtl
- WriteUniquePtlStash

For the WriteNoSnpPtl transaction the following rules apply:

- For a transaction to Normal memory, any combination of byte enables can be asserted during the data transfers. This includes asserting all and asserting none.
- For a transaction to Device memory, byte enables must only be asserted for bytes at or above the address specified in the transaction. Any combination of byte enables can be asserted that meets this requirement. This includes asserting all and asserting none.

For Atomic transactions, byte enables that are not within the data window, as specified below by Addr and Size, must be deasserted:

- If Addr is aligned to Size, then the Data window is [Addr: (Addr+Size-1)].
- If Addr is not aligned to Size, then the Data window is [(Addr-Size/2): (Addr+Size/2-1)].
- For Atomic transactions all byte enables within the data window must be asserted.

For Snoop responses with data that use the SnpRespData opcode, all byte enables must be asserted.

For Snoop responses with data that use the SnpRespDataPtl opcode, any combination of byte enables can be asserted alongside the data transfers. This includes asserting all and asserting none.

### 2.10.4 Data packetization

For each transaction that involves data, the data bytes can be transferred in multiple packets.

The number of packets required is determined by:

- Number of bytes
- Data bus width

The number of bytes transferred in each packet is determined by:

- Data bus width

This specification supports the following data bus widths:

- 128-bit
- 256-bit
- 512-bit

The *Data Identifier* (DataID) and *Critical Chunk Identifier* (CCID) fields are used to identify data packets within a transaction.

A transaction size of up to 16-byte is always contained in a single packet. The DataID field value must be set to Addr[5:4] because the DataID field represents Addr[5:4] of the lowest addressed byte within the packet.

Table 2-15 shows the relationship between the DataID field and the bytes that are contained within the packet, for different data bus widths.

Table 2-15 DataID and the bytes within a packet for different data widths

| DataID | Data Width    |               |             |
|--------|---------------|---------------|-------------|
|        | 128-bit       | 256-bit       | 512-bit     |
| 0b00   | Data[127:0]   | Data[255:0]   | Data[511:0] |
| 0b01   | Data[255:128] | Reserved      | Reserved    |
| 0b10   | Data[383:256] | Data[511:256] | Reserved    |
| 0b11   | Data[511:384] | Reserved      | Reserved    |

Within a data packet, all bytes are located at their natural byte positions. This is true even if fewer data bytes are transferred than the width of the data bus.

The number of data packets used for transactions to Device memory is independent of the address of the transaction. The number of data packets required is determined only by the Size field and the data bus width.

— Note —

For some transactions to Device memory, it can be determined from the address at the start of the transaction that some data packets will not contain valid data and are redundant. However, it is required that these data packets are transferred.

### 2.10.5 Size, Address and Data alignment in Atomic transactions

This section describes the data size and alignment requirements for Atomic transactions. It contains the following sub-sections:

- *Size*
- *Address and Data alignment*
- *Endianness on page 2-138*

#### Size

The Size field of the packet specifies the total data size of the Atomic transaction.

For the AtomicCompare transaction, the data size is the sum of the Compare and Swap data values.

Table 2-16 shows the permitted data sizes, and the relationship between inbound and outbound valid data size for each Atomic transaction type. The size of the data value returned in response to an AtomicCompare transaction is half the number of bytes specified in the Size field in the associated Request packet.

Table 2-16 Atomic transaction outbound and inbound data sizes

| Atomic transaction | Outbound (bytes)   | Inbound               |
|--------------------|--------------------|-----------------------|
| AtomicStore        | 1, 2, 4, or 8      | -                     |
| AtomicLoad         | 1, 2, 4, or 8      | Same as outbound      |
| AtomicSwap         | 1, 2, 4, or 8      | Same as outbound      |
| AtomicCompare      | 2, 4, 8, 16, or 32 | Half size of outbound |

#### Address and Data alignment

In the AtomicStore, AtomicLoad, and AtomicSwap transactions:

- The byte address is aligned to the outbound data size.
- The position of data bytes in the Data packet matches the endianness of the operation, as specified in the Endian field of the request.
- The big-endian data is byte invariant.

The write data associated with an AtomicCompare transaction is provided as if it were for a transaction that is aligned to the outbound data size.

In the AtomicCompare transaction:

- The byte address must be aligned in the Data packet to the inbound data size, which is equivalent to half the outbound data size.

The two data values in an AtomicCompare transaction are placed in the data field in the following manner:

- The Compare and Swap data values are concatenated and the resulting data payload is aligned in the Data packet to the outbound data size.
- The Compare data is always at the addressed byte location.
- The Swap data is always in the remaining half of the valid data.

For any given Compare data address, the Swap data address can be determined by inverting bit[n] in the Compare data address where:

- $n = \log_2(\text{Compare data size in bytes})$

#### Alignment example

Figure 2-36 shows examples of data placement with different addresses and different Data size.

![](2ee4eab0a7ac079c4858483ede251b76_img.jpg)

|                       | Comp and Data<br>Value size |
|-----------------------|-----------------------------|
| Example 1: Addr = 0x2 | 1 Byte each                 |
| Example 2: Addr = 0x5 | 1 Byte each                 |
| Example 3: Addr = 0x2 | 2 Byte each                 |
| Example 4: Addr = 0x4 | 2 Byte each                 |

Only 8 bytes of the 16 byte data packet are shown

Figure 2-36 Data value packing for AtomicCompare transaction

In Figure 2-36, Example 1 shows the addressed byte location is 0x2 and the total size of data is two bytes. In this case, the Compare and Swap data must be placed in an address location aligned to a 2 byte boundary that includes the addressed location, that is, addresses 0x2 to 0x3. Compare data is placed in location 0x2 and Swap data is placed in location 0x3.

###### **Note**

The address of the Swap data can be determined by inverting bit[0] of the Compare data address. Bit[0] is inverted because the size of the Compare data and the size of the Swap data is 1 byte.

In Figure 2-36, Example 3 shows the addressed location is 0x2 and the total size of data is four bytes. In this case, the Compare and Swap data must be placed in an address location aligned to a 4 byte boundary that includes the addressed location, that is, addresses 0x0 to 0x3. Compare data is placed in location 0x2 and Swap data is placed in location 0x0.

###### **Note**

The address of the Swap data can be determined by inverting bit[1] of the Compare data address. Bit[1] is inverted because the size of the Compare data and the size of the Swap data is two bytes.

#### Endianness

The data on which an atomic operation executes can be in either little-endian or big-endian format. For arithmetic operations, such as ADD, MAX, and MIN the component performing the operation needs to know the format of the data.

The endian format of the data is defined by the Endian bit in the Atomic transaction Request packet. See [Endian on page 13-432](#).

### 2.10.6 Critical Chunk Identifier

The CCID field is used to identify the data bytes that are the most critical in the transaction request.

The CCID field must match the value of Addr[5:4] of the original request. Transactions which contain multiple data packets must use the same CCID value for all data packets.

When read data or write data is reordered by the interconnect, the CCID field permits quick identification of the most critical bytes within a transaction by comparing the CCID value with the DataID value. When the two values match, the data bytes being transferred are the critical bytes.

The bits to match is dependent on the data bus width:

- For a data bus width of 128 bits, the CCID and DataID bits must match for the critical chunk.
- For a data bus width of 256 bits only the most significant CCID and DataID bits must match for the critical chunk.

### 2.10.7 Critical chunk first wrap order

The Sender of Data is permitted, but is not required, to send individual Data packets of a transaction in critical chunk first wrap order.

The interface property, CCF\_Wrap\_Order defines the capabilities of a Sender, and the guarantees provided by the Receiver:

- CCF\_Wrap\_Order at the Sender:
  - **True** The Sender signals that it is capable of sending Data packets in critical chunk first wrap order.
  - **False** The Sender signals that it is not capable of sending Data packets in critical chunk first wrap order.
- CCF\_Wrap\_Order at the interconnect:
  - **True** The interconnect guarantees that it will maintain the Data packets of a transaction in the order they are received.
  - **False** The interconnect signals that it does not guarantee it can maintain the Data packets of a transaction in the order they are received.
- CCF\_Wrap\_Order at the Receiver that is not an interconnect:
  - **True** The Receiver requires the Data packets to be received in critical chunk first wrap order.
  - **False** The Receiver does not require the Data packets to be received in critical chunk first wrap order.

If some components in the system do not support sending Data packets in critical chunk first wrap order then the receiver of Data must not rely on Data being received in critical chunk first wrap order.

###### Note

At design time, the CCF\_Wrap\_Order parameter can help a component to identify if Data packets need to be sent in critical chunk first wrap order. For example, if the component knows that it is connected to an out-of-order interconnect, then it might be able to simplify its Data packet path by not returning the Data packets in critical chunk first wrap order.

If the interconnect has the CCF\_Wrap\_Order property set to True, then a component interfacing to that interconnect, if capable, can send Data packets in critical chunk first wrap order, and the receiver can make use of possible latency optimization due to receiving the critical chunk first.

### 2.10.8 Data Beat ordering

The reordering of data packets within a transaction is permitted when passing across an interconnect. However, the original source of data packets is permitted, but not required, to provide the packets in a critical chunk first, wrap order. See *Critical chunk first wrap order* on page 2-139.

###### Note

Critical chunk first wrap order ensures that interfacing to protocols that do not support data reordering, such as AXI, can be done in the most efficient manner when an ordered interconnect is used.

Wrap order is defined as follows:

Start\_Address = Addr

Number\_Bytes =  $2^{\text{Size}}$

INT(x) = Rounded down integer value of x

Aligned\_Address = (INT(Start\_Address / Number\_Bytes)) x Number\_Bytes

Lower\_Wrap\_Boundary = Aligned\_Address

Upper\_Wrap\_Boundary = Aligned\_Address + Number\_Bytes - 1

To maintain wrap order, the order must be:

1. The first data packet must correspond to the data bytes specified by the Start\_Address of the transaction.
2. Subsequent packets must correspond to incrementing byte addresses up to the Upper\_Wrap\_Boundary.
3. Subsequent packets must correspond to the Lower\_Wrap\_Boundary.
4. Subsequent packets must correspond to incrementing byte addresses up to the Start\_Address.

###### Note

Some of the steps to maintain wrap order might overlap and not be required if the required bytes are included in a previous step.

### 2.10.9 Data transfer examples

This section gives a number of examples of the data transfer requirements defined in this specification.

In most of the examples, the size of the transaction is 64 bytes and the data bus width is 128 bits. This requires 4 data packets for each transaction.

In the following examples, the accompanying text highlights some interesting aspects. It is not intended to describe all aspects of the example.

#### Example 2-1 Normal memory 64-byte Read transaction from an aligned address

![](b68adb563a4c71503e8fe8d0e63b56ab_img.jpg)

Normal Memory Read Transaction  
Size = 0b110 (64B)

Addr = 0x0040

Data Size Boundary

Data Size Boundary

| 8F | 80 | 7F | 70 | 6F | 60 | 5F | 50 | 4F | 40 | 3F | 30 | 2F | 20 |
|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
|----|----|----|----|----|----|----|----|----|----|----|----|----|----|

Packet 3 Packet 2 Packet 1 Packet 0

| DataID = 0x3<br>CCID = 0x0 | DataID = 0x2<br>CCID = 0x0 | DataID = 0x1<br>CCID = 0x0 | DataID = 0x0<br>CCID = 0x0 |
|----------------------------|----------------------------|----------------------------|----------------------------|
|----------------------------|----------------------------|----------------------------|----------------------------|

- The order of the data packets, as indicated by Packet 0, Packet 1, Packet 2, and Packet 3, is such that they follow wrap order.
- The DataID changes for each packet, while the CCID field remains constant.
- The packet containing the data bytes specified by the address of the transaction has the same value for the CCID and DataID fields.

#### Example 2-2 Normal memory 64-byte Read transaction from an unaligned address

![](1be6088acfdf350d5b843557fb778d25_img.jpg)

Diagram illustrating a Normal Memory Read Transaction of Size 0b110 (64B) starting at Address 0x0068. The memory map shows addresses 8F, 80, 7F, 70, 6F, 68, 67, 60, 5F, 50, 4F, 40, 3F, 30, 2F, 20. Data Size Boundaries are indicated at 80 and 40. The transaction is divided into four packets (Packet 0, Packet 1, Packet 2, Packet 3) with the following DataID and CCID values:

| Packet   | DataID | CCID |
|----------|--------|------|
| Packet 0 | 0x2    | 0x2  |
| Packet 1 | 0x3    | 0x2  |
| Packet 2 | 0x0    | 0x2  |
| Packet 3 | 0x1    | 0x2  |

- The order of the data packets, as indicated by Packet 0, Packet 1, Packet 2, and Packet 3, is such that they follow wrap order.
- The DataID changes for each packet, while the CCID field remains constant.
- The packet containing the data bytes specified by the address of the transaction has the same value for the CCID and DataID fields.

#### Example 2-3 Normal memory 32-byte Read transaction from an unaligned address

![](6ccddcaf102e121d4377d3b51a141b28_img.jpg)

Diagram illustrating a Normal Memory Read Transaction of Size 0b101 (32B) starting at Address 0x0078. The memory map shows addresses 8F, 80, 7F, 78, 77, 70, 6F, 60, 5F, 50, 4F, 40, 3F, 30, 2F, 20. Data Size Boundaries are indicated at 80 and 60. The transaction is divided into two packets (Packet 0 and Packet 1) with the following DataID and CCID values:

| Packet   | DataID | CCID |
|----------|--------|------|
| Packet 0 | 0x3    | 0x3  |
| Packet 1 | 0x2    | 0x3  |

- The size of the transaction is 32-byte and the data bus width is 128-bit, resulting in 2 data packets.
- The order of the data packets, as indicated by Packet 0 and Packet 1, is such that they follow wrap order.

#### Example 2-4 Normal memory 14-byte consecutive write transaction from an unaligned address

![](0edc1257f56dc0e7c86c93b2b14d1dfc_img.jpg)

Normal Memory Write Transaction  
Size = 0b110 (64B)

Data Size Boundary

Addr = 0x0058  
14-bytes written

Data Size Boundary

| 8F | 80 | 7F | 70 | 6F | 60 | 5F | 58 | 57 | 50 | 4F | 40 | 3F | 30 | 2F | 20 |
|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|

Packet 2 Packet 1 Packet 0 Packet 3

| DataID = 0x3<br>CCID = 0x1<br>BE = 0x0000 | DataID = 0x2<br>CCID = 0x1<br>BE = 0x003F | DataID = 0x1<br>CCID = 0x1<br>BE = 0xFF00 | DataID = 0x0<br>CCID = 0x1<br>BE = 0x0000 |
|-------------------------------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
|-------------------------------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|

- The order of the data packets, as indicated by Packet 0, Packet 1, Packet 2, and Packet 3, is such that they follow wrap order.
- The DataID changes for each packet, while the CCID field remains constant.
- The packet containing the data bytes specified by the address of the transaction has the same value for the CCID and DataID fields.
- Fourteen consecutive bytes in memory are written, as indicated by the byte enables. However, other combinations of byte enables are permitted. See [Byte Enables on page 2-135](#).

#### Example 2-5 Device Read transaction from an unaligned address

![](710630a233e2bcdeec533d2ff71224cb_img.jpg)

Diagram illustrating a Device Read Transaction (Size = 0b110 (64B)) starting at Address = 0x0058. The transaction spans 64 bytes, extending from the Data Size Boundary (0x80) up to the next Data Size Boundary (0x40). The shaded area represents the valid bytes transferred.

The transaction is divided into four packets:

| Packet | Packet 2 | Packet 1 | Packet 0 | Packet 3 |
|--------|----------|----------|----------|----------|
| DataID | 0x3      | 0x2      | 0x1      | 0x0      |
| CCID   | 0x1      | 0x1      | 0x1      | 0x1      |

- The shaded area indicates the valid bytes in the transaction. The valid bytes extend from the transaction address up to the next Size boundary.
- The transaction includes the transfer of a packet that contains no valid data.

#### Example 2-6 Device write transaction to an unaligned address

![](1406d3fbba2b2fce2607beceace3b6fa_img.jpg)

Diagram illustrating a Device Write Transaction (Size = 0b110 (64B)) starting at Address = 0x0068. The transaction spans 64 bytes, extending from the Data Size Boundary (0x80) up to the next Data Size Boundary (0x40). The shaded area represents the valid bytes transferred.

The transaction is divided into four packets:

| Packet | Packet 1 | Packet 0 | Packet 3 | Packet 2 |
|--------|----------|----------|----------|----------|
| DataID | 0x3      | 0x2      | 0x1      | 0x0      |
| CCID   | 0x2      | 0x2      | 0x2      | 0x2      |
| BE     | 0xFFFF   | 0xFF00   | 0x0000   | 0x0000   |

- Byte enables are only permitted to be asserted for the bytes from the transaction address up to the next Size boundary. It is not required that all byte enables meeting this criteria are asserted.
- Byte enables for bytes below the start address must not be asserted.

## 2.11 Request Retry

This specification provides a Request Retry mechanism that ensures when a request reaches a Completer it is either accepted, or is given a RetryAck response, to prevent blocking of the REQ channel.

Request Retry is not applicable to the PrefetchTgt transaction. The PrefetchTgt transaction cannot be retried because there is no response associated with this request.

A Requester is required to hold all the details of the request until it receives a response indicating that the request has either been accepted, or must be sent again at a later point in time. To meet this requirement, except for PrefetchTgt, the AllowRetry field must be asserted the first time a transaction is sent.

A Completer that is receiving requests is able to give a RetryAck response to a request that it is not able to accept. Typically, it will not be able to accept a request when it has limited resources and insufficient storage to hold the current request until some earlier transactions have completed.

When a Completer gives a RetryAck response it is responsible for recording where the request came from, as determined by the SrcID of the request. The Completer is also responsible for determining and recording the type of Protocol Credit required to process the request. The PCrdType field in the RetryAck encodes the type of Protocol Credit that will be granted by the Completer. When required resources become available, at a later point in time, the Completer must then send a P-Credit to the Requester, using a PCrdGrant response. The PCrdGrant response indicates to the Requester that the transaction can be retried.

###### **Note**

There is no explicit mechanism to request a credit. A transaction that is given a RetryAck response implicitly requests a credit.

It is possible that a reordering interconnect can reorder the responses such that the PCrdGrant is received by the Requester before the RetryAck response for the transaction is received. In this case, the Requester must record the credit it has received, including the credit type, so that it can assign the credit appropriately when it does receive the RetryAck response.

###### **Note**

It is expected to be rare that a PCrdGrant would be re-ordered with respect to a RetryAck response, as the delay between a RetryAck and a PCrdGrant response will typically be much longer than any delay caused by interconnect re-ordering.

When the Requester receives a credit, it can then resend the request with an indication that it has been allocated a credit. This is done by deasserting the AllowRetry field. This second attempt to carry out the transaction is guaranteed to be accepted.

The transaction that is resent must have the same field values as the original request, except when the field is inapplicable or is one of the following:

- QoS
- TgtID. See [Target ID determination for Request messages on page 3-152.](#)
- TxnID
- ReturnTxnID for ReadNoSnp and ReadNoSnpSep from the Home Node to the Subordinate Node.
- SLCRepHint
- AllowRetry, which must be deasserted.
- PCrdType, which must be set to the value in the Retry response for the original transaction.
- TraceTag
- RSVDC

When the Requester receives a RetryAck response for a CopyBack Write request whose data is invalidated by a snoop, the Requester:

- Can drop the Write request and return the received credit.

- Is permitted to send the Write request with AllowRetry set to zero, knowing that the subsequent data response would be CopyBackWrData\_I.

There is no fixed relationship between credits and particular transactions. If a Requester has received multiple RetryAck responses for different transactions and then receives a credit, there is no fixed credit allocation. The Requester is free to choose the most appropriate transaction from the list of transactions that receives a RetryAck response with that particular Protocol Credit Type.

The Retry mechanism supports up to 16 different credit types. This lets the Completer use different credit types for different resources. For example, a Completer might use one credit type for the resources associated with Read transactions, and another credit type for Write transactions. Using different credit types gives the Completer the ability to efficiently manage its resources by controlling which of the retried requests can be sent again.

The transaction must only be retried by the Requester when a PCrdGrant is received with the correct PCrdType.

###### **Note**

If a Completer is only using one credit type, it is recommended that the PCrdType value of 0b0000 is used. See [PCrdType on page 2-147](#).

A Completer that is giving RetryAck responses must be able to record all the RetryAck responses that it has given to ensure it can correctly distribute credits. If the Completer is using more than one credit type, the RetryAck responses that have been given for each credit type must be recorded.

A Requester must limit the transactions it issues so that the Completer is never required to track more than 1024 transactions that require a PCrdGrant response. This is achieved by limiting the maximum number of outstanding transactions to 1024 for each Requester.

A transaction is outstanding from the cycle that the request is first issued until either:

- The transaction is fully completed, as determined by the return of all the following responses that are expected for the transaction:
  - ReadReceipt
  - CompData
  - RespSepData
  - DataSepResp
  - DBIDResp\*
  - Comp, CompCMO, CompPersist, and CompStashDone
  - CompDBIDResp
- It receives RetryAck and PCrdGrant and is either:
  - Retried using a credit of the appropriate PCrdType and then is fully completed as determined by the return of all responses.
  - Canceled and returns the received credit using the PCrdReturn message.

A Requester can reuse the TxnID value used by a request either:

- As soon as it receives a RetryAck response for that request.
- As soon as it receives all the required responses for that request if the received responses are Non-RetryAck responses.

Each transaction request includes a QoS value which can be used by the Completer to influence the allocation of credits as resources become available. See [Chapter 10 Quality of Service](#) for further details.

### 2.11.1 Credit Return

It is possible for a Requester to be given more credits than it requires.

This specification does not define when this can occur, but two typical scenarios are:

- A transaction is canceled between the first attempt and the point at which it can be resent with P-Credit.

- A transaction is requested multiple times with increasing QoS values. However, only a single completion of the transaction is required.

###### — Note —

If a Requester makes a second request before the first request has been given a RetryAck response, it must be acceptable for both transactions to occur. However, as an example, this behavior would typically not be acceptable for accesses to a peripheral device.

A Requester returns a credit by the use of the PCrdReturn transaction. This is effectively a *No Operation* (NOP) transaction that uses the credit that is not required. This transaction is used to inform the Completer that the allocated resources are no longer required for the given PCrdType.

Any credits that are not required must be returned in a timely manner.

###### — Note —

Any unused pre-allocated credit must be returned to avoid components holding on to credits in expectation of using them later. Such behavior is likely to result in an inefficient use of resources and to make analysis of the system performance difficult.

### 2.11.2 Transaction Retry mechanism

The following sections describe the Request transaction fields used by the Retry mechanism.

The transaction retry mechanism is not applicable to the PrefetchTgt transaction.

#### AllowRetry

The AllowRetry field indicates if the Request transaction can be given a RetryAck response. See Table 13-26 on page 13-432 for the AllowRetry value encodings. The AllowRetry field must be asserted the first time a transaction is sent.

The AllowRetry field must be deasserted when either:

- The transaction is using a pre-allocated P-Credit.
- The transaction is PrefetchTgt.

#### PCrdType

The PCrdType field indicates the credit type associated with the request and is determined as follows:

- For a Request transaction:
  - If the AllowRetry field is asserted, the PCrdType field must be set to 0b0000.
  - If the AllowRetry field is deasserted, the PCrdType field must be set to the value that was returned in the RetryAck response from the Completer when the transaction was first attempted.
- A PCrdReturn transaction must have the credit type set to the value of the credit type that is being returned. See *Protocol Credit Type, PCrdType* on page 13-434 for the PCrdType value encodings.
- For destinations that have a single credit class, or do not implement credit type classification, it is recommended that the PCrdType field is set to 0b0000.

###### — Note —

The value a Completer assigns to PCrdType is IMPLEMENTATION DEFINED.

The Completer must implement a starvation prevention mechanism to ensure that all transactions, irrespective of QoS value or credit type required, will eventually make forward progress, even if over a significantly long time period. This is done by ensuring that credits are eventually given to every transaction that has received a RetryAck response. See Chapter 10 *Quality of Service* for more details on the distribution of credits for the purposes of QoS.

### 2.11.3 Transaction Retry flow

Figure 2-37 shows a typical Transaction Retry flow.

![](58ab1110847fe57c438cad1cdf3b9454_img.jpg)

Sequence Diagram: Transaction Retry flow (Requester (RN-F) and Completer (HN-F)).

Initial state:  $n = 0 \times 0$  to  $0 \times F$ .

1. RN-F sends ReadOnce (AllowRetry = 1) (PCrdType = 0b0000) to HN-F.

2. HN-F sends RetryAck (PCrdType = n) to RN-F.

3. HN-F sends PCrdGrant (PCrdType = n) to RN-F.

4. RN-F sends ReadOnce (AllowRetry = 0) (PCrdType = n) to HN-F.

5. HN-F sends (P-Credit allocated) to RN-F.

6. HN-F sends (Log credit request) to RN-F.

7. HN-F sends HN-F buffer entry not gained to RN-F.

8. RN-F waits for P-Credit.

Figure 2-37 Transaction Retry flow

The steps that Figure 2-37 shows are:

1. The Requester sends a ReadOnce request.
   - This is done without a credit, so AllowRetry is asserted.
2. The Completer receives the request and sends a RetryAck response because it is not able to process the transaction at this time.
   - The request is logged and a PCrdType is determined at the Completer.
3. The Completer sends a P-Credit, using the PCrdGrant response, when it has allocated resource for the transaction.
   - The PCrdGrant includes the PCrdType allocated for the original request.
4. The Requester re-sends the transaction with AllowRetry deasserted.
   - The request uses the P-Credit and sets the PCrdType field to the value allocated for the original request.

It is permitted, but not expected, for a Completer to send a PCrdGrant before it has sent the associated RetryAck response.

###### **Note**

The Requester might receive PCrdGrant before RetryAck.

The second attempt at a transaction must not be sent until both a RetryAck response and an appropriate P-Credit is received for the transaction.

# Chapter 3Network Layer

This chapter describes the network layer that is responsible for determining the node ID of a destination node. It contains the following sections:

- [System Address Map on page 3-150](#)
- [Node ID on page 3-151](#)
- [Target ID determination on page 3-152](#)
- [Network layer flow examples on page 3-155](#)

## 3.1 System Address Map

To determine the target ID of a request, Requesters must have a *System Address Map* (SAM). Requesters might be Request Nodes or Home Nodes. The scope of the SAM might be as simple as providing a fixed node ID value to all the outgoing requests.

The exact format and structure of the SAM is *IMPLEMENTATION DEFINED* and is outside the scope of this specification.

The SAM must provide a complete decode of the entire address space. It is recommended that any address that does not correspond to a physical component is sent to an agent that can provide an appropriate error response.

## 3.2 Node ID

Each component connected to a Port on the interconnect is assigned a node ID that is used to identify the source and destination of packets communicated over the interconnect. A Port can be assigned multiple node IDs. A node ID value can be assigned only to a single Port.

This specification supports a variable NodeID field width of 7 bits to 11 bits.

The width can be configured to any fixed value within this range for a given implementation and this value must be consistent across all NodeID fields.

Defining and assigning a node ID for each node in a system is IMPLEMENTATION DEFINED and is outside the scope of this specification.

## 3.3 Target ID determination

This section describes how the target ID is determined for the different message types. It contains the following sections:

- [Target ID determination for Request messages](#)
- [Target ID determination for Response messages on page 3-153](#)
- [Target ID determination for Snoop Request messages on page 3-154](#)

### 3.3.1 Target ID determination for Request messages

For mapping of target ID in requests from the Request Node, it is required that the SAM logic to be present in the Request Node or in the interconnect. In the case of the interconnect, it might remap the target ID in the Request packet provided by the Request Node.

The target ID of a Request message is determined in the following manner using the SAM logic.

Except for PCrdReturn:

- If the request does not use a pre-allocated credit, then the target ID is determined by:
  - Opcode for DVMOp.
  - Address to node ID mapping for all other requests.

    PrefetchTgt uses a different Address to node ID mapper than other requests. Two requests from a Request Node to the same Address, where one is a PrefetchTgt, target different nodes. PrefetchTgt always targets a Subordinate Node. All other requests from a Request Node that use an Address to node ID mapper target a Home Node.
- If the request uses pre-allocated credit, the target ID of the Request must be obtained from either the source ID of the RetryAck, provided as a response to the original Request message, or the target ID of the original request.

For PCrdReturn:

- The target ID provided by the Request Node must match the source ID included in the prior PCrdGrant which provided the credit being returned.

A Request Node must expect the interconnect to remap the target ID of a request.

For transactions from a Request Node, except for PrefetchTgt which is targeted to an SN-F, this specification expects a Snoopable transaction to be targeted to HN-F and a Non-snoopable transaction to target HN-I or HN-E. It is legal for a Snoopable transaction to be targeted at an HN-I. This might occur, for example, due to a software programming error. In this case, the HN-I is required to respond to the transaction in a protocol-compliant manner, but coherency is not guaranteed.

A Home Node might also use address map logic to determine the target Subordinate Node ID for each request.

### 3.3.2 Target ID determination for Response messages

Response packets are issued as a result of a received message. The target ID in Response packets must match either the SrcID or the HomeNID, or the ReturnNID or the FwdNID in the received message that resulted in the response being sent.

Table 3-1 shows the source of the Response packet target ID for each Response message type and the field in the received message that determines the target ID.

Table 3-1 Source of response packet target ID

| Response message | Target ID obtained from                         |                                                                                                        |                                                        |
|------------------|-------------------------------------------------|--------------------------------------------------------------------------------------------------------|--------------------------------------------------------|
|                  | At the HN                                       | At the SN                                                                                              | At the RN                                              |
| RetryAck         | Request.SrcID                                   | Request.SrcID                                                                                          | -                                                      |
| PCrdGrant        | Request.SrcID                                   | Request.SrcID                                                                                          | -                                                      |
| ReadReceipt      | Request.SrcID                                   | Request.SrcID                                                                                          | -                                                      |
| RespSepData      | Request.SrcID or<br>SnpResp*.SrcID <sup>a</sup> | -                                                                                                      | -                                                      |
| Comp             | Request.SrcID                                   | Request.SrcID                                                                                          | -                                                      |
| CompCMO          | Request.SrcID                                   | Request.SrcID                                                                                          | -                                                      |
| DataSepResp      | Request.SrcID or<br>SnpResp*.SrcID <sup>a</sup> | Request.ReturnNID                                                                                      | -                                                      |
| CompData         | Request.SrcID or<br>SnpResp*.SrcID <sup>a</sup> | Request.ReturnNID                                                                                      | Snoop.FwdNID                                           |
| CompAck (reads)  | -                                               | -                                                                                                      | Comp.SrcID or RespSepData.SrcID or<br>CompData.HomeNID |
| CompAck (writes) | -                                               | -                                                                                                      | Comp.SrcID or DBIDResp*.SrcID or<br>CompDBIDResp.SrcID |
| DBIDResp         | Request.SrcID                                   | If Request.DoDWT == 0 then:<br>Request.SrcID<br>or<br>If Request DoDWT == 1 then:<br>Request.ReturnNID | -                                                      |
| DBIDRespOrd      | Request.SrcID                                   | -                                                                                                      | -                                                      |
| WriteData        | -                                               | -                                                                                                      | DBIDResp*.SrcID or CompDBIDResp.SrcID                  |
| NCBWrDataCompAck | -                                               | -                                                                                                      | Comp.SrcID or DBIDResp*.SrcID or<br>CompDBIDResp.SrcID |
| Persist          | Request.SrcID                                   | Request.ReturnNID                                                                                      | -                                                      |
| CompPersist      | Request.SrcID                                   | Request.SrcID or<br>Request.ReturnNID                                                                  | -                                                      |
| StashDone        | Request.SrcID                                   | -                                                                                                      | -                                                      |

Table 3-1 Source of response packet target ID (continued)

| Response message      | Target ID obtained from |                   |             |
|-----------------------|-------------------------|-------------------|-------------|
|                       | At the HN               | At the SN         | At the RN   |
| CompStashDone         | Request.SrcID           | -                 | -           |
| TagMatch              | Request.SrcID           | Request.ReturnNID | -           |
| SnResp <sup>a,b</sup> | -                       | -                 | Snoop.SrcID |

a. For Data Pull requests where Snoop response can be SnResp or SnRespData or SnRespDataPtl.  
b. SnResp, SnRespData, SnRespDataPtl, SnRespFwded, and SnRespDataFwded.

### 3.3.3 Target ID determination for Snoop Request messages

A Snoop request does not include a target ID. The protocol does not define an architectural mechanism to address and send a Snoop request to a target. It is expected that this mechanism will be IMPLEMENTATION DEFINED and is outside the scope of this specification.

## 3.4 Network layer flow examples

This section shows transaction flows at the network layer. It contains the following sections:

- *Simple flow*
- *Flow with interconnect-based SAM on page 3-156*
- *Flow with interconnect based SAM and Retry request on page 3-157*

### 3.4.1 Simple flow

Figure 3-1 is an example of a simple transaction flow and shows how the TgtID is determined for the requests and responses.

![Figure 3-1: Target ID assignment without remapping. The diagram shows three nodes: RN0 (Requester Node), HN0 (Home Node), and SN0 (Subordinate Node). RN0 sends a Request packet to HN0. The packet header is TgtID=HN0, SrcID=RN0. HN0 sends a Return Request packet to SN0. The packet header is TgtID=SN0, SrcID=HN0, ReturnNID=RN0. SN0 sends a Data Response packet back to HN0. The packet header is TgtID=RN0, SrcID=SN0, HomeNID=HN0, RDATA. HN0 sends a Response packet back to RN0. The packet header is TgtID=HN0, SrcID=RN0, RSP.](9f569eab9ce02335e1539153bbfc4b9b_img.jpg)

Figure 3-1: Target ID assignment without remapping. The diagram shows three nodes: RN0 (Requester Node), HN0 (Home Node), and SN0 (Subordinate Node). RN0 sends a Request packet to HN0. The packet header is TgtID=HN0, SrcID=RN0. HN0 sends a Return Request packet to SN0. The packet header is TgtID=SN0, SrcID=HN0, ReturnNID=RN0. SN0 sends a Data Response packet back to HN0. The packet header is TgtID=RN0, SrcID=SN0, HomeNID=HN0, RDATA. HN0 sends a Response packet back to RN0. The packet header is TgtID=HN0, SrcID=RN0, RSP.

Figure 3-1 Target ID assignment without remapping

1. RN0 sends a request with Target ID of HN0 using the SAM internal to RN0.
   - The interconnect does not remap the node ID.
2. HN0 looks up an internal SAM to determine the target Subordinate Node.
3. SN0 receives the request and sends a data response.
   - The data response packet has the TgtID derived from the requests ReturnNID.
4. RN0 receives the data response from SN0.
5. RN0 sends, if necessary, a CompAck with TgtID of HN0 derived from the HomeNID in the data response packet to complete the transaction.

### 3.4.2 Flow with interconnect-based SAM

Figure 3-2 shows a case where remapping of the target ID occurs in the interconnect.

Note

Only the target ID of the request from the Request Node is remapped. The TgtID in all other packets in the transaction flow is determined in a similar manner to *Simple flow* on page 3-155.

![](a0ef559f2bd4147ec203cff042d7369a_img.jpg)

Diagram illustrating the flow of a request and response packet between Request Node (RN0), Remap Node (HN1), and Service Node (SN0), showing Target ID (TgtID) and Source ID (SrcID) assignments.

**Request Flow (RN0 to SN0):**

- From RN0 (Dec): TgtID=HN0, SrcID=RN0. Packet: Req.
- Through Remap Node (Remap Dec): TgtID=HN1, SrcID=RN0. Packet: Req.
- From HN1 (Dec): TgtID=SN0, SrcID=HN1, ReturnNID=RN0. Packet: Req.
- To SN0 (Dec): TgtID=RN0, SrcID=SN0, HomeNID=HN1. Packet: RDATA.

**Response Flow (SN0 to RN0):**

- From SN0 (Dec): TgtID=HN1, SrcID=RN0. Packet: -Resp.

Figure 3-2 Target ID assignment with remapping logic

### 3.4.3 Flow with interconnect based SAM and Retry request

Figure 3-3 shows a case of a request getting retried.

![](240318eb53e18366b06354b765508a8f_img.jpg)

Diagram illustrating the flow of a request involving remapping of TgtID and a retry mechanism.

The flow involves three main entities: RN0 (Requester), HN1 (Home Node), and SN0 (Source Node).

**Initial Request Flow:**

- Initial target: RN0 sends a request (Req) to HN1. The request is labeled TgtID=HN0, SrcID=RN0.
- Remapping: HN1 processes the request using a Remap Dec (Dec) block. The request is remapped to TgtID=HN1, SrcID=RN0.
- Request to SN0: HN1 sends the remapped request (Req) to SN0. The request is labeled TgtID=HN1, SrcID=RN0.

**Retry Flow:**

- SN0 sends a RetryAck response (dashed line) back to HN1. The response is labeled TgtID=RN0, SrcID=HN1.
- SN0 sends a PCrdGrant response (dashed line) back to HN1. The response is labeled TgtID=RN0, SrcID=HN1.
- Request Resend: HN1 sends a new request (Req) to RN0. The request is labeled TgtID=HN1, SrcID=RN0.

**Final Request Flow:**

- Request to SN0: RN0 sends a request (Req) to SN0. The request is labeled TgtID=SN0, SrcID=HN1, ReturnNID=RN0.
- Response from SN0: SN0 sends an RDATA response (dashed line) back to RN0. The response is labeled TgtID=RN0, SrcID=SN0, HomeNID=HN1.
- Response from HN1: HN1 sends a response (Resp, dashed line) back to RN0. The response is labeled TgtID=HN1, SrcID=RN0.

Figure 3-3 Remapping of TgtID and retried request

1. The interconnect remaps the TgtID provided by RN0 to HN1.
2. The request receives a RetryAck response.
   - The RetryAck and PCrdGrant responses get the TgtID information from the SrcID in the received request.
3. RN0 resends the request once both RetryAck and PCrdGrant responses are received.
   - The TgtID in the retried request is the same as the SrcID in the received RetryAck or the TgtID in the original request. The TgtID must pass through the remapping logic again.
4. The packets in the rest of the transaction flow get the TgtID in a similar manner to *Flow with interconnect-based SAM* on page 3-156.



# Chapter 4Coherence Protocol

This chapter describes the coherence protocol and contains the following sections:

- *Cache line states* on page 4-160
- *Request types* on page 4-162
- *Snoop request types* on page 4-191
- *Request transactions and corresponding Snoop requests* on page 4-194
- *Response types* on page 4-197
- *Silent cache state transitions* on page 4-209
- *Cache state transitions at a Requester* on page 4-210
- *Cache state transitions at a Snoopee* on page 4-221
- *Returning Data with Snoop response* on page 4-240
- *Do not transition to SD* on page 4-241
- *Hazard conditions* on page 4-242

## 4.1 Cache line states

The action required when a protocol node accesses a cache line is determined by the cache line state. The protocol defines the following cache line states:

**I** Invalid:

- The cache line is not present in the cache.

**UC** Unique Clean:

- The cache line is present only in this cache.
- The cache line has not been modified with respect to memory.
- The cache line can be modified without notifying other caches.
- In response to a snoop that requests data, the cache line is permitted, but not required to be:
  - Returned to Home when requested.
  - Forwarded directly to the Requester when instructed by the snoop.

**UCE** Unique Clean Empty:

- The cache line is present only in this cache.
- The cache line is in a unique state but none of the data bytes are valid.
- The cache line can be modified without notifying other caches.
- In response to a snoop that requests data, the cache line must not be:
  - Returned to Home even when requested.
  - Forwarded directly to the Requester even when instructed by the snoop.

**UD** Unique Dirty:

- The cache line is present only in this cache.
- The cache line has been modified with respect to memory.
- The cache line must be written back to next level cache or memory on eviction.
- The cache line can be modified without notifying other caches.
- In response to a snoop that requests data, the cache line:
  - Must be returned to Home when requested.
  - Is expected to be forwarded directly to the Requester when instructed by the snoop.

**UDP** Unique Dirty Partial:

- The cache line is present only in this cache.
- The cache line is unique. The cache line might have some bytes valid, where some includes none or all bytes.
- The cache line has been modified with respect to memory.
- When the cache line is evicted, it must be merged with data from next level cache or memory to form the complete valid cache line.
- The cache line can be modified without notifying other caches.
- In response to a snoop that requests data, the cache line must:
  - Be returned to Home.
  - Not be forwarded directly to the Requester even when instructed by the snoop.

**SC** Shared Clean:

- Other caches might have a shared copy of the cache line.
- The cache line might have been modified with respect to memory.
- It is not the responsibility of this cache to write the cache line back to memory on eviction.
- The cache line cannot be modified without invalidating any shared copies and obtaining unique ownership of the cache line.
- In response to a snoop that requests data, the cache line:
  - Is required to not return data if RefToSrc bit is not set.
  - Is expected to return data if RefToSrc bit is set.
  - Is expected to be forwarded directly to the Requester when instructed by the snoop.

**SD** Shared Dirty:

- Other caches might have a shared copy of the cache line.
- The cache line has been modified with respect to memory.
- The cache line must be written back to next level cache or memory on eviction.
- The cache line cannot be modified without invalidating any shared copies and obtaining unique ownership of the cache line.
- In response to a snoop that requests data, the cache line:
  - Must be returned to Home when requested.
  - Is expected to be forwarded directly to the Requester when instructed by the snoop.

A cache is permitted to implement a subset of these states.

### 4.1.1 Empty cache line ownership

An empty cache line is a cache line that is held in a Unique state to prevent other copies of the cache line existing. None of the data bytes are valid in an empty cache line. This cache line state is UCE or UDP.

The following are examples of when empty cache line ownership can occur:

- A Requester can deliberately obtain an empty cache line before starting a write, to save system bandwidth. A Requester that expects to write to a cache line can obtain an empty cache line with permission to store, instead of obtaining a valid copy of the cache line.
- A Requester can transition into an empty state if the Requester has a copy of the cache line when it requests permission to store. That copy of the cache line is invalidated before the Requester obtains permission to store. At the completion of the request, this results in the Requester having an empty cache line with permission to store.

### 4.1.2 Ownership of cache line with partial Dirty data

Once ownership of a cache line without data is obtained, the Requester is permitted to store to the cache line. If the Requester modifies part of the cache line, the cache line remains partially Unique Dirty. This cache line state is UDP.

## 4.2 Request types

Protocol requests are categorized as follows:

- For Read request transactions, a data response is provided to the Requester.
- For Dataless request transactions, no data response is provided to the Requester.
- For Write request transactions, data is moved from the Requester.
- For Combined Write request transactions, data is moved from the Requester and a cache maintenance operation is performed.
- For Atomic request transactions, data is moved from the Requester and a data response is provided to the Requester in some request types.
- For Stash request transactions, data can be moved within a system to improve performance.
- Other request transactions:
  - Do not involve any data movement in the system.
  - Can be used to assist with DVM maintenance.
  - Can be used to warm the memory controller for a following read request.

The following subsections enumerate the resulting transactions and their characteristics. See [Chapter 12 Memory Tagging](#) for a description of the Memory Tagging mechanism. See [Table 12-2 on page 12-388](#) for information on the permitted MTE TagOp values for each request. See [Request communicating nodes on page B-492](#) for information on Request communicating nodes.

###### Note

It is legal for any transaction that is expected to target an HN-F, but not an HN-I, to target an HN-I. This can occur for an incorrect assignment of memory type for a transaction. It is required that the HN-I responds to such a transaction in a protocol-compliant manner.

### 4.2.1 Read transactions

Read transactions have the following common characteristics:

- Data must be included in the completion response to the Requester, except for MakeReadUnique request. For MakeReadUnique, a data response is optional.
- When Data response is provided, the transferred data can be from the Home Node, another Request Node, or a Subordinate Node.
- In Allocating Read transactions, received data, if cached, must be cached in a system coherent manner.
- In Non-allocating Read transactions, that is, ReadNoSnp and ReadOnce\*, received data is not expected to be cached, but if cached, data is not cached in a system coherent manner.
- The request can result in a cache state change at the Requester. See [Table 4-4 on page 4-167](#) for expected and permitted initial cache and [Table 4-5 on page 4-167](#) for final cache state at the Requester for each of the Read transactions.
- The request can result in a cache state change at other Request Nodes in the system. See [Table 4-6 on page 4-168](#) for expected and permitted cache states at the peer Request Nodes for each of the Read transactions.

See [Chapter 6 Exclusive accesses](#) for details on Exclusive attribute in read transactions.

#### ReadNoSnp

Read request by a Request Node to a Non-snoopable address region, or from a Home Node to any address region to obtain a copy of the addressed data. See [Table 2-6 on page 2-48](#) for use DMT, Order field, and ExpCompAck values.

#### ReadNoSnpSep

Read request from a Home Node to Subordinate Node, requesting the Completer to send only a data response. Used when separate completion and data responses are used to complete the read transaction.

#### ReadOnce

Read request to a Snoopable address region to obtain a snapshot of the coherent data.

#### ReadOnceCleanInvalid

Read request to a Snoopable address region to obtain a snapshot of the coherent data. It is recommended, but not required, that other cached copies of the cache line are invalidated. If a Dirty copy is invalidated, it must be written back to memory.

###### Note

ReadOnceCleanInvalid is used instead of ReadOnce or ReadOnceMakeInvalid where the application determines that the data is still Valid, but will not be used in the near future. Use of ReadOnceCleanInvalid by an application improves cache efficiency by reducing cache pollution.

The following should be considered when using ReadOnceCleanInvalid:

- The invalidation in the ReadOnceCleanInvalid transaction is a hint. Completion of the transaction does not guarantee removal of all cached copies, therefore it cannot be used as a replacement for a CMO.
- Use of the transaction can cause the deallocation of a cache line and therefore caution is needed if the transaction could target the same cache line that other agents in the system are using for Exclusive accesses.

#### ReadOnceMakeInvalid

Read request to a Snoopable address region to obtain a snapshot of the coherent data. It is recommended, but not required, that all snooped cached copies are invalidated. If a Dirty copy is invalidated, it does not need to be written back to memory.

###### — Note —

ReadOnceMakeInvalid is used in preference to ReadOnce or ReadOnceCleanInvalid to obtain a snapshot of a data value when the application determines that the cached data is not going to be used again.

The application can free up the caches and also, by discarding Dirty data, avoid an unnecessary WriteBack to memory.

The following should be considered when using ReadOnceMakeInvalid:

- The invalidation in the ReadOnceMakeInvalid transaction is a hint. Completion of the transaction does not guarantee removal of all cached copies, therefore it cannot be used as a replacement for a CMO.
- Use of the transaction can cause the deallocation of a cache line and therefore caution is needed if the transactions could target the same cache line that other agents in the system are using for Exclusive accesses.
- The use of the ReadOnceMakeInvalid transaction can cause the loss of a Dirty cache line. Use of this transaction must be strictly limited to scenarios where it is known that the loss of a Dirty cache line is harmless.
- For a ReadOnceMakeInvalid transaction, it is required that the invalidation of the cache line is committed before the read data response for the transaction. The invalidation of the cache line is not required to have completed at this point, but it must be ensured that any later Write transaction from any agent, which starts after this point, is guaranteed not to be invalidated by this transaction.

#### ReadClean

Read request to a Snoopable address region:

- Data must be provided to the Requester in a clean state only:
  - UC, or SC

#### ReadNotSharedDirty

Read request to a Snoopable address region to carry out a load from the cache line:

- ReadNotSharedDirty is used instead of ReadShared when the Requester cannot accept data in SD state.
- Requester will accept the data in any valid state except SD:
  - UC, UD, or SC

#### ReadShared

Read request to a Snoopable address region to carry out a load from the cache line:

- ReadShared is used instead of ReadNotSharedDirty when the Requester is willing to accept data in the SD state.
- Requester will accept the data in any valid state:
  - UC, UD, SC, or SD

#### ReadUnique

Read request to a Snoopable address region to carry out a store to the cache line:

- Data must be provided to the Requester in unique state only:
  - UC, or UD

#### ReadPreferUnique

Read request to a Snoopable address region requesting a unique copy of a cache line.

ReadPreferUnique is used when the Requester prefers, but does not require, the data to be returned in Unique state:

- Data is provided in Unique state unless another Request Node is currently performing an exclusive sequence using the same address. In which case the data is provided in Shared state.

- It is permitted to always provide the data in Shared state to the Requester.

###### — Note —

This request is included in this specification to improve the execution efficiency of an exclusive sequence.

**MakeReadUnique** Read request to a Snoopable address region requesting a unique copy of a cache line. Typical usage is when the Requester has a shared copy of the cache line and wants to obtain permission to store to the cache line.

###### — Note —

Because data return is guaranteed if the Requester receives an Invalidating snoop and retention of data is required otherwise, resending a request to obtain a Unique copy of the cache line is never required.

#### Read request attribute values

This section discusses the attribute values for Read requests across node interfaces.

See [Appendix A Message Field Mappings](#) for complete list.

Table 4-1 lists permitted values for the key attributes in Read requests for Request Node to Home Node.

Table 4-1 RN to HN Read request permitted attribute values

| Request              | Size (bytes) | Excl | SnpAttr | MemAttr<br>A C D E | Order    | LikelyShared | ExpCompAck |
|----------------------|--------------|------|---------|--------------------|----------|--------------|------------|
| ReadNoSnp            | <=64         | 0,1  | 0       | 0010               | 11       | 0            | 0,1        |
|                      |              |      |         | 0011               | 00,10,11 | 0            | 0,1        |
|                      |              |      |         | 0000               | 00,10    | 0            | 0,1        |
|                      |              |      |         | 0001               |          |              |            |
|                      |              |      |         | 0101               |          |              |            |
| ReadOnce             | 64           | 0    | 1       | 0101               | 00,10    | 0            | 0,1        |
| ReadOnceCleanInvalid |              |      |         | 1101               |          |              |            |
| ReadOnceMakeInvalid  | 64           | 0    | 1       | 0101               | 00,10    | 0            | 0,1        |
| ReadClean            | 64           | 0,1  | 1       | 0101               | 00       | 0,1          | 1          |
| ReadNotSharedDirty   |              |      |         | 1101               |          |              |            |
| ReadShared           |              |      |         |                    |          |              |            |
| ReadUnique           | 64           | 0    | 1       | 0101               | 00       | 0            | 1          |
|                      |              |      |         | 1101               |          |              |            |
| ReadPreferUnique     | 64           | 0,1  | 1       | 0101               | 00       | 0            | 1          |
| MakePreferUnique     |              |      |         | 1101               |          |              |            |

Table 4-2 lists the permitted values for the key attributes in Read requests for HN-F to SN-F.

Table 4-2 HN-F to SN-F Read request permitted attribute values

| Request      | Size (bytes) | Excl | SnPAttr | MemAttr<br>A C D E | Order | LikelyShared | ExpCompAck |
|--------------|--------------|------|---------|--------------------|-------|--------------|------------|
| ReadNoSnP    | <=64         | 0,1  | 0       | 0000               | 00,01 | 0            | 0          |
|              |              |      |         | 0001               |       |              |            |
|              |              |      |         | 0101               |       |              |            |
|              |              |      |         | 1101               |       |              |            |
| ReadNoSnPSep | <=64         | 0    | 0       | 0000               | 00,01 | 0            | 0          |
|              |              |      |         | 0001               |       |              |            |
|              |              |      |         | 0101               |       |              |            |
|              |              |      |         | 1101               |       |              |            |

Table 4-3 lists the permitted values for the key attributes in Read requests for HN-I to SN-I.

Table 4-3 HN-I to SN-I Read request permitted attribute values

| Request      | Size (bytes) | Excl | SnPAttr | MemAttr<br>A C D E | Order       | LikelyShared | ExpCompAck |
|--------------|--------------|------|---------|--------------------|-------------|--------------|------------|
| ReadNoSnP    | <=64         | 0,1  | 0       | 0010               | 11          | 0            | 0          |
|              |              |      |         | 0011               | 00,01,10,11 | 0            | 0          |
|              |              |      |         | 0000               | 00,01,10    | 0            | 0          |
|              |              |      |         | 0001               |             |              |            |
|              |              |      |         | 0101               |             |              |            |
|              |              |      |         | 1101               |             |              |            |
| ReadNoSnPSep | <=64         | 0    | 0       | 0010               | 11          | 0            | 0          |
|              |              |      |         | 0011               | 00,01,10,11 | 0            | 0          |
|              |              |      |         | 0000               | 00,01,10    | 0            | 0          |
|              |              |      |         | 0001               |             |              |            |
|              |              |      |         | 0101               |             |              |            |
|              |              |      |         | 1101               |             |              |            |

##### **Initial cache state at the Requester**

Table 4-4 lists the permitted Requester cache states when a Request is sent. The following key is used for Table 4-4 and Table 4-5:

| Y   | Yes, permitted |
|-----|----------------|
| -   | Not permitted  |
| n/a | Not applicable |

**Table 4-4 Permitted Requester cache state at the sending of Read request**

| Request                                   | Initial state |    |    |    |   |     |     |  |
|-------------------------------------------|---------------|----|----|----|---|-----|-----|--|
|                                           | UD            | UC | SD | SC | I | UDP | UCE |  |
| ReadNoSnp                                 | -             | -  | -  | -  | Y | -   | -   |  |
| ReadOnce                                  | -             | -  | -  | -  | Y | -   | Y   |  |
| ReadOnceCleanInvalid, ReadOnceMakeInvalid | -             | -  | -  | -  | Y | -   | Y   |  |
| ReadClean                                 | Y             | Y  | Y  | Y  | Y | Y   | Y   |  |
| ReadNotSharedDirty                        | -             | -  | -  | -  | Y | -   | Y   |  |
| ReadShared                                | -             | -  | -  | -  | Y | -   | Y   |  |
| ReadUnique                                | Y             | Y  | Y  | Y  | Y | Y   | Y   |  |
| ReadPreferUnique                          | -             | -  | Y  | Y  | Y | -   | Y   |  |
| MakeReadUnique                            | -             | -  | Y  | Y  | - | -   | -   |  |

##### **Final cache state at the Requester**

Table 4-5 lists the permitted cache state at the Requester at the completion of the transaction.

**Table 4-5 Permitted final Requester cache state**

| Request                                   | Final state |    |    |    |   |     |     |  |
|-------------------------------------------|-------------|----|----|----|---|-----|-----|--|
|                                           | UD          | UC | SD | SC | I | UDP | UCE |  |
| ReadNoSnp                                 | -           | -  | -  | -  | Y | -   | -   |  |
| ReadOnce                                  | -           | -  | -  | -  | Y | -   | -   |  |
| ReadOnceCleanInvalid, ReadOnceMakeInvalid | -           | -  | -  | -  | Y | -   | -   |  |
| ReadClean                                 | -           | Y  | -  | Y  | - | -   | -   |  |
| ReadNotSharedDirty                        | Y           | Y  | -  | Y  | - | -   | -   |  |
| ReadShared                                | Y           | Y  | Y  | Y  | - | -   | -   |  |
| ReadUnique                                | Y           | Y  | -  | -  | - | -   | -   |  |
| ReadPreferUnique                          | Y           | Y  | Y  | Y  | - | -   | -   |  |
| MakeReadUnique(non-Excl)                  | Y           | Y  | -  | -  | - | -   | -   |  |
| MakeReadUnique(Excl)                      | Y           | Y  | Y  | Y  | - | -   | -   |  |

##### Peer cache state

Table 4-6 lists the permitted cache state at the peer Request Nodes at the completion of the transaction.

In response to a request, the Home must send the appropriate Snoops to ensure cached lines at the peer caches are either an expected or permitted final state.

Table 4-6 Permitted peer cache state at the completion of a request

| Request                                      | Peer final state |     |     |     |     |     |     |          |
|----------------------------------------------|------------------|-----|-----|-----|-----|-----|-----|----------|
|                                              | UD               | UC  | SD  | SC  | I   | UDP | UCE | NoChange |
| ReadNoSnp                                    | n/a              | n/a | n/a | n/a | n/a | n/a | n/a | n/a      |
| ReadOnce                                     | Y                | Y   | Y   | Y   | Y   | Y   | Y   | Y        |
| ReadOnceCleanInvalid,<br>ReadOnceMakeInvalid | Y                | Y   | Y   | Y   | Y   | Y   | Y   | Y        |
| ReadClean                                    | -                | -   | Y   | Y   | Y   | -   | -   | -        |
| ReadNotSharedDirty                           | -                | -   | Y   | Y   | Y   | -   | -   | -        |
| ReadShared                                   | -                | -   | Y   | Y   | Y   | -   | -   | -        |
| ReadUnique                                   | -                | -   | -   | -   | Y   | -   | -   | -        |
| ReadPreferUnique                             | -                | -   | Y   | Y   | Y   | -   | -   | -        |
| MakeReadUnique <sup>a</sup>                  | -                | -   | -   | -   | Y   | -   | -   | -        |

a. For MakeReadUnique(Excl), it is possible that peer caches are not required to change state.

### 4.2.2 Dataless transactions

Request Nodes use Dataless transactions to perform coherent actions without the transfer of data from or to the Requester. The Dataless transactions, grouped for their common functionality, are:

- CleanUnique, MakeUnique
- Evict
- Independent Stash transactions
  - StashOnceUnique, StashOnceSepUnique, StashOnceShared, StashOnceSepShared
- Cache Maintenance transactions
  - CleanShared, CleanSharedPersist, CleanSharedPersistSep, CleanInvalid, MakeInvalid

Dataless transactions have the following common characteristics:

- Data must not be included in the completion response.
- The Request can result in data movement among other agents in the system.
- The Request can result in a cache state change at the Requester.

See [Table 4-10 on page 4-174](#) for expected and permitted initial cache and [Table 4-11 on page 4-174](#) for final cache state at the Requester for each of the Dataless transactions.

- The Request can result in a cache state change at the other Request Nodes in the system.

See [Table 4-12 on page 4-175](#) for expected and permitted cache states at the peer Request Nodes for each of the Dataless transactions.

See [Chapter 6 Exclusive accesses](#) for details on Exclusive attribute in Dataless transactions.

#### CleanUnique

Request to a Snoopable address region to change the cache state at the Requester to Unique to carry out a store to the cache line. Typical usage is when the Requester has a shared copy of the cache line and wants to obtain permission to store to the cache line. Any dirty copy of the cache line at a snooped cache must be written back to the memory.

#### MakeUnique

Request to a Snoopable address region to obtain ownership of the cache line without a data response. This request is used only when the Requester guarantees that it will carry out a store to all bytes of the cache line. Any dirty copy of the cache line at a snooped cache must be invalidated without carrying out a data transfer.

#### Evict

Used to indicate that a Clean cache line is no longer cached by the Request Node.

#### StashOnceUnique, StashOnceSepUnique

Request to a Snoopable address region to attempt to move the addressed cache line to a targeted cache to enable the target to store that line. The request includes:

- A valid Node ID of another Request Node as the Stash target, along with an optional ID of a Logical Processor within that node. When a valid target is not specified, the addressed cache line can be fetched to be cached at the request Completer.
- It is recommended, but not required, that the other agent is snooped to indicate that it obtains the addressed cache line and ensures that it is in a cache state suitable for writing to the cache line.
- The Data Pull request from the target Request Node is treated as a ReadUnique Request.

See [Chapter 7 Cache Stashing](#).

#### StashOnceShared, StashOnceSepShared

Request to a Snoopable address region to attempt to move the addressed cache line to a targeted cache. The request includes:

- The Node ID of another Request Node. Optionally, the request can include the ID of a Logical Processor within that node. When a valid target is not specified, the addressed cache line can be fetched to be cached at the request Completer.
- It is recommended, but not required, that the other agent is snooped to indicate that it obtains the addressed cache line.
- The Data Pull request from the target Request Node is treated as ReadNotSharedDirty.

See [Chapter 7 Cache Stashing](#).

#### Cache Maintenance transactions

A *Cache Maintenance Operation* (CMO) assists with software cache management. The protocol includes the following five transactions to support a Cache Maintenance Operation:

##### CleanShared

The completion response to a CleanShared request ensures that all cached copies are changed to a Non-dirty state and any Dirty copy is written back to memory.

##### CleanSharedPersist

The completion response to a CleanSharedPersist request ensures that all cached copies are changed to a Non-dirty state and any Dirty cached copy is written back to the *Point of Persistence* (PoP) or final destination.

##### CleanSharedPersistSep

The Persist or combined CompPersist completion response to a CleanSharedPersistSep request ensures that all cached copies are changed to a Non-dirty state and any Dirty cached copy is written back to the *Point of Persistence* (PoP), or final destination.

Functionality of CleanSharedPersistSep is similar to CleanSharedPersist but allows two separate responses to the Requester.

It is expected, but not required, that a Requester, when sending a persistent CMO, uses a CleanSharedPersistSep transaction instead of CleanSharedPersist.

Such a Requester must support receiving both separate Comp and Persist responses and a combined CompPersist response.

##### CleanInvalid

The completion response to a CleanInvalid request ensures that all cached copies are invalidated. The request requires that any cached Dirty copies must be written to memory.

##### MakeInvalid

The completion response to a MakeInvalid request ensures that all cached copies are invalidated. The request permits that any cached Dirty copies are discarded.

The following characteristics are common to all five CMO transactions:

- The Resp field value in the Comp, indicating cache state, must be ignored by both the Requester and the Home.
- Sending of a CMO transaction to the interconnect from an RN and from the interconnect to an SN is controlled by the **BROADCASTPERSIST (BP)** and **BROADCASTCACHEMAINTENANCE (BCM)** interface signals. See [Optional interface broadcast signals on page 16-474](#).

###### — Note —

Permitting Cache Maintenance Operations to be forwarded downstream of the Home Node incorporates system topologies where some observers might directly access locations downstream of the Home Node and software cache maintenance is required to make cached data visible to such observers.

- Cachable and SnpAttr bit values must be observed.
- MemAttr values on a request received at Home must be preserved when the request is propagated to the Subordinate, except when it is known that the Subordinate has only Normal memory, in which case the MemAttr bit Device can be set to Normal.
- Order field must not be asserted:
  - A CMO intended for a particular address must not be sent to the interconnect before all previous transactions sent to the same address that can allocate the data in the Requester caches have completed.
  - A transaction intended for a particular address that can allocate data in Requester caches must not be sent to the interconnect before a previous CMO sent to the same address has completed.
  - A Completer is permitted, but not required, to wait for WriteData to send a Persist response. Examples of when a Completer can send an early Persist is when the Completer does not support Persistence on that memory location or the request encounters a Non-data Error.
- A CMO is permitted to be combined with a Write transaction to the same address when the write is ahead of the CMO. See *Combined Write requests on page 4-182*.

#### Persistent CMO handling at Home

This section discusses the *Point of Persistence* (PoP) at the Home and downstream of the Home. This section also introduces Deep attribute in Persistent CMO.

##### Point of Persistence at Home

If the Home is the PoP, then for CleanSharedPersistSep:

- The Home is permitted to not forward the CleanSharedPersistSep request to the Subordinate. When the Home decides not to forward the CleanSharedPersistSep request, it must return a Persist response to the Requester.
- When the Home sends a Persist response, it is permitted, but not required, to combine it with Comp and return a single CompPersist response to the Requester.

##### Point of Persistence downstream of Home

If the PoP is downstream of the Home, then for CleanSharedPersistSep:

- The Home must send the request downstream.
- The Subordinate Node must return a Comp response only after it guarantees that it has accepted the request and will not return a RetryAck response.
- The Subordinate Node must also return a Persist response to either the Requester or the Home when it can guarantee that all previous writes to the same address, to non-volatile memory, have been made persistent. The address location will also contain the updated value even after the removal of power.
- The Home receives a Persist response from downstream, then it must forward the Persist response to the Requester:
  - The Subordinate is permitted to return a combined CompPersist response to the Home.
  - The Home is permitted, but not expected, to wait for the Persist response from the Subordinate and then return a combined CompPersist response to the Requester instead of returning an earlier separate Comp response.
- If the target is volatile memory, then the Persist response can be given immediately. Such a situation must not return an error.

##### Deep Persistent CMO

Systems with non-volatile memory to meet high availability expectations require guarantees that operation critical data is preserved on back-up battery failure as well as on power failure. The guarantee can be provided by a system by adding a mechanism to push previous writes to the Point of Deep Persistence. This specification supports this feature using an attribute, called Deep, on Persistent CMO transactions.

If the Completer of the request with Deep asserted does not support the Deep attribute, the Completer can ignore the attribute value and treat the request as having the Deep attribute deasserted. An error response must not be given to indicate that Deep persistence is not supported. See *Deep persistence, Deep* on page 13-426.

#### Dataless request attribute values

This section discusses the attribute values for Dataless requests across node interfaces.

See *Appendix A Message Field Mappings* for complete list.

Table 4-7 lists the values permitted for key attributes in Dataless requests from Request Node to Home Node.

Table 4-7 RN to HN Dataless request permitted attribute values

| Request               | Size (bytes) | Excl | SnPAttr | MemAttr<br>A C D E                           | Order           | LikelyShared | ExpCompAck |
|-----------------------|--------------|------|---------|----------------------------------------------|-----------------|--------------|------------|
| CleanUnique           | 64           | 0,1  | 1       | 0101<br>1101                                 | 00              | 0            | 1          |
| MakeUnique            | 64           | 0    | 1       | 0101<br>1101                                 | 00              | 0            | 1          |
| Evict                 | 64           | 0    | 1       | 0101                                         | 00              | 0            | 0          |
| StashOnceUnique       | 64           | 0    | 1       | 0101                                         | 00              | 0,1          | 0          |
| StashOnceSepUnique    |              |      |         | 1101                                         |                 |              |            |
| StashOnceShared       |              |      |         |                                              |                 |              |            |
| StashOnceSepShared    |              |      |         |                                              |                 |              |            |
| CleanShared           | 64           | 0    | 1       | 0101<br>1101                                 | 00 <sup>a</sup> | 0            | 0          |
| CleanSharedPersist    |              |      |         |                                              |                 |              |            |
| CleanSharedPersistSep |              |      |         |                                              |                 |              |            |
| CleanInvalid          |              | 0    | 0       | 0010<br>0011<br>0000<br>0001<br>0101<br>1101 | 00 <sup>a</sup> | 0            | 0          |
| MakeInvalid           |              |      |         |                                              |                 |              |            |

a. The field is inapplicable and must be set to zero.

Table 4-8 lists the values permitted for key attributes in Dataless requests from HN-F to SN-F.

Table 4-8 HN-F to SN-F Dataless request permitted attribute values

| Request               | Size (bytes) | Excl | SnpAttr | MemAttr A C D E | Order           | LikelyShared | ExpCompAck |
|-----------------------|--------------|------|---------|-----------------|-----------------|--------------|------------|
| CleanShared           | 64           | 0    | 0       | 0000            | 00 <sup>a</sup> | 0            | 0          |
| CleanSharedPersist    |              |      |         | 0001            |                 |              |            |
| CleanSharedPersistSep |              |      |         | 0101            |                 |              |            |
| CleanInvalid          |              |      |         | 1101            |                 |              |            |
| MakeInvalid           |              |      |         |                 |                 |              |            |

a. The field is inapplicable and must be set to zero.

Table 4-9 lists the values permitted for key attributes in Dataless requests from HN-I to SN-I.

Table 4-9 HN-I to SN-I Dataless request permitted attribute values

| Request               | Size (bytes) | Excl | SnpAttr | MemAttr A C D E | Order           | LikelyShared | ExpCompAck |
|-----------------------|--------------|------|---------|-----------------|-----------------|--------------|------------|
| CleanShared           | 64           | 0    | 0       | 0010            | 00 <sup>a</sup> | 0            | 0          |
| CleanSharedPersist    |              |      |         | 0011            |                 |              |            |
| CleanSharedPersistSep |              |      |         | 0000            |                 |              |            |
| CleanInvalid          |              |      |         | 0001            |                 |              |            |
| MakeInvalid           |              |      |         | 0101            |                 |              |            |
|                       |              |      |         | 1101            |                 |              |            |

a. The field is inapplicable and must be set to zero.

##### Initial cache state at the Requester

Table 4-10 lists the permitted Requester cache states when a request is sent. The following key is used for Table 4-10, Table 4-11, and Table 4-12 on page 4-175:

| Y | Yes, permitted |
|---|----------------|
| - | Not permitted  |

Table 4-10 Permitted Requester cache state at the sending of Dataless request

| Request               | Initial state |    |    |    |   |     |     |
|-----------------------|---------------|----|----|----|---|-----|-----|
|                       | UD            | UC | SD | SC | I | UDP | UCE |
| CleanUnique           | Y             | Y  | Y  | Y  | Y | -   | Y   |
| MakeUnique            | -             | Y  | Y  | Y  | Y | -   | Y   |
| Evict                 | -             | -  | -  | -  | Y | -   | -   |
| StashOnceUnique       | -             | -  | -  | -  | Y | -   | -   |
| StashOnceSepUnique    | -             | -  | -  | -  | Y | -   | -   |
| StashOnceShared       | -             | -  | -  | -  | Y | -   | -   |
| StashOnceSepUnique    | -             | -  | -  | -  | Y | -   | -   |
| CleanShared           | -             | Y  | -  | Y  | Y | -   | -   |
| CleanSharedPersist    | -             | Y  | -  | Y  | Y | -   | -   |
| CleanSharedPersistSep | -             | Y  | -  | Y  | Y | -   | -   |
| CleanInvalid          | -             | -  | -  | -  | Y | -   | -   |
| MakeInvalid           | -             | -  | -  | -  | Y | -   | -   |

##### Cache states for Dataless transactions

This section describes *Final cache state at the Requester* and *Peer cache state* on page 4-175 at the completion of a Dataless transaction.

##### Final cache state at the Requester

Table 4-11 lists the permitted cache state at the Requester at the completion of the transaction.

Table 4-11 Permitted final Requester cache state

| Request            | Final state |    |    |    |   |     |     |
|--------------------|-------------|----|----|----|---|-----|-----|
|                    | UD          | UC | SD | SC | I | UDP | UCE |
| CleanUnique        | Y           | Y  | -  | -  | - | -   | Y   |
| MakeUnique         | Y           | -  | -  | -  | - | -   | -   |
| Evict              | -           | -  | -  | -  | Y | -   | -   |
| StashOnceUnique    | -           | -  | -  | -  | Y | -   | -   |
| StashOnceSepUnique | -           | -  | -  | -  | Y | -   | -   |
| StashOnceShared    | -           | -  | -  | -  | Y | -   | -   |
| StashOnceSepUnique | -           | -  | -  | -  | Y | -   | -   |

Table 4-11 Permitted final Requester cache state (continued)

| Request               | Final state |    |    |    |   |     |     |
|-----------------------|-------------|----|----|----|---|-----|-----|
|                       | UD          | UC | SD | SC | I | UDP | UCE |
| CleanShared           | -           | Y  | -  | Y  | Y | -   | -   |
| CleanSharedPersist    |             |    |    |    |   |     |     |
| CleanSharedPersistSep |             |    |    |    |   |     |     |
| CleanInvalid          | -           | -  | -  | -  | Y | -   | -   |
| MakeInvalid           | -           | -  | -  | -  | Y | -   | -   |

##### Peer cache state

Table 4-12 lists the expected and permitted cache state at the peer Request Node at the completion of the Dataless transaction. In response to a request, the Home must send appropriate snoop to transition cached line at the peer caches to either expected or permitted final states.

Table 4-12 Permitted peer cache state at the completion of a request

| Request               | Peer final state |    |    |    |   |     |     |          |
|-----------------------|------------------|----|----|----|---|-----|-----|----------|
|                       | UD               | UC | SD | SC | I | UDP | UCE | NoChange |
| CleanUnique           | -                | -  | -  | -  | Y | -   | -   | -        |
| MakeUnique            | -                | -  | -  | -  | Y | -   | -   | -        |
| CleanShared           | -                | Y  | -  | Y  | Y | -   | -   | -        |
| CleanSharedPersist    |                  |    |    |    |   |     |     |          |
| CleanSharedPersistSep |                  |    |    |    |   |     |     |          |
| CleanInvalid          | -                | -  | -  | -  | Y | -   | -   | -        |
| MakeInvalid           | -                | -  | -  | -  | Y | -   | -   | -        |

The Peer Request Node cache state at the completion of Evict, StashOnceUnique, StashOnceSepUnique, StashOnceShared, and StashOnceSepShared is not applicable.

### 4.2.3 Write transactions

Write transactions move data from a Requester to a Completer, this might be the next level cache, memory, or a peripheral. The data being transferred, depending on the transaction type, can be coherent or non-coherent. Each write transaction must assert appropriate byte enables with the data.

#### Non-CopyBack transactions

Non-CopyBack transactions, also known as Immediate Write transactions, are a subclass of Write transactions. Non-CopyBack transactions transfer data from Request Nodes to Home Nodes without initially obtaining coherent ownership of the data. Non-CopyBack transactions are also used to transfer data from Home Nodes to Subordinate Nodes.

Each Non-CopyBack transaction must assert the appropriate byte enables with the data. Non-CopyBack transactions can require snooping of other agents in the system.

In Non-CopyBack requests, except WriteNoSnpZero and WriteUniqueZero, DWT flow between the Request Node and the Subordinate Node is permitted only when the original request from the Request Node does not use OWO.

DWT flow between a Request Node and a Subordinate Node in WriteNoSnpZero and WriteUniqueZero is never permitted.

##### WriteNoSnpFull

Write a full cache line of data from a Request Node to a Non-snoopable address region, or write for a full cache line of data to any address region from the Home to Subordinate.

- All byte enables must be asserted.

##### WriteNoSnpPtl

Write up to a cache line of data from a Request Node to a Non-snoopable address region, or write up to a cache line of data to any address region from the Home to Subordinate.

- Byte enables must be asserted for the appropriate byte lanes, including none or all, within the specified data size and deasserted in the rest of the data transfer.

##### WriteNoSnpZero

Write data value of zero without transferring data bytes from a Request Node to a Non-snoopable address region, or write data value of zero without transferring data bytes to any address region from Home to Subordinate.

##### WriteUniqueFull

Write to a Snoopable address region. Write a full cache line of data to the next-level cache or memory when the cache line is Invalid at the Requester.

- All byte enables must be asserted.

##### WriteUniquePtl

Write to a Snoopable address region. Write up to a cache line of data to the next-level cache or memory when the cache line is Invalid at the Requester.

- Byte enables must be asserted for the appropriate byte lanes within the specified data size and deasserted in the rest of the data transfer.

##### WriteUniqueZero

Write to a Snoopable address region. Write without data bytes when the data value is zero.

##### WriteUniqueFullStash

Write to a Snoopable address region. Write a full cache line of data to the next-level cache or memory when the cache line is Invalid at the Requester. Also includes a request to the Stash target node to obtain the addressed cache line.

- All byte enables must be asserted.

##### **WriteUniquePtlStash**

Write to a Snoopable address region. Write up to a cache line of data to the next-level cache or memory when the cache line is Invalid at the Requester. Also includes a request to the Stash target node to obtain the addressed cache line.

- Byte enables must be asserted for the appropriate byte lanes within the specified data size and deasserted in the remainder of the data transfer.

#### **CopyBack transactions**

CopyBack transactions are a subclass of Write transactions. CopyBack transactions move coherent data from a cache to the next level cache or memory. Each CopyBack transaction must assert the appropriate byte enables with the data. CopyBack transactions do not require the snooping of other agents in the system.

##### **WriteBackFull**

WriteBack a full cache line of Dirty data to the next level cache or memory. All byte enables must be asserted except when the write data is CopyBackWrData\_I.

##### **WriteBackPtl**

WriteBack up to a cache line of Dirty data to the next level cache or memory. All appropriate byte enables, up to all 64, including none or all, must be asserted.

##### **WriteCleanFull**

WriteBack a full cache line of Dirty data to the next level cache or memory and retain a Clean copy in the cache. All byte enables must be asserted except when the write data is CopyBackWrData\_I.

##### **WriteEvictFull**

WriteBack of UniqueClean data to the next-level cache.

- All byte enables must be asserted except when the write data is CopyBackWrData\_I.
- The cache line must not propagate beyond its Snoop domain.

##### **WriteEvictOrEvict**

WriteBack of Clean data to the next-level cache. This request type is merging of WriteEvictFull and Evict into one request. This allows the Home Node to determine if it is sent data.

- Data might not be sent if the Completer does not accept data.
- If data is sent, then the Data size is a cache line length.
- LikelyShared value indicates the initial state of the cache line when the request is sent:

| LikelyShared | Initial state |
|--------------|---------------|
| 0            | UC            |
| 1            | SC            |

- The cache line must not propagate beyond its Snoop domain.

#### **Write request attribute values**

This section discusses the attribute values for Write requests across node interfaces.

Table 4-13 lists the values permitted for key attributes in Write requests from Request Node to Home Node.

Table 4-13 RN to HN Write request attribute values

| Request              | Size (bytes) | Excl | SnPAttr | MemAttr<br>A C D E | Order | LikelyShared | ExpCompAck |
|----------------------|--------------|------|---------|--------------------|-------|--------------|------------|
| WriteNoSnPtl         | <=64         | 0,1  | 0       | 0010               | 11    | 0            | 0          |
|                      |              |      |         | 0011               | 00,11 | 0            | 0          |
|                      |              |      |         |                    | 10    | 0            | 0,1        |
|                      |              |      |         | 0000               | 00    | 0            | 0          |
|                      |              |      |         | 0001               |       |              |            |
| WriteNoSnPFull       | 64           | 0,1  | 0       | 0101               | 10    | 0            | 0,1        |
|                      |              |      |         | 1101               |       |              |            |
|                      |              |      |         | 0010               | 11    | 0            | 0          |
|                      |              |      |         | 0011               | 00,11 | 0            | 0          |
|                      |              |      |         |                    | 10    | 0            | 0,1        |
| WriteNoSnpZero       | 64           | 0    | 0       | 0000               | 00    | 0            | 0          |
|                      |              |      |         | 0001               |       |              |            |
|                      |              |      |         | 0101               | 10    | 0            | 0,1        |
|                      |              |      |         | 1101               |       |              |            |
|                      |              |      |         | 0010               | 11    | 0            | 0          |
| WriteUniquePtl       | <=64         | 0    | 1       | 0101               | 00    | 0,1          | 0          |
|                      |              |      |         | 1101               |       |              |            |
|                      |              |      |         |                    | 10    | 0,1          | 0,1        |
|                      |              |      |         | 0101               | 00    | 0,1          | 0          |
|                      |              |      |         | 1101               | 10    | 0,1          | 0,1        |
| WriteUniquePtlStash  |              |      |         |                    |       |              |            |
|                      |              |      |         |                    |       |              |            |
| WriteUniqueFull      | 64           | 0    | 1       | 0101               | 00    | 0,1          | 0          |
|                      |              |      |         | 1101               | 10    | 0,1          | 0,1        |
| WriteUniqueFullStash |              |      |         |                    |       |              |            |
|                      |              |      |         |                    |       |              |            |
| WriteUniqueZero      | 64           | 0    | 1       | 0101               | 00,10 | 0,1          | 0          |
|                      |              |      |         | 1101               |       |              |            |
| WriteBackPtl         | 64           | 0    | 1       | 0101               | 00    | 0            | 0          |
|                      |              |      |         | 1101               |       |              |            |
| WriteBackFull        | 64           | 0    | 1       | 0101               | 00    | 0,1          | 0          |
|                      |              |      |         | 1101               |       |              |            |
| WriteBackPtl         |              |      |         |                    |       |              |            |
|                      |              |      |         |                    |       |              |            |
| WriteEvictFull       | 64           | 0    | 1       | 1101               | 00    | 0,1          | 0          |
|                      |              |      |         |                    |       |              |            |
| WriteEvictOrEvict    | 64           | 0    | 1       | 1101               | 00    | 0,1          | 1          |
|                      |              |      |         |                    |       |              |            |

Table 4-14 lists the values permitted for key attributes in Write requests from HN-F to SN-F.

Table 4-14 HN-F to SN-F Write request attribute values

| Request        | Size (bytes) | Excl | DoDWT          | MemAttr<br>A C D E | Order | LikelyShared   | ExpCompAck     |
|----------------|--------------|------|----------------|--------------------|-------|----------------|----------------|
| WriteNoSnpPtl  | <=64         | 0,1  | 0,1            | 0000               | 00    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |                | 0001               |       |                |                |
|                |              |      |                | 0101               |       |                |                |
|                |              |      |                | 1101               |       |                |                |
| WriteNoSnpFull | 64           | 0,1  | 0,1            | 0000               | 00    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |                | 0001               |       |                |                |
|                |              |      |                | 0101               |       |                |                |
|                |              |      |                | 1101               |       |                |                |
| WriteNoSnpZero | 64           | 0    | 0 <sup>a</sup> | 0000               | 00    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |                | 0001               |       |                |                |
|                |              |      |                | 0101               |       |                |                |
|                |              |      |                | 1101               |       |                |                |

a. The field is inapplicable and must be set to zero.

Table 4-15 lists the values permitted for key attributes in Write requests from HN-I to SN-I.

Table 4-15 HN-I to SN-I Write request attribute values

| Request        | Size (bytes) | Excl | DoDWT | MemAttr<br>A C D E | Order    | LikelyShared   | ExpCompAck     |
|----------------|--------------|------|-------|--------------------|----------|----------------|----------------|
| WriteNoSnpPtl  | <=64         | 0,1  | 0,1   | 0010               | 11       | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |       | 0011               | 00,10,11 | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |       | 0000               | 00,10    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |       | 0001               |          |                |                |
|                |              |      |       | 0101               |          |                |                |
|                |              |      |       | 1101               |          |                |                |
| WriteNoSnpFull | 64           | 0,1  | 0,1   | 0010               | 11       | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |       | 0011               | 00,10,11 | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |       | 0000               | 00,10    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |       | 0001               |          |                |                |
|                |              |      |       | 0101               |          |                |                |
|                |              |      |       | 1101               |          |                |                |

Table 4-15 HN-I to SN-I Write request attribute values (continued)

| Request        | Size (bytes) | Excl | DoDWT          | MemAttr<br>A C D E | Order    | LikelyShared   | ExpCompAck     |
|----------------|--------------|------|----------------|--------------------|----------|----------------|----------------|
| WriteNoSnpZero | 64           | 0    | 0 <sup>a</sup> | 0010               | 11       | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |                | 0011               | 00,10,11 | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |                | 0000               | 00,10    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|                |              |      |                | 0001               |          |                |                |
|                |              |      |                | 0101               |          |                |                |
|                |              |      |                | 1101               |          |                |                |

a. The field is inapplicable and must be set to zero.

##### Initial cache state at the Requester

Table 4-16 lists the permitted Requester cache states when a request is sent. The following key is used:

| Y | Yes, permitted |
|---|----------------|
| - | Not permitted  |

Table 4-16 Permitted Requester cache state at the sending of a Write request

| Request              | Initial state |    |    |    |   |     |     |
|----------------------|---------------|----|----|----|---|-----|-----|
|                      | UD            | UC | SD | SC | I | UDP | UCE |
| WriteNoSnpPtl        | -             | -  | -  | -  | Y | -   | -   |
| WriteNoSnpFull       | -             | -  | -  | -  | Y | -   | -   |
| WriteNoSnpZero       | -             | -  | -  | -  | Y | -   | -   |
| WriteUniquePtl       | -             | -  | -  | -  | Y | -   | -   |
| WriteUniqueFull      | -             | -  | -  | -  | Y | -   | -   |
| WriteUniqueZero      | -             | -  | -  | -  | Y | -   | -   |
| WriteUniquePtlStash  | -             | -  | -  | -  | Y | -   | -   |
| WriteUniqueFullStash | -             | -  | -  | -  | Y | -   | -   |
| WriteBackPtl         | -             | -  | -  | -  | - | Y   | -   |
| WriteBackFull        | Y             | -  | Y  | -  | - | -   | -   |
| WriteCleanFull       | Y             | -  | Y  | -  | - | -   | -   |
| WriteEvictFull       | -             | Y  | -  | -  | - | -   | -   |
| WriteEvictOrEvict    | -             | Y  | -  | Y  | - | -   | -   |

##### Final cache state at the Requester

The permitted Requester cache state at the completion of a Write transaction, except for WriteCleanFull, is Invalid.

The permitted Requester cache state at the completion of a WriteCleanFull transaction is UC or SC.

##### Peer cache state

The Peer Request Node cache state at the completion of WriteNoSnpPtl, WriteNoSnpFull, and WriteNoSnpZero is not applicable.

The Peer Request Node cache state at the completion of WriteUniquePtl, WriteUniqueFull, WriteUniqueZero, WriteUniquePtlStash, and WriteUniqueFullStash must be Invalid.

The Peer Request Node cache state at the completion of CopyBack requests is not changed. The Home Node is not required to snoop the Peer Request Nodes to change their cache state.

### 4.2.4 Combined Write requests

This specification supports the combining of Write transactions with Cache Maintenance transactions when both are to the same address. The ability to combine the two requests to the same address is useful when a CMO or PCMO transaction reaches a point in the system where a Write operation must be completed before the CMO or PCMO transaction can be initiated. The use of a single Combined Write transaction avoids the need to serialize the Write and CMO or PCMO transactions. The point where the two requests are combined can be an RN or an HN.

Table 4-17 and Table 4-18 show the Write, CMO, and PCMO combinations for which combining is permitted. Empty table cells indicate a combination that is not permitted or not applicable.

Note

Deep is an attribute on persistent CMO requests. Deep has not been listed explicitly as a CMO type in Table 4-17 and Table 4-18.

When a Persistent CMO is combined with a write, the Persistent CMO is treated as a CleanSharedPersistSep, that is, in addition to a completion response, a separate Persist response is required for the CMO part of the request.

Table 4-17 and Table 4-18 show the permitted combinations of Write and CMO requests. Table 4-17 and Table 4-18 use the following key:

Y Yes, permitted  
- Not permitted

Table 4-17 Permitted combinations of Write and CMO for RN to HN requests

| Write type           | Persistent CMO<br>(With separate<br>Persist response) | Non-persistent CMO |              |             |
|----------------------|-------------------------------------------------------|--------------------|--------------|-------------|
|                      |                                                       | CleanShared        | CleanInvalid | MakeInvalid |
| WriteNoSnpFull       | Y                                                     | Y                  | Y            | -           |
| WriteNoSnpPtl        |                                                       |                    |              |             |
| WriteUniqueFull      | Y                                                     | Y                  | -            | -           |
| WriteUniquePtl       |                                                       |                    |              |             |
| WriteUniqueStashFull | -                                                     | -                  | -            | -           |
| WriteUniqueStashPtl  |                                                       |                    |              |             |
| WriteBackFull        | Y                                                     | Y                  | Y            | -           |
| WriteBackPtl         | -                                                     | -                  | -            | -           |
| WriteCleanFull       | Y                                                     | Y                  | -            | -           |
| WriteEvictFull       | -                                                     | -                  | -            | -           |

Table 4-18 Permitted combinations of Write and CMO for HN to SN requests

| Write type     | Persistent CMO<br>(With separate<br>Persist response) | Non-persistent CMO |              |             |
|----------------|-------------------------------------------------------|--------------------|--------------|-------------|
|                |                                                       | CleanShared        | CleanInvalid | MakeInvalid |
| WriteNoSnpFull | Y                                                     | Y                  | Y            | -           |
| WriteNoSnpPtl  |                                                       |                    |              |             |

Examples of how combining of a Write request with Cache Maintenance is useful are:

- Combining WriteBack with CleanShared and CleanSharedPersist, is to support Request Nodes that transition the cache line to Invalid when cleaned by a CMO irrespective of the type of CMO.
- Combining WriteUnique with CleanShared is to support the case when the CleanSharedPersist target is known to not support Persistent transactions and therefore the CleanSharedPersist request needs to be converted to CleanShared by the Requester.

For each Write request the Combined Write requests are:

- WriteNoSnpFull:
  - WriteNoSnpFullCleanInv
  - WriteNoSnpFullCleanSh
  - WriteNoSnpFullCleanShPerSep
- WriteNoSnpPt:
  - WriteNoSnpPtCleanInv
  - WriteNoSnpPtCleanSh
  - WriteNoSnpPtCleanShPerSep
- WriteUniqueFull:
  - WriteUniqueFullCleanSh
  - WriteUniqueFullCleanShPerSep
- WriteUniquePt:
  - WriteUniquePtCleanSh
  - WriteUniquePtCleanShPerSep
- WriteBackFull:
  - WriteBackFullCleanInv
  - WriteBackFullCleanSh
  - WriteBackFullCleanShPerSep
- WriteCleanFull:
  - WriteCleanFullCleanSh
  - WriteCleanFullCleanShPerSep

#### Characteristics

A Combined Write request is permitted for both CopyBack and Non-CopyBack writes.

All permitted behaviors of the Combined Write request are the same as if the write and CMO are sent separately, except that:

- WriteNoSnp(Excl) is not permitted to be combined with a CMO.
- TagOp setting of *Match* is not permitted in Write\*CMO.

A Home receiving a Combined Write request from a Request Node is permitted to forward the Combined Write to the Subordinate Node if both the write and the CMO or PCMO in the request need to be sent downstream. The Home is also permitted to use DWT for such a Write request if the write from the Request Node is a Non-CopyBack write and ExpCompAck is set to zero.

Where an uncombined CMO from a Request Node results in the cache line being evicted from a cache at the Home or a Dirty copy is passed in a Snoop response, the CMO propagated to the Subordinate can be combined with the write back to the Subordinate.

The receiver of a Combined Write request is permitted to separate the write and the CMO request and process them separately. In such a case, the CMO request must be ordered behind the write. Once the requests are separated, the Completer is permitted to interleave requests to the same address between the write and the CMO transaction.

The Size field value in a combined request corresponds to the size of Data in the Write request. The CMO is always on a 64-byte granularity.

The MemAttr and SnpAttr field values in a Combined Write request correspond to the memory attributes of the Write request. When the write and the CMO transactions are separated, the Write transaction inherits the MemAttr and SnpAttr values of the original combined request. The SnpAttr and Cacheable bit values of the separated CMO transaction must be set to the most pervasive.

### 4.2.5 Atomic transactions

An Atomic transaction permits a Requester to send to the interconnect a transaction with a memory address and an operation to be performed on that memory location. This transaction type moves the operation closer to where the data resides and is useful for atomically executing an operation and updating the memory location in a performance efficient manner.

Without an Atomic transaction, an atomic operation has to be executed using a sequence of memory accesses. These accesses might rely on Exclusive reads and writes.

Also, by using an Atomic transaction:

- A more deterministic latency can be estimated for atomic operations.
- The blocking period of access to the memory location being modified is reduced, which then reduces the impact on the forward progress of memory accesses by other agents.
- Providing fairness among different Requesters accessing a memory location becomes simpler, because accessing of that memory location by an atomic operation is arbitrated at the *Point of Serialization (PoS)* or *Point of Coherence (PoC)*.

This specification defines the following terms relating to atomic operations and Atomic transactions:

**Atomic operation** The execution of a function involving multiple data values such that, the loading of the original value, the execution of the function, and the storing of the updated value, occurs in an atomic manner. This means that no other agent has access to the location during the entire operation.

**Atomic transaction** A transaction that is used to pass an atomic operation, along with the data values required for the execution of the atomic operation, from one agent in a system to another, so that the atomic operation can be carried out by a different component in the system than the component that requires the operation to be performed.

#### Atomic transaction types

This specification defines four Atomic transaction types:

- AtomicStore
- AtomicLoad
- AtomicSwap
- AtomicCompare

See [Chapter 12 Memory Tagging](#) for a description of the Memory Tagging mechanism.

For information on the permitted MTE TagOp values for each Atomic request see [Table 12-2 on page 12-388](#).

The following terminology is used to refer to the different data elements in the execution of an atomic operation:

| <b>TxnData</b>     | The write data in the AtomicLoad, and AtomicStore transactions.    |
|--------------------|--------------------------------------------------------------------|
| <b>CompareData</b> | The compare value in the AtomicCompare transaction.                |
| <b>SwapData</b>    | The swap value in the AtomicCompare, and AtomicSwap transactions.  |
| <b>InitialData</b> | The content of the addressed location before the atomic operation. |

Enumeration of the four Atomic transaction types is as follows:

**AtomicStore**

- Sends a single data value with an address and the atomic operation to be performed.
- The target, a Home Node or a Subordinate Node, performs the required operation on the address location specified with the data supplied in the Atomic transaction.
- The target returns a completion response without data.
- Unlike in AtomicLoad transactions, the original value of AtomicStore transactions at the addressed location is not returned to the Requester.
- Number of operations supported is 8.

Table 4-19 shows the eight operations supported by the AtomicStore transaction.

Each of the AtomicStore operations apply to 1 byte, 2 byte, 4 byte, or 8 byte data sizes.

Table 4-19 AtomicStore operations

| Operation | Action                                                                                          |
|-----------|-------------------------------------------------------------------------------------------------|
| STADD     | Update location with:<br>(TxnData + InitialData)                                                |
| STCLR     | Update location with bitwise:<br>(InitialData AND (NOT TxnData))                                |
| STEOR     | Update location with bitwise:<br>(InitialData XOR TxnData)                                      |
| STSET     | Update location with bitwise:<br>(InitialData OR TxnData)                                       |
| STSMAX    | Update location with TxnData if:<br>(((Signed INT) TxnData - (Signed INT) InitialData) > 0)     |
| STSMIN    | Update location with TxnData if:<br>(((Signed INT) TxnData - (Signed INT) InitialData) < 0)     |
| STUMAX    | Update location with TxnData if:<br>(((Unsigned INT) TxnData - (Unsigned INT) InitialData) > 0) |
| STUMIN    | Update location with TxnData if:<br>(((Unsigned INT) TxnData - (Unsigned INT) InitialData) < 0) |

**AtomicLoad**

- Sends a single data value with an address and the atomic operation to be performed.
- The target, a Home Node or a Subordinate Node, performs the required operation on the address location specified with the data value supplied in the Atomic transaction.
- The target returns the completion response with data. The data value is the original value at the addressed location.
- The target returns the completion response with data. The data value is the original value at the addressed location.
- Number of operations supported is 8.

Table 4-20 shows the eight operations supported by the AtomicLoad transaction.

Each of the AtomicLoad operations applies to 1 byte, 2 byte, 4 byte, or 8 byte data sizes.

Table 4-20 AtomicLoad operations

| Operation | Action                                                                                          |
|-----------|-------------------------------------------------------------------------------------------------|
| LDADD     | Update location with:<br>(TxnData + InitialData)                                                |
| LDCLR     | Update location with bitwise:<br>(InitialData AND (NOT TxnData))                                |
| LDEOR     | Update location with bitwise:<br>(InitialData XOR TxnData)                                      |
| LDSET     | Update location with bitwise:<br>(InitialData OR TxnData)                                       |
| LDSMAX    | Update location with TxnData if:<br>(((Signed INT) TxnData - (Signed INT) InitialData) > 0)     |
| LDSMIN    | Update location with TxnData if:<br>(((Signed INT) TxnData - (Signed INT) InitialData) < 0)     |
| LDUMAX    | Update location with TxnData if:<br>(((Unsigned INT) TxnData - (Unsigned INT) InitialData) > 0) |
| LDUMIN    | Update location with TxnData if:<br>(((Unsigned INT) TxnData - (Unsigned INT) InitialData) < 0) |

#### **AtomicSwap**

- Sends a single data value, the swap value, together with the address of the location to be operated on.
- The target, a Home Node or a Subordinate Node, swaps the value at the address location with the data value supplied in the transaction.
- The target returns the completion response with data. The data value is the original value at the addressed location.
- Number of operations supported is 1.

#### **AtomicCompare**

- Sends two data values, the compare value and the swap value, with the address of the location to be operated on.
- The target, a Home Node or a Subordinate Node, compares the value at the addressed location with the compare value:
  - If the values match, the target writes the swap value to the addressed location.

- If the values do not match, the target does not write the swap value to the addressed location.
- The target returns the completion response with data. The data value is the original value at the addressed location.
- Number of operations supported is 1.

Other common characteristics of Atomic transactions are:

- Data must be included in the completion response to the Requester, except for AtomicStore transaction. For AtomicStore, the completion response does not include the data response.
  - When data is returned, inbound data size must be the same as the outbound data size, except for in AtomicCompare transaction. In AtomicCompare, inbound data size must be half of the outbound data size.
  - The data value in the response data must be the original value at the addressed location.
  - The received data must not be cached at the Requester.
- Byte enables must be asserted for all valid data in the inbound and outbound data messages.
- The request can result in a cache state change at other Request Nodes in the system. The peer Request Node cache state must be Invalid at the completion of the request.
- Atomic transactions cannot use DMT nor DWT flows.

A Requester that has a cached copy of the line on which it must perform an atomic operation can do the following:

- If the cache line is Unique, then it can perform the atomic operation locally without generating an Atomic transaction.
- If the cache line is Shared but not Dirty, it can either:
  - Generate a ReadUnique, CleanUnique, or MakeReadUnique to gain ownership of the cache line and perform the atomic operation locally.
  - Invalidate the local copy and send the Atomic transaction to the interconnect.
- If the cache line is Shared Dirty, it can either:
  - Generate a ReadUnique, CleanUnique, or MakeReadUnique, gain ownership of the cache line, and perform the operation locally.
  - WriteBack and Invalidate the local copy and then send the Atomic transaction to the interconnect.
- Optionally, in all the above cases, the Requester is permitted to send the Atomic transaction with the SnoopMe bit set to direct the interconnect to send a Snoop request to the Requester to invalidate, and if necessary, extract the cached copy. See [SnoopMe on page 13-433](#).

#### Atomic request attribute values

This section discusses the attribute values for Atomic requests across node interfaces.

Table 4-21 lists the permitted values for attributes for Atomic requests from Request Node to Home Node.

Table 4-21 RN to HN Atomic request attribute values

| Request       | Size (bytes)    | SnoopMe | SnAttr | MemAttr<br>A C D E | Order    | LikelyShared | ExpCompAck |
|---------------|-----------------|---------|--------|--------------------|----------|--------------|------------|
| AtomicStore   | 1, 2, 4, 8      | 0       | 0      | 0010               | 11       | 0            | 0          |
| AtomicLoad    |                 |         |        | 0011               | 00,10,11 | 0            | 0          |
| AtomicSwap    |                 |         |        | 0000               | 00,10    | 0            | 0          |
|               |                 |         |        | 0001               |          |              |            |
|               |                 |         |        | 0101               |          |              |            |
|               |                 |         |        | 1101               |          |              |            |
|               |                 | 0,1     | 1      | 0101               | 00,10    | 0            | 0          |
|               |                 |         |        | 1101               |          |              |            |
| AtomicCompare | 2, 4, 8, 16, 32 | 0       | 0      | 0010               | 11       | 0            | 0          |
|               |                 |         |        | 0011               | 00,10,11 | 0            | 0          |
|               |                 |         |        | 0000               | 00,10    | 0            | 0          |
|               |                 |         |        | 0001               |          |              |            |
|               |                 |         |        | 0101               |          |              |            |
|               |                 |         |        | 1101               |          |              |            |
|               |                 | 0,1     | 1      | 0101               | 00,10    | 0            | 0          |
|               |                 |         |        | 1101               |          |              |            |

Table 4-22 lists the permitted values for attributes for Atomic requests from HN-F to SN-F.

Table 4-22 HN-F to SN-F Atomic request attribute values

| Request       | Size (bytes)    | SnoopMe        | DoDWT | MemAttr<br>A C D E | Order | LikelyShared   | ExpCompAck     |
|---------------|-----------------|----------------|-------|--------------------|-------|----------------|----------------|
| AtomicStore   | 1, 2, 4, 8      | 0 <sup>a</sup> | 0     | 0000               | 00    | 0 <sup>a</sup> | 0 <sup>a</sup> |
| AtomicLoad    |                 |                |       | 0001               |       |                |                |
| AtomicSwap    |                 |                |       | 0101               |       |                |                |
|               |                 |                |       | 1101               |       |                |                |
| AtomicCompare | 2, 4, 8, 16, 32 | 0 <sup>a</sup> | 0     | 0000               | 00    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|               |                 |                |       | 0001               |       |                |                |
|               |                 |                |       | 0101               |       |                |                |
|               |                 |                |       | 1101               |       |                |                |

a. The field is inapplicable and must be set to zero.

Table 4-23 lists the permitted values for attributes for Atomic requests from HN-I to SN-I.

Table 4-23 HN-I to SN-I Atomic request attribute values

| Request       | Size (bytes)    | SnoopMe        | DoDWT | MemAttr<br>A C D E | Order    | LikelyShared   | ExpCompAck     |
|---------------|-----------------|----------------|-------|--------------------|----------|----------------|----------------|
| AtomicStore   | 1, 2, 4, 8      | 0 <sup>a</sup> | 0     | 0010               | 11       | 0 <sup>a</sup> | 0 <sup>a</sup> |
| AtomicLoad    |                 |                |       | 0011               | 00,10,11 | 0 <sup>a</sup> | 0 <sup>a</sup> |
| AtomicSwap    |                 |                |       | 0000               | 00,10    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|               |                 |                |       | 0001               |          |                |                |
|               |                 |                |       | 0101               |          |                |                |
|               |                 |                |       | 1101               |          |                |                |
| AtomicCompare | 2, 4, 8, 16, 32 | 0 <sup>a</sup> | 0     | 0010               | 11       | 0 <sup>a</sup> | 0 <sup>a</sup> |
|               |                 |                |       | 0011               | 00,10,11 | 0 <sup>a</sup> | 0 <sup>a</sup> |
|               |                 |                |       | 0000               | 00,10    | 0 <sup>a</sup> | 0 <sup>a</sup> |
|               |                 |                |       | 0001               |          |                |                |
|               |                 |                |       | 0101               |          |                |                |
|               |                 |                |       | 1101               |          |                |                |

a. The field is inapplicable and must be set to zero.

#### Communicating node pair

See Table B-1 on page B-492 for expected and permitted node pairs for each Atomic transaction.

##### Initial cache state at the Requester

The Requester cache state permitted at the issue of the Atomic transaction is any state.

If the Requester at the time of issuing an Atomic transaction determines the cache state to not be Invalid, or cannot determine that the cache state is Invalid, then it must set the value of SnoopMe in the Atomic request to 1.

##### Final cache state at the Requester

The Requester cache state permitted at the completion of an Atomic transaction is Invalid.

##### Peer cache state

The peer Request Node cache state at the completion of Atomic transactions is Invalid.

### 4.2.6 Other transactions

This section describes the protocol transactions that carry out miscellaneous actions.

See Chapter 12 Memory Tagging for a description of the Memory Tagging mechanism.

For information on the permitted MTE TagOp values for each miscellaneous request see Table 12-2 on page 12-388.

See Table B-1 on page B-492 for expected and permitted node pairs for other transactions.

#### DVM transactions

DVM transactions are used for virtual memory system maintenance.

**DVMOp** DVM Operation. Actions include the passing of messages between components within a distributed virtual memory system. See [Chapter 8 DVM Operations](#) for details.

#### Prefetch transaction

The Prefetch target transaction is used to speculatively fetch data from main memory.

**PrefetchTgt** Prefetch Target. A Request to a Snoopable memory address, sent from a Request Node directly to a Subordinate Node:

- The PrefetchTgt transaction does not include a response.
- The request can be used by the Subordinate Node to fetch the data from off-chip memory and buffer it in anticipation of a subsequent Read request to the same location.
- The request does not include a response nor RetryAck. The Requester can deallocate the request as soon as the request is sent.
- The Receiver must accept the request without dependency on receiving a subsequent Read request to the same address.
- The Receiver is permitted to initiate an internal action or discard the request without any further action.
- Data read from off-chip memory using PrefetchTgt must not hold Subordinate Node resources waiting indefinitely for a future Read request to the same address.
- The following fields are inapplicable and can take any value:
  - TxnID
  - Order
  - Endian
  - Size
  - MemAttr
  - SnpAttr
  - Excl
  - LikelyShared

## 4.3 Snoop request types

The interconnect generates a Snoop request either in response to a request from a Request Node or due to an internal trigger such as a cache or snoop filter maintenance operation. A Snoop transaction, except for SnpDVMOp, operates on the cached data at the RN-F. A SnpDVMOp transaction carries out a DVM maintenance operation at the target node.

The Home selection of a Snoop to send is based on several criteria. These are:

- Expected or permitted final cache states, required by the request causing the snoop, at the Requester and the snooped nodes.
- Avoid losing any Dirty tags present in the caches being snooped.
- Replacing a Non-forwarding with an equivalent Forwarding snoop, if one exists.
- A Forwarding snoop is permitted to be sent to one RN-F only.
- A stash snoop is permitted to be sent to one RN-F only.
- Snoops are permitted to Non-snoopable address locations.

See [Request transactions and corresponding Snoop requests on page 4-194.](#)

See [Cache state transitions at a Snoopee on page 4-221](#) for the permitted responses for specific snoop types.

For details of Snoop transaction interaction with the *Memory Tagging Extension (MTE)* see [Chapter 12 Memory Tagging.](#)

### SnpOnceFwd, SnpOnce

Snoop request to obtain the latest copy of the cache line, preferably without changing the cache line state at the Snoopee:

### SnpStashUnique

Snoop request recommending that the Snoopee obtains a copy of the cache line in a Unique state:

- It is expected that the snoop for a StashOnceUnique request is not sent if the cache line is cached in Unique state at the Stash target.
- Permitted to send the snoop to the Stash target for WriteUniqueFullStash and WriteUniquePtlStash only if the Snoopee does not have a cached copy of the cache line.
- The Snoopee must not return data with the Snoop response.
- Permits the Snoop response to include a Data Pull.
- Data Pull request in the Snoop response is treated as a ReadUnique.
- Must not change the cache line state at the Snoopee.

### SnpStashShared

Snoop request recommending that the Snoopee obtains a copy of the cache line in a Shared state:

- It is expected to not send the snoop if the cache line is cached at the target.
- The Snoopee must not return data with the Snoop response.
- Permits the Snoop response to include a Data Pull.
- Data Pull request in the Snoop response is treated as a ReadNotSharedDirty.
- Must not change the cache line state at the Snoopee.

### **SnpCleanFwd, SnpClean**

Snoop request to obtain a copy of the cache line in Clean state while leaving any cached copy in Shared state:

- Must not leave the cache line in Unique state.

### **SnpNotSharedDirtyFwd, SnpNotSharedDirty**

Snoop request to obtain a copy of the cache line in Shared/Clean state while leaving any cached copy in a Shared state:

- Must not leave the cache line in Unique state.

### **SnpSharedFwd, SnpShared**

Snoop request to obtain a copy of the cache line in Shared state while leaving any cached copy in Shared state:

- Must not leave the cache line in Unique state.

### **SnpUniqueFwd, SnpUnique**

Snoop request to obtain a copy of the cache line in Unique state while invalidating any cached copies:

- Must change the cache line to Invalid state.

### **SnpPreferUniqueFwd, SnpPreferUnique**

Snoop request to obtain a copy of the cache line in Unique state while invalidating any cached copies:

- Home is expected to use SnpPreferUniqueFwd or SnpPreferUnique in response to ReadPreferUnique.
- The behavior of the Snoopee is dependent on whether it is executing an exclusive sequence.

### **SnpUniqueStash**

Snoop request to invalidate the cached copy at the Snoopee and recommends that the Snoopee obtains a copy of the cache line in Unique state:

- Permits the Snoop response to include a Data Pull.
- Data Pull request in the Snoop response is treated as a ReadUnique.

### **SnpCleanShared**

Snoop request to remove any Dirty copy of the cache line at the Snoopee:

- Must not leave the cache line in a Dirty state.

### **SnpCleanInvalid**

Snoop request to Invalidate the cache line at the Snoopee and obtain any Dirty copy. Might also be generated by the interconnect without a corresponding request:

- Must change the cache line to Invalid state.

### **SnpMakeInvalid**

Snoop request to Invalidate the cache line at the Snoopee and discard any Dirty copy:

- Does not return data with the Snoop response, Dirty data is discarded.
- Must change the cache line to Invalid state.

#### **SnpMakeInvalidStash**

Snoop request to invalidate the copy of the cache line and recommends that the Snoopee obtains a copy of the cache line in Unique state:

- Snoopee must not return data with the Snoop response, Dirty data must be discarded.
- Permits the Snoop response to include a Data Pull.
- Data Pull request in the Snoop response is treated as a ReadUnique.

### SnpQuery

SnpQuery probes the state of a cache line at a Request Node:

- Home can send a SnpQuery snoop without any corresponding request from a Requester.
- The Snoop response must include the precise state of the cache line at the targeted Snoopee.
- Snoopee must not return data with the Snoop response.
- The SnpQuery snoop must not change the state of the cache line at the Snoopee.

See [MakeReadUnique transaction on page 4-213](#) and [MakeReadUnique\(Excl\) on page 6-288](#) to see how SnpQuery can be used in the efficient handling of exclusive request flows.

### SnpDVMOp

Generated at the interconnect, initiated by the DVMOp request:

- A single DVMOp request generates two snoop requests.
- Returns a single Snoop response for the two Snoop requests.

See [Non-sync type DVM transaction flow on page 8-304](#).

## 4.4 Request transactions and corresponding Snoop requests

For a required coherency action, a Home has a choice of multiple snoop types that it is permitted to select from. This section describes examples of how a Home selects the snoop to send and the number of snoops it sends.

While responding to a Request, the selection of which snoop to use is determined from the intended outcome, that is the desired final state of the cache line at the Requester and the required or desired cache state at the Snoopee.

See *Request types on page 4-162* for required cache state at peer Request Nodes. See *Cache state transitions at a Snoopee on page 4-221* for details of Snoopee cache state transitions.

### 4.4.1 Number of snoops to send

The Home Node can send snoops to more than one Request Node, including to all. In the case of an invalidation, the invalidating snoop must be sent at least to all the cached copies. Whereas for a Non-invalidating snoop, the Home Node is:

- Permitted, but not required, to send the snoop to all Request Nodes with the cached copies.
- Must be able to obtain a copy of the Dirty line. In the case of a cache line in Unique Dirty state, it must send a snoop to the Request Node with the Unique Dirty cached copy.

For Write transactions with stash hint, the Home Node must also send invalidating snoops to all Non-stash target Request Nodes that have a copy of the cache line:

- For WriteUniqueFullStash, the expected snoop to Non-stash target nodes is SnpMakeInvalid.
- For WriteUniquePtlStash, the expected snoop to Non-stash target nodes is SnpCleanInvalid.

To support filtering of snoops, this specification permits, but does not require the interconnect to include an SF or a directory.

### 4.4.2 Selection of snoop to send

A Home Node, based on internal preferences and implementation constraints, might prefer one of the expected snoops or substitute an expected snoop with others. See *Table 4-24* for the expected snoop per Request type.

*Table 4-24* shows the snoops expected to be used by the Home Node for a given Request. A Home is permitted to substitute the expected snoop with another snoop that accomplishes the required Snoopee state transition.

**Table 4-24 Expected snoop requests per Request from an RN**

| Request Category | Request              | Expected Snoop                   |
|------------------|----------------------|----------------------------------|
| Read             | ReadNoSnp            | None or SnpOnceFwd               |
|                  | ReadNoSnpSep         | n/a                              |
|                  | ReadOnce             | SnpOnceFwd                       |
|                  | ReadOnceCleanInvalid | SnpUnique or SnpOnceFwd          |
|                  | ReadOnceMakeInvalid  | SnpUnique or SnpOnceFwd          |
|                  | ReadClean            | SnpCleanFwd                      |
|                  | ReadNotSharedDirty   | SnpNotSharedDirtyFwd             |
|                  | ReadShared           | SnpSharedFwd                     |
|                  | ReadUnique           | SnpUniqueFwd                     |
|                  | ReadPreferUnique     | SnpPreferUniqueFwd               |
|                  | MakeReadUnique       | SnpCleanInvalid or SnpUniqueFwd* |

Table 4-24 Expected snoop requests per Request from an RN (continued)

| Request Category | Request               | Expected Snoop               |
|------------------|-----------------------|------------------------------|
| Dataless         | CleanUnique           | SnpCleanInvalid              |
|                  | MakeUnique            | SnpMakeInvalid               |
|                  | Evict                 | None                         |
|                  | CleanShared           | SnpCleanShared               |
|                  | CleanSharedPersist    | SnpCleanShared               |
|                  | CleanSharedPersistSep |                              |
|                  | CleanInvalid          | SnpCleanInvalid              |
| Dataless-stash   | MakeInvalid           | SnpMakeInvalid               |
|                  | StashOnceUnique       | SnpStashUnique               |
|                  | StashOnceSepUnique    |                              |
| Write            | StashOnceShared       | SnpStashShared               |
|                  | StashOnceSepShared    |                              |
|                  | WriteNoSnp            | None                         |
|                  | WriteNoSnpSep         | n/a                          |
|                  | WriteUniqueFull       | SnpMakeInvalid               |
| Write-stash      | WriteUniquePtl        | SnpCleanInvalid or SnpUnique |
|                  | WriteUniqueZero       | SnpMakeInvalid               |
| Write-CopyBack   | WriteUniqueFullStash  | SnpMakeInvalidStash          |
|                  | WriteUniquePtlStash   | SnpUniqueStash               |
|                  | WriteBack             | None                         |
|                  | WriteClean            |                              |
|                  | WriteEvictFull        |                              |
| Atomic           | WriteEvictOrEvict     |                              |
|                  | AtomicStore           | SnpUnique                    |
|                  | AtomicLoad            | SnpUnique                    |
|                  | AtomicSwap            | SnpUnique                    |
| Others           | AtomicCompare         | SnpUnique                    |
|                  | DVMOp                 | SnpDVMOp                     |
|                  | PCrdReturn            | n/a                          |
|                  | PrefetchTgt           |                              |

a. Home is expected to use SnpUniqueFwd if it determines that the Requester has lost its copy of the cache line.

The interconnect has the following behavior when generating a snoop request on receipt of a request from an RN:

- This specification supports a snoop filter or directory within the interconnect to track the state of cache lines present in RN-F caches. The tracking can be as detailed as knowing each RN-F that has a copy of the cache line, or as nonspecific as knowing that a cache line is present in one of the RN-F caches. Such tracking permits the interconnect to filter unnecessary snooping of an RN-F, for example:
  - If the snoop filter indicates that the cache line is not present in any of the RN-F caches, then the interconnect does not send a snoop request.
  - If the cache line in the RN-F caches is already in the required state, for example the received request is ReadShared and all cached copies of the cache line are in SharedClean (SC) state, then the interconnect does not send a snoop request.
- The interconnect in response to a WriteUniqueFull, WriteUniqueFullStash, MakeUnique, and MakeInvalid must not use the SnpMakeInvalid snoop request unless either:
  - The transaction TagOp value is *Update*.
  - The interconnect can determine that the Snoopee does not hold Dirty tags.
- The interconnect in response to a MakeReadUnique must not use the SnpMakeInvalid Snoop request unless the interconnect can determine either that:
  - The Requester still has a cached copy of the cache line and the Snoopee does not have Dirty tags.
  - The Requester has lost its cached copy and the Snoopee does not have a Dirty copy of the cache line.
- It is permitted for the interconnect to generate a snoop request spontaneously without a corresponding request from a Request Node. For example, the interconnect can send a SnpUnique or SnpCleanInvalid request as a result of a backward invalidation from a snoop filter or interconnect cache.
- This specification permits the interconnect to select which snoop request to send. For example:
  - For a WriteUniquePtl request, either a SnpCleanInvalid or SnpUnique snoop request can be sent. Both of these snoop transactions invalidate the cache line and if the cache line is dirty then data is returned with the response. The write data is written to memory once all Snoop responses are received and the partial data has been merged with any dirty data received with the Snoop response.  
    The only difference in the behavior between the SnpCleanInvalid and SnpUnique snoop requests is that SnpUnique can return data from the UniqueClean (UC) state but SnpCleanInvalid does not. Using SnpUnique therefore might result in an unnecessary data transfer. This example shows the disadvantage of using SnpUnique instead of SnpCleanInvalid in certain circumstances.
- This specification permits the interconnect to:
  - Use SnpNotSharedDirty or SnpShared or SnpClean for ReadNotSharedDirty, ReadShared, and ReadClean transactions.
  - Use SnpNotSharedDirtyFwd or SnpSharedFwd or SnpCleanFwd for ReadShared transactions.
  - Use SnpNotSharedDirtyFwd or SnpCleanFwd for ReadNotSharedDirty and ReadClean transactions.
  - Use any Non-forwarding, Non-invalidating snoop types for the ReadOnce transactions.
  - Use any Non-forwarding snoop types except SnpMakeInvalid for the ReadOnceCleanInvalid and ReadOnceMakeInvalid transactions.
  - Use Forwarding snoop type SnpOnceFwd for the ReadOnce, ReadOnceCleanInvalid and ReadOnceMakeInvalid transactions.
  - Send SnpStashUnique or SnpMakeInvalidStash to the target RN for WriteUniqueFullStash and WriteUniquePtlStash if the target RN does not have the cache line.
  - Replace any Invalidating snoop request by the SnpUnique or SnpCleanInvalid request.
  - Replace any Forwarding snoop with a corresponding non-Forwarding type. The receiver is permitted to treat the forward indication as a hint and respond to the snoop with a corresponding non-Forwarding version in a protocol-compliant manner. This is permitted irrespective of the use of MTE.
  - Use of SnpMakeInvalid for MakeInvalid and WriteUniqueZero is permitted only when the Home knows that the Snoopee does not have Dirty tags.

## 4.5 Response types

Each request can generate one or more responses. Some responses can also include data. A Response is classified as follows:

- *Completion response*
- *WriteData response on page 4-199*
- *Snoop response on page 4-201*
- *Miscellaneous response on page 4-207*

### 4.5.1 Completion response

A completion response is required for all transactions except PCrdReturn and PrefetchTgt. It is typically the last message sent, from the Completer, to conclude a request transaction. The Requester might, however, still send a CompAck response to conclude the transaction. A completion guarantees that the request has reached a PoS or a PoC, where it will be ordered with respect to requests to the same address from any Requester in the system. See *Ordering on page 2-114* for details on the Ordering guarantees.

#### Read and Atomic transaction completion

A Read completion is either in the form of a single response on the RDAT channel using the CompData opcode, or two separate responses, one on the RSP channel using the RespSepData opcode, and a second one on the RDAT channel using the DataSepResp opcode. See *Dataless transaction completion on page 4-198* for completion without data for the MakeReadUnique transaction.

AtomicLoad, AtomicSwap, and AtomicCompare completion is sent on the RDAT channel and uses the CompData opcode.

The CompData and DataSepResp completion responses include the Resp field that indicates the following:

**Cache state** The final permitted state of the cache line at the Requester for all reads except ReadNoSnp and ReadOnce\*.

**Pass Dirty** Indicates if the responsibility for updating memory is passed to the Requester. The assertion of the Pass Dirty bit is shown by \_PD in the response name.

When using separate Comp and Data responses, RespSepData also includes the Resp field with Cache state and Pass Dirty indications. The Resp field value in RespSepData must be either inapplicable and set to zero or the same as in the corresponding DataSepResp.

Table 4-25 shows the permitted Read transaction completion, the encoding of the Resp field, and the meaning of the response. A Subordinate Node can send DataSepResp only in response to ReadNoSnpSep, and only CompData in response to ReadNoSnp.

Table 4-25 Permitted Read transaction completion and Resp field encodings

| Response                                        | Resp[2:0] | Description                                                                                                                                                                                                                                                                                       |
|-------------------------------------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| CompData_I<br>DataSepResp_I                     | 0b000     | Indicates that a coherent copy of the cache line cannot be kept.                                                                                                                                                                                                                                  |
| RespSepData_I                                   | 0b000     | Cache state in this response is not applicable. Cache state must be determined from DataSepResp response.                                                                                                                                                                                         |
| CompData_UC<br>DataSepResp_UC<br>RespSepData_UC | 0b010     | The final state of the cache line can be UC, UCE, SC or I, when the cache state in the response is applicable.<br>This response is also permitted for ReadNoSnp and ReadOnce* transactions but the cache line will not be coherent.<br>Responsibility for a Dirty cache line is not being passed. |

Table 4-25 Permitted Read transaction completion and Resp field encodings (continued)

| Response                                                 | Resp[2:0] | Description                                                                                                     |
|----------------------------------------------------------|-----------|-----------------------------------------------------------------------------------------------------------------|
| CompData_SC<br>DataSepResp_SC<br>RespSepData_SC          | 0b001     | The final state of the cache line can be SC or I.<br>Responsibility for a Dirty cache line is not being passed. |
| CompData_UD_PD<br>DataSepResp_UD_PD<br>RespSepData_UD_PD | 0b110     | The final state of the cache line can be UD or SD.<br>Responsibility for a Dirty cache line is being passed.    |
| CompData_SD_PD                                           | 0b111     | The final state of the cache line must be SD.<br>Responsibility for a Dirty cache line is being passed.         |

In a response with an error indication, the cache state is permitted to be any value, including reserved values. See *Errors and transaction structure* on page 9-336.

#### Dataless transaction completion

A completion for Dataless transactions and the MakeReadUnique transaction without data is sent on the CRSP channel and uses the Comp, CompPersist, CompCMO, or CompStashDone opcode.

CompCMO is the completion message for the CMO and PCMO in a Combined Write transaction. It must be used only in Combined Write transactions. CompCMO can be combined with Persist response as CompPersist opcode.

The Comp response includes the Resp field that indicates the following:

**Cache state** The final state the cache line is permitted to be in at the Requester, except for CMO transactions. For CMO transactions, the cache state field value in the completion, specifically in Comp, CompCMO and CompPersist transactions, is ignored and the cache state remains unchanged.

Table 4-26 shows the permitted Dataless transaction completion, the encoding of the Resp field, and the meaning of the response.

Table 4-26 Permitted Dataless transaction completion and Resp field encodings

| Response   | Resp[2:0] | Description                                                                                                   |
|------------|-----------|---------------------------------------------------------------------------------------------------------------|
| Comp_I     | 0b000     | The final state of the cache line must be I.                                                                  |
| Comp_UC    | 0b010     | The final state of the cache line can be UD, UC, UCE, SC or I.                                                |
| Comp_SC    | 0b001     | The final state of the cache line can be SC or I.                                                             |
| Comp_UD_PD | 0b110     | The final state of the cache line must be UD or SD.<br>Responsibility for a Dirty cache line is being passed. |

In a response with an error indication, the cache state is permitted to be any value, including reserved values. See *Errors and transaction structure* on page 9-336. See *Combined Immediate Write and CMO* on page 2-56 for CompCMO and CompPersist. See *Independent Stash request* on page 7-297 for CompStashDone.

#### Write and Atomic transaction completion

A Write and AtomicStore completion is sent on the CRSP channel and uses the Comp or CompDBIDResp opcode.

No cache state information, or responsibility for a Dirty cache line, is communicated using the Write transaction completion. The Resp field of a Comp or CompDBIDResp response must be set to zero for a Write transaction completion. All cache state information and responsibility for a Dirty cache line are communicated with the WriteData. See *WriteData response*.

The permitted Write transaction completion responses are:

**Comp** Used when the completion response is separate from the DBIDResp or DBIDRespOrd response.

**CompDBIDResp** Used when the completion response is combined with the DBIDResp or DBIDRespOrd response.

All CopyBack requests must use the CompDBIDResp completion response.

Non-CopyBack writes and AtomicStore, can either send Comp and DBIDResp or DBIDRespOrd responses separately or can opportunistically combine the two responses and send CompDBIDResp if both are ready to be sent to the Requester.

#### Miscellaneous transaction completion

A Comp response, with the Resp field set to zero, is always used for DVM transaction completion.

### 4.5.2 WriteData response

The WriteData response is part of Write request and DVMOp transactions. The Requester sends WriteData to the Completer after receiving a guarantee that a buffer is available to accept the data. Buffer availability is signaled through a DBIDResp or DBIDRespOrd response sent from the Completer.

The WriteData response is sent on the WDAT channel and uses the following opcodes.

**CopyBackWrData**

- Used for WriteBack, WriteClean, WriteEvictFull, and WriteEvictOrEvict, and CopyBack Combined Write transactions.
- Transfers coherent data from the cache at the Requester to the interconnect.
- Includes an indication of the cache line state prior to sending the WriteData response.

**NonCopyBackWrData**

- Used for WriteUnique and WriteNoSnp, and Non-CopyBack Combined Write transactions.
- Also used for a DVMOp transaction.
- The cache state in the response must be I.

**NCBWrDataCompAck**

- Used for Non-CopyBack Write and Combined Write transactions.
- Combined NonCopyBackWrData and CompAck.
- The cache state in the response must be I.

**WriteDataCancel**

- Used to inform the Completer that a Write request is canceled before write data is sent.
- A Request Node can send WriteDataCancel instead of NonCopyBackWrData in WriteNoSnpPtl, WriteUniquePtl, WriteUniquePtlStash, and corresponding Combined Write transactions.

- A Home Node can send WriteDataCancel instead of NonCopyBackWrData in WriteNoSnpFull, WriteNoSnpPtl, and corresponding Combined Write transactions to the Subordinate Node.
- Must not be used in Write requests to Device memory.
- All data packets originally intended to be transferred must be sent.
- BE field value in the WriteDataCancel message must be set to all zeroes.
- Cache state in the response must be I.

The response includes the Resp field, which indicates the following:

**Cache state** Indicates the state of the cache line before sending the WriteData response. This state can differ from the state of the cache line when the original transaction request was sent if a snoop request, to the same address, is received by the Requester after sending the original transaction request, but before sending the corresponding WriteData response.

**Pass Dirty** Indicates if the responsibility for updating memory is passed by the Requester. The assertion of the Pass Dirty bit is shown by \_PD in the response name.

Table 4-27 shows the permitted WriteData responses, the Opcode and Resp field encodings, and the meaning of the response.

Table 4-27 Permitted WriteData responses and Opcode and Resp field encodings

| Response             | DAT Opcode | Resp[2:0] | Description                                                                                                                                         |
|----------------------|------------|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| CopyBackWrData_I     | 0x2        | 0b000     | Data corresponding to a CopyBack request.<br>Cache line state when data was sent is I and the data in the response is not valid.                    |
| CopyBackWrData_UC    | 0x2        | 0b010     | Data corresponding to a CopyBack request.<br>Cache line state when data was sent is UC.                                                             |
| CopyBackWrData_SC    | 0x2        | 0b001     | Data corresponding to a CopyBack request.<br>Cache line state when data was sent is SC.                                                             |
| CopyBackWrData_UD_PD | 0x2        | 0b110     | Data corresponding to a CopyBack request.<br>Cache line state when data was sent is UD or UDP.<br>Responsibility for updating the memory is passed. |
| CopyBackWrData_SD_PD | 0x2        | 0b111     | Data corresponding to a CopyBack request.<br>Cache line state when data was sent is SD.<br>Responsibility for updating the memory is passed.        |
| NonCopyBackWrData    | 0x3        | 0b000     | Data corresponding to a Non-CopyBack Write request.                                                                                                 |
| NCBWrDataCompAck     | 0xC        | 0b000     | Data corresponding to a Non-CopyBack Write request and combined Comp/Ack to indicate that the transaction has completed.                            |
| WriteDataCancel      | 0x7        | 0b000     | Data corresponding to a canceled Non-CopyBack Write request.                                                                                        |

###### — Note —

The cache line state at the Requester after the Write transaction has completed is not determined from the cache state information in the WriteData response. It can be determined if the cache line remains Valid or not after the transaction by the opcode of the transaction:

- A WriteBack or WriteEvictFull transaction must be in I state.
- A WriteClean transaction can remain allocated and be in a Clean state.

### 4.5.3 Snoop response

A Snoop transaction includes a Snoop response. A Snoop response can be with or without data. The forms of Snoop response are:

#### Snoop response without data

- This Snoop response is used when no data transfer is required.
- It is sent on the SRSP channel and uses the SnpResp opcode.
- It can include a Data Pull request for stash snoops.
- Snoop response without data is always used for the response to a SnpDVMOp transaction.

#### Snoop response without data to Home and *Direct Cache Transfer (DCT)*

- This Snoop response is used when the Snoopee sends Data to the Requester and a data transfer to the Home is not required.
- It is sent on the SRSP channel and uses the SnpRespFwded opcode.

#### Snoop response with data

- This Snoop response is used when a full cache line of data is transferred to Home.
- It is sent on the WDAT channel and uses the SnpRespData opcode.
- It can include a Data Pull request for stash snoops.

#### Snoop response with partial data

- This Snoop response is used when a partial cache line of data is transferred to the Home.
- It is sent on the WDAT channel and uses the SnpRespDataPtl opcode.
- It can include a Data Pull request for stash snoops.
- It is sent when the combination of the Snoop request and cache line state is:
  - Any Snoop request except SnpMakeInvalid, and the cache line state is UDP.

#### Snoop response with data to Home and DCT

- This Snoop response is used when the Snoopee sends Data to the Requester and a data transfer to the Home is also required.
- It is sent on the DAT channel and uses the SnpRespDataFwded opcode.

The Snoop response includes the Resp field, which indicates the following:

**Cache state** The final state of the cache line at the snooped node after sending the Snoop response.

**Pass Dirty** Indicates that the responsibility for updating memory is passed to the Requester or ICN.  
Pass Dirty must only be asserted for a Snoop response with data. The assertion of the Pass Dirty bit is shown by `_PD` in the response name.

The Snoop response also includes the FwdState field that is applicable in Snoop responses with DCT and indicates the cache state and pass dirty value in the CompData response sent to the Requester.

These attributes convey sufficient information for the interconnect to determine the appropriate response to the initial Requester, and to determine if data must be written back to memory. It is also sufficient to support snoop filter or directory maintenance in the interconnect.

See [Snoop requests on page 12-383](#) for details on Snoop responses and MTE interaction.

###### Note

The Snoop response cache state information provides the state of the cache line after the Snoop response is sent. This is different from:

- A WriteData response, where the cache state information provides the state of the cache line at the point the write data is sent.
- A read data response, where the cache state information indicates the permitted state of the cache line after the transaction completes.

Table 4-28 shows the permitted Non-forward type snoop responses without data, the RSP Opcode and Resp field encodings, and the meaning of the response.

Table 4-28 Permitted Non-forward type snoop responses without data

| Response  | RSP Opcode | Resp[2:0] | Description                                                            |
|-----------|------------|-----------|------------------------------------------------------------------------|
| SnResp_I  | 0x1        | 0b000     | Snoop response without data.<br>Cache line state is I.                 |
| SnResp_SC | 0x1        | 0b001     | Snoop response without data.<br>Cache line state is SC, or I.          |
| SnResp_UC | 0x1        | 0b010     | Snoop response without data.<br>Cache line state is UC, UCE, SC, or I. |
| SnResp_UD | 0x1        | 0b010     | Snoop response without data.<br>Cache line state is UD.                |
| SnResp_SD | 0x1        | 0b011     | Snoop response without data.<br>Cache line state is SD.                |

Table 4-29 shows the permitted Forward type snoop responses without data, the RSP Opcode, Resp, and FwdState field encodings, and the meaning of the response.

Table 4-29 Permitted Forward type snoop responses without data

| Response             | RSP Opcode | Resp[2:0] | FwdState[2:0] | Description                                                                                                                                                                     |
|----------------------|------------|-----------|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SnResp_I_Fwded_I     | 0x9        | 0b000     | 0b000         | Snoop response without data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is I.                                                       |
| SnResp_I_Fwded_SC    | 0x9        | 0b000     | 0b001         | Snoop response without data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.                                                      |
| SnResp_I_Fwded_UC    | 0x9        | 0b000     | 0b010         | Snoop response without data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is UC.                                                      |
| SnResp_I_Fwded_UD_PD | 0x9        | 0b000     | 0b110         | Snoop response without data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is UD.<br>Responsibility for updating the memory is passed. |
| SnResp_I_Fwded_SD_PD | 0x9        | 0b000     | 0b111         | Snoop response without data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is SD.<br>Responsibility for updating the memory is passed. |

Table 4-29 Permitted Forward type snoop responses without data (continued)

| Response                                                                                                                                | RSP Opcode | Resp[2:0] | FwdState[2:0] | Description                                                                                                                                                                      |
|-----------------------------------------------------------------------------------------------------------------------------------------|------------|-----------|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SnResp_SC_Fwded_I                                                                                                                       | 0x9        | 0b001     | 0b000         | Snoop response without data.<br>Cache line state is SC.<br>Copy of data forwarded to the Requester.<br>Forward State is I.                                                       |
| SnResp_SC_Fwded_SC                                                                                                                      | 0x9        | 0b001     | 0b001         | Snoop response without data.<br>Cache line state is SC.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.                                                      |
| SnResp_SC_Fwded_SD_PD                                                                                                                   | 0x9        | 0b001     | 0b111         | Snoop response without data.<br>Cache line state is SC.<br>Copy of data forwarded to the Requester.<br>Forward State is SD.<br>Responsibility for updating the memory is passed. |
| SnResp_UC_Fwded_I                                                                                                                       | 0x9        | 0b010     | 0b000         | Snoop response without data.<br>Cache line state is UC or UD.<br>Copy of data forwarded to the Requester.<br>Forward State is I.                                                 |
| SnResp_UD_Fwded_I                                                                                                                       | 0x9        | 0b010     | 0b000         | Snoop response without data.<br>Cache line state is UC or UD.<br>Copy of data forwarded to the Requester.<br>Forward State is I.                                                 |
| <p><b>Note</b></p> <p>A single encoding is used to indicate that the cache line is unique.<br/>This encoding is used for UC and UD.</p> |            |           |               |                                                                                                                                                                                  |
| SnResp_SD_Fwded_I                                                                                                                       | 0x9        | 0b011     | 0b000         | Snoop response without data.<br>Cache line state is SD.<br>Copy of data forwarded to the Requester.<br>Forward State is I.                                                       |
| SnResp_SD_Fwded_SC                                                                                                                      | 0x9        | 0b011     | 0b001         | Snoop response without data.<br>Cache line state is SD.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.                                                      |

Table 4-30 shows the permitted Non-forward type snoop responses with data, the DAT Opcode and Resp field encodings, and the meaning of the response.

Table 4-30 Permitted Non-forward type snoop responses with data

| Response                                                                                                                                | DAT Opcode | Resp[2:0] | Description                                                                                                                  |
|-----------------------------------------------------------------------------------------------------------------------------------------|------------|-----------|------------------------------------------------------------------------------------------------------------------------------|
| SnRespData_I                                                                                                                            | 0x1        | 0b000     | Snoop response with data.<br>Cache line state is I.                                                                          |
| SnRespData_UC                                                                                                                           | 0x1        | 0b010     | Snoop response with data.<br>Cache line state is UC or UD.                                                                   |
| SnRespData_UD                                                                                                                           | 0x1        | 0b010     | Snoop response with data.<br>Cache line state is UC or UD.                                                                   |
| <p><b>Note</b></p> <p>A single encoding is used to indicate that the cache line is unique.<br/>This encoding is used for UC and UD.</p> |            |           |                                                                                                                              |
| SnRespData_SC                                                                                                                           | 0x1        | 0b001     | Snoop response with data.<br>Cache line state is SC.                                                                         |
| SnRespData_SD                                                                                                                           | 0x1        | 0b011     | Snoop response with data.<br>Cache line state is SD.                                                                         |
| SnRespData_I_PD                                                                                                                         | 0x1        | 0b100     | Snoop response with data.<br>Cache line state is I.<br>Responsibility for updating the memory is passed to the Home.         |
| SnRespData_UC_PD                                                                                                                        | 0x1        | 0b110     | Snoop response with data.<br>Cache line state is UC.<br>Responsibility for updating the memory is passed to the Home.        |
| SnRespData_SC_PD                                                                                                                        | 0x1        | 0b101     | Snoop response with data.<br>Cache line state is SC.<br>Responsibility for updating the memory is passed to the Home.        |
| SnRespDataPtl_I_PD                                                                                                                      | 0x5        | 0b100     | Snoop response with partial data.<br>Cache line state is I.<br>Responsibility for updating the memory is passed to the Home. |
| SnRespDataPtl_UD                                                                                                                        | 0x5        | 0b010     | Snoop response with partial data.<br>Cache line state is UDP.                                                                |

Table 4-31 shows the permitted Forward type snoop responses with data, the DAT Opcode, Resp, and FwdState field encodings, and the meaning of the response.

Table 4-31 Permitted Forward type snoop responses with data

| Response                  | DAT Opcode | Resp[2:0] | FwdState[2:0] | Description                                                                                                                                                                                    |
|---------------------------|------------|-----------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SnRespData_I_Fwded_SC     | 0x6        | 0b000     | 0b001         | Snoop response with data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.                                                                        |
| SnRespData_I_Fwded_SD_PD  | 0x6        | 0b000     | 0b111         | Snoop response with data.<br>Cache line state is I.<br>Copy of data forwarded to the Requester.<br>Forward State is SD.<br>Responsibility for updating the memory is passed to the Requester.  |
| SnRespData_SC_Fwded_SC    | 0x6        | 0b001     | 0b001         | Snoop response with data.<br>Cache line state is SC.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.                                                                       |
| SnRespData_SC_Fwded_SD_PD | 0x6        | 0b001     | 0b111         | Snoop response with data.<br>Cache line state is SC.<br>Copy of data forwarded to the Requester.<br>Forward State is SD.<br>Responsibility for updating the memory is passed to the Requester. |
| SnRespData_SD_Fwded_SC    | 0x6        | 0b011     | 0b001         | Snoop response with data.<br>Cache line state is SD.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.                                                                       |
| SnRespData_I_PD_Fwded_I   | 0x6        | 0b100     | 0b000         | Snoop response with data.<br>Cache line state is I.<br>Responsibility for updating the memory is passed to the Home.<br>Copy of data forwarded to the Requester.<br>Forward State is I.        |

Table 4-31 Permitted Forward type snoop responses with data (continued)

| Response                  | DAT Opcode | Resp[2:0] | FwdState[2:0] | Description                                                                                                                                                                               |
|---------------------------|------------|-----------|---------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SnRespData_I_PD_Fwded_SC  | 0x6        | 0b100     | 0b001         | Snoop response with data.<br>Cache line state is I.<br>Responsibility for updating the memory is passed to the Home.<br>Copy of data forwarded to the Requester.<br>Forward State is SC.  |
| SnRespData_SC_PD_Fwded_I  | 0x6        | 0b101     | 0b000         | Snoop response with data.<br>Cache line state is SC.<br>Responsibility for updating the memory is passed to the Home.<br>Copy of data forwarded to the Requester.<br>Forward State is I.  |
| SnRespData_SC_PD_Fwded_SC | 0x6        | 0b101     | 0b001         | Snoop response with data.<br>Cache line state is SC.<br>Responsibility for updating the memory is passed to the Home.<br>Copy of data forwarded to the Requester.<br>Forward State is SC. |

The cache line state associated with a Snoop response with data must be a legal value, even if the RespErr field indicates there is a Data Error. A Snoop response with data is not permitted to have a Non-data Error. See *Snoop transactions* on page 9-345.

In responses to stash snoops, the Snoopee can send a Read request combined with the Snoop response (SnResp\_X\_Read), by setting the DataPull bit. The permitted Snoop responses with Data Pull are:

- For SnpUniqueStash:
  - SnResp\_I\_Read
  - SnRespData\_I\_Read
  - SnRespData\_I\_PD\_Read
  - SnRespDataPtl\_I\_PD\_Read
- For SnpMakeInvalidStash:
  - SnResp\_I\_Read
- For SnpStashUnique:
  - SnResp\_I\_Read
  - SnResp\_UC\_Read
  - SnResp\_SC\_Read
  - SnResp\_SD\_Read
- For SnpStashShared:
  - SnResp\_I\_Read
  - SnResp\_UC\_Read

### 4.5.4 Miscellaneous response

This section describes responses that cannot be classified as a completion, WriteData, or Snoop response.

For all responses in this section the Resp and RespErr fields have no meaning and must be set to zero.

The miscellaneous responses are:

#### CompAck

- Sent by the Requester on receipt of the completion response.
- Used by Read, Dataless, WriteNoSnp, WriteEvictOrEvict, and WriteUnique transactions.

See *Transaction structure on page 2-40*.

#### RetryAck

- Sent by a Completer to a Requester if the request is not accepted at the Completer due to lack of appropriate resources.
- Response is permitted for any request transaction except PCrdReturn or PrefetchTgt.

See *Retry on page 2-76*.

#### PCrdGrant

Grants a Protocol Credit. A subsequent request, sent using the Protocol Credit, is guaranteed to be accepted by the target.

See *Retry on page 2-76*.

#### ReadReceipt

- Sent for a request that has an ordering requirement with respect to other ordered requests from the same Requester.
- Sent by a Subordinate Node to indicate it has accepted a Read request and will not send a RetryAck response.
- See *Ordering requirements on page 2-119* for how ReadReceipt is used in an ordered request.
- Applies to ReadNoSnp, ReadNoSnpSep, and ReadOnce\* request transactions.

See *Read transactions on page 2-41*.

#### DBIDResp

- Response sent to signal to the Requester that resources are available to accept the WriteData response.
- DBIDResp response also indicates that the Completer provides certain transaction ordering guarantees. See *Transaction ordering on page 2-118*.
- Applies to Write, Combined Write, DVMOp, and Atomic request transactions.
- The response is permitted from Home Node to Request Node and Subordinate Node to both a Home Node and Request Node.

See *Transaction structure on page 2-40*.

#### DBIDRespOrd

- Response sent to signal to the Requester that resources are available to accept the WriteData response.
- DBIDRespOrd response also indicates that the Completer provides certain transaction ordering guarantees. See [Transaction ordering on page 2-118](#).
- Applies to Write, Combined Write, and Atomic request transactions.
- DBIDRespOrd is not permitted in DVM transactions.
- The response is permitted from Home Node to Request Node only.

See [Transaction ordering on page 2-118](#).

#### Persist

Sent by a Completer for CleanSharedPersistSep transaction to indicate that any data written earlier to the same memory location is made persistent.

See [Combined Immediate Write and Persist CMO on page 2-59](#) and [Combined CopyBack Write and CMO on page 2-65](#).

#### StashDone

Sent by a Completer for StashOnceSep to signal the ordering of the request at the Completer.

See [Independent Stash request on page 7-297](#).

#### TagMatch

Sent by the Completer for a Write transaction with TagOp of *Match* to signal the completion of the Tag Match operation.

See [Tag Match on page 12-386](#).

## 4.6 Silent cache state transitions

A cache can change state due to an internal event without notifying the rest of the system.

The legal silent cache state transitions are shown in Table 4-32. In some cases it is possible, but not required, to issue a transaction to indicate that the transition has occurred. If such a transaction is issued, then the cache state transition is visible to the interconnect and is not classified as a silent transition.

The RN-F action described in Table 4-32 as *Local sharing*, describes the case where an RN-F specifies a Unique cache line as Shared, effectively disregarding the fact that the cache line remains Unique to the RN-F. For example, this can happen when the RN-F contains multiple internal agents and the cache line becomes shared between them.

For silent cache state transitions:

- Cache eviction and Local sharing transitions can occur at any point and are IMPLEMENTATION DEFINED.
- Store and Cache Invalidate transitions can only occur as the result of a deliberate action, which in the case of a core is caused by the execution of a particular program instruction.

The Notes column in Table 4-32 indicates how a silent cache transition can be made non-silent or visible at the interface.

Table 4-32 Legal silent cache state transitions

| RN-F action      | RN-F Cache state |      | Notes                                                            |
|------------------|------------------|------|------------------------------------------------------------------|
|                  | Present          | Next |                                                                  |
| Cache eviction   | UC               | I    | Can use Evict, WriteEvictFull, or WriteEvictOrEvict transaction. |
|                  | UCE              | I    | Can use Evict transaction.                                       |
|                  | SC               | I    | Can use Evict transaction.                                       |
| Local sharing    | UC               | SC   | -                                                                |
|                  | UD               | SD   | -                                                                |
| Store            | UC               | UD   | Full or partial cache line store                                 |
|                  | UCE              | UDP  | Partial cache line store                                         |
|                  | UCE              | UD   | Full cache line store                                            |
|                  | UDP              | UD   | Store that fills the cache line                                  |
| Cache Invalidate | UD               | I    | Can use Evict transaction.                                       |
|                  | UDP              | I    | Can use Evict transaction.                                       |

A cache state change from UC to UCE is not permitted.

— Note —

Sequences of silent transitions can also occur. Any silent transition that results in the cache line being in UD, UDP, or SC state can undergo a further silent transition.

## 4.7 Cache state transitions at a Requester

This section specifies the cache state transitions and completion responses for the following request transactions:

- *Read request transactions*
- *Dataless request transactions* on page 4-218
- *Write request transactions* on page 4-219
- *Atomic transactions* on page 4-220
- *Other request transactions* on page 4-220

### 4.7.1 Read request transactions

Table 4-33 shows the cache state transitions at the Requester, and the completion responses, for Read request transactions except for the MakeReadUnique transaction.

For details of the permitted completion responses and cache state transitions at the Requester for the MakeReadUnique transaction, both Non-exclusive and Exclusive, see *MakeReadUnique transaction* on page 4-213.

The cache state in the Data response to the Requester from the Subordinate Node is UC, that is, CompData\_UC irrespective of the original request type. The Requester must ignore the cache state in the CompData response to ReadNoSnp, ReadOnce, ReadOnceCleanInvalid, and ReadOnceMakeInvalid and implicitly assume the cache state value to be I.

— Note —

In a non-DMT data transfer, where the CompData response is sent from the Subordinate to Home, the cache state in the response can be either I or UC. It is expected that typically the design of a Subordinate can be simplified by always using UC. Home then sends CompData to the Requester with the appropriate cache state value.

Table 4-33 Cache state transitions at the Requester for Read request transactions

| Request type         | Cache state         |                           | Final | Comp response              | Separate responses              |
|----------------------|---------------------|---------------------------|-------|----------------------------|---------------------------------|
|                      | Initial             | Expected Others Permitted |       |                            |                                 |
| ReadNoSnp            | I                   | -                         | I     | CompData_UC,<br>CompData_I | RespSepData +<br>DataSepResp_UC |
| ReadOnce             | I, UCE <sup>a</sup> | -                         | I     | CompData_UC,<br>CompData_I | RespSepData +<br>DataSepResp_UC |
| ReadOnceCleanInvalid | I, UCE <sup>a</sup> | -                         | I     | CompData_UC,<br>CompData_I | RespSepData +<br>DataSepResp_UC |
| ReadOnceMakeInvalid  | I, UCE <sup>a</sup> | -                         | I     | CompData_UC,<br>CompData_I | RespSepData +<br>DataSepResp_UC |

Table 4-33 Cache state transitions at the Requester for Read request transactions (continued)

| Request type                   | Cache state         |                  | Final | Comp response  | Separate responses                 |
|--------------------------------|---------------------|------------------|-------|----------------|------------------------------------|
|                                | Initial             | Others Permitted |       |                |                                    |
| ReadClean<br>TagOp = Transfer  | I                   | -                | SC    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UC    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
|                                | UC, UCE             | -                | UC    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UC    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
|                                | UD, UDP             | -                | UD    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UD    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
|                                | SC                  | -                | SC    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UC    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
|                                | SD <sup>b</sup>     | -                | SD    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UD    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
| ReadClean<br>TagOp != Transfer | I                   | -                | SC    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UC    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
|                                | UCE                 | -                | UC    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UC    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
| ReadNotSharedDirty             | I, UCE <sup>a</sup> | -                | SC    | CompData_SC    | RespSepData +<br>DataSepResp_SC    |
|                                |                     |                  | UC    | CompData_UC    | RespSepData +<br>DataSepResp_UC    |
|                                |                     |                  | UD    | CompData_UD_PD | RespSepData +<br>DataSepResp_UD_PD |

Table 4-33 Cache state transitions at the Requester for Read request transactions (continued)

| Request type     | Cache state                                                |                      | Final           | Comp response                 | Separate responses                                                     |
|------------------|------------------------------------------------------------|----------------------|-----------------|-------------------------------|------------------------------------------------------------------------|
|                  | Initial                                                    | Others Permitted     |                 |                               |                                                                        |
| ReadShared       | I, UCE <sup>a</sup>                                        | -                    | SC              | CompData_SC                   | RespSepData +<br>DataSepResp_SC                                        |
|                  |                                                            |                      | UC              | CompData_UC                   | RespSepData +<br>DataSepResp_UC                                        |
|                  |                                                            |                      | SD              | CompData_SD_PD                | -                                                                      |
|                  |                                                            |                      | UD              | CompData_UD_PD                | RespSepData +<br>DataSepResp_UD_PD                                     |
| ReadUnique       | I, SC                                                      | UC, UCE              | UC              | CompData_UC                   | RespSepData +<br>DataSepResp_UC                                        |
|                  |                                                            |                      | UD              | CompData_UD_PD                | RespSepData +<br>DataSepResp_UD_PD                                     |
|                  | SD                                                         | UD, UDP <sup>c</sup> | UD              | CompData_UC<br>CompData_UD_PD | RespSepData +<br>DataSepResp_UC,<br>RespSepData +<br>DataSepResp_UD_PD |
|                  |                                                            |                      | SD              | CompData_UC<br>CompData_UD_PD | RespSepData +<br>DataSepResp_UD_PD                                     |
| ReadPreferUnique | I, SC                                                      | -                    | SC              | CompData_SC                   | RespSepData +<br>DataSepResp_SC                                        |
|                  |                                                            |                      | UC              | CompData_UC                   | RespSepData +<br>DataSepResp_UC                                        |
|                  |                                                            |                      | UD              | CompData_UD_PD                | RespSepData +<br>DataSepResp_UD_PD                                     |
|                  |                                                            |                      | SD <sup>b</sup> | -                             | SD                                                                     |
| MakeReadUnique   | See Table 4-36 on page 4-216 and Table 4-37 on page 4-217. |                      | SD              | CompData_SC                   | RespSepData +<br>DataSepResp_SC                                        |
|                  |                                                            |                      | UD              | CompData_UC<br>CompData_UD_PD | RespSepData +<br>DataSepResp_UC,<br>RespSepData +<br>DataSepResp_UD_PD |
|                  |                                                            |                      | SD              | CompData_UC<br>CompData_UD_PD | RespSepData +<br>DataSepResp_UC,<br>RespSepData +<br>DataSepResp_UD_PD |
|                  |                                                            |                      | SD              | CompData_UC<br>CompData_UD_PD | RespSepData +<br>DataSepResp_UC,<br>RespSepData +<br>DataSepResp_UD_PD |

a. For ReadOnce\*, ReadNotSharedDirty and ReadShared transactions the Requester with an initial state of UCE must not upgrade the cache line to UDP nor UD while the request is outstanding.

b. A Requester in initial state of SD that receives a CompData\_SC or DataSepResp\_SC response must stay in SD state. Similarly, a Home that uses a Snoop filter to track the cached state at the Requester, must not downgrade the state of the cache line in the snoop filter based on the state in the response to the Requester.

c. Data received from memory must be dropped if the cache state is UD or SD, or merged if the cache state is UDP. Data received from memory must be the same as the cached data when the cache state is SC or UC.

#### MakeReadUnique transaction

This section describes the permitted responses, and the cache state transitions at the Requester, for the MakeReadUnique and MakeReadUnique(Excl) transactions. The additional MakeReadUnique(Excl) behavioral requirements are described in *MakeReadUnique(Excl)* on page 6-288.

#### Permitted responses

Table 4.34 shows the permitted responses in a MakeReadUnique transaction. Table 4.35 on page 4-214 shows the additional responses that are permitted only when the Exclusive bit in the request is set to one. This attribute is indicated by adding the suffix (Excl) to the request.

Some key features of the permitted responses are:

- A response without data, Comp\_UD\_PD, indicates that the Requester is being passed responsibility for a Dirty cache line.

This can occur when the Requester holds a Shared/Clean copy of the cache line and another agent holds a Shared/Dirty copy. It is permitted for the Home to invalidate the Shared/Dirty copy, for example using a SnpMakeInvalid transaction, and then pass the responsibility for the Dirty cache line to the Requester that issued the MakeReadUnique transaction.

- A response with a cache state of SC is only permitted in response to an Exclusive version of MakeReadUnique.

Comp\_SC, an example of a response with a cache state of SC, is sent when the Home determines that the Exclusive Store has failed but the snoop filter, or response to a SnpQuery snoop to the Requester, indicates that the Requester still holds a copy of the cache line while there is another shared copy in the system.

###### Note

The above situation can occur with a non-full address PoC exclusive monitor. The monitor bit for an LP can be reset by another LP performing an Exclusive store to a different address location. This store to a different address does not invalidate the cached copy of the address location being used for Exclusive access by the first Requester.

Table 4.34 shows the permitted responses in both the non-Exclusive and Exclusive MakeReadUnique transaction.

Table 4.34 Permitted responses in the MakeReadUnique transaction

| Response Received | Description                                                                                                                                                                          |
|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Comp_UC           | Requester retains its copy of the cache line.<br>All other cached copies have been invalidated.<br>Cache line might be Clean or Dirty at the Requester.                              |
| Comp_UD_PD        | Requester retains its copy of the cache line.<br>Dirty copy of the cache line held elsewhere has been invalidated.<br>Cache line must become Dirty at the Requester.                 |
| CompData_UC       | Requester lost the cache line while the transaction was in progress.<br>Clean copy of the cache line is given to the Requester.<br>Combined data and completion responses are given. |

Table 4-34 Permitted responses in the MakeReadUnique transaction (continued)

| Response Received                 | Description                                                                                                                                                                              |
|-----------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| CompData_UD_PD                    | Requester lost the cache line while the transaction was in progress.<br>Dirty copy of the cache line is given to the Requester.<br>Combined data and completion responses are given.     |
| RespSepData,<br>DataSepResp_UC    | Requester lost the cache line while the transaction was in progress.<br>Clean copy of the cache line is given to the Requester.<br>Separate data and completion responses are given.     |
| RespSepData,<br>DataSepResp_UD_PD | Requester lost the cache line while the transaction was in progress.<br>Dirty copy of the cache line is given to the Requester.<br>Separate data and completion responses given by Home. |

Table 4-35 shows the additional permitted responses in the Exclusive MakeReadUnique transaction.

Table 4-35 Additional permitted responses in the MakeReadUnique (Excl) transaction

| Response received             | Description                                                                                                                           |
|-------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| Comp_SC                       | Global Exclusive check fails.<br>Shared cached copy exists in another cache.<br>Requester retains its copy of the cache line.         |
| CompData_SC                   | Global Exclusive check fails.<br>Shared cached copy exists in another cache.<br>Requester might have lost its copy of the cache line. |
| RespSepData<br>DataSepResp_SC | Global Exclusive check fails.<br>Shared cached copy exists in another cache.<br>Requester might have lost its copy of the cache line. |

#### Expected snoops

The use of snoops by the Home to invalidate a cache line at the Snoopee in response to a non-Exclusive MakeReadUnique, or an Exclusive MakeReadUnique that passes an Exclusive check, are as follows:

- The Home is expected to use a SnpCleanInvalid snoop:
  - The Home is permitted to use SnpUnique instead of SnpCleanInvalid.
  - The Home is permitted to use SnpUniqueWd if it determines that the Requester has lost the cached copy of the cache line.
  - The Home is also permitted to use SnpMakeInvalid instead of SnpCleanInvalid if it determines that the Snoopee does not have a Dirty copy of the cache line.

See *Home behavior on page 6-289* for the types of snoops the Home is expected and permitted to use when an Exclusive MakeReadUnique request fails the Exclusive check.

#### Cache line state transitions

The final state of the cache line after a MakeReadUnique transaction depends on the state of the cache line immediately before the transaction response is received. This can be different from the state of the cache line at the point the transaction is issued.

For MakeReadUnique, the Requester must keep a copy of the cache line unless it receives an invalidating snoop.

- Invalidating snoops are SnpUnique, SnpUniqueFwd, SnpCleanInvalid, SnpMakeInvalid, SnpUniqueStash, and SnpMakeInvalidStash.
- The Requester is permitted to treat SnpPreferUnique and SnpPreferUniqueFwd as either invalidating or non-invalidating. The Home can determine how these snoops are treated by the Snoopee by inspecting the Snoop response.
- All other snoops are non-invalidating and the Requester is required to keep a copy of the cache line.

If the Home does not have an SF, or the SF is imprecise, and the Home cannot determine if the Requester still has a copy of the cache line at the point that the transaction completes, then the Home must assume the cache line is lost at the Requester and provide data with the response.

A Requester that receives a response with data, while still holding the line in SD state, must use its own copy of the cache line, rather than the copy returned with the response.

###### **Note**

A Requester that receives a response with data, while still holding the line in SD state implies there is no snoop filter present or that the snoop filter is imprecise. In this case, it is possible that the data returned with the response is Stale.

If the Requester is aware that there is no snoop filter, then it can use a CleanUnique transaction instead of MakeReadUnique to avoid an unnecessary memory read when the cache line is not cached at any other agent.

###### **Note**

Use of the CleanUnique transaction can avoid an unnecessary memory read in the absence of a snoop filter. The unnecessary memory read occurs when the cache line remains cached at the Requester, but a snoop filter is not present in the system or a SnpQuery snoop is not used and a cached copy is not available from another agent in the system. However, using a CleanUnique transaction will result in the Requester needing to issue another transaction in the case where the cache line is lost due to a snoop while the transaction is in progress.

Table 4-34 on page 4-213 shows the state transitions and responses that are applicable to both non-Exclusive and Exclusive versions of MakeReadUnique. Table 4-35 on page 4-214 shows the additional state transitions and responses that apply only to the Exclusive version of the request.

The response rules are:

- The cache state in the response to a non-Exclusive MakeReadUnique must be Unique.
- The cache state in the response to an Exclusive MakeReadUnique is permitted to be Unique or Shared.
- The cache state in the response to an Exclusive and to a Non-exclusive MakeReadUnique must not include Shared Dirty.
- For each permitted combined completion and data response, a corresponding response with separate completion and data is permitted.

Table 4-36 on page 4-216 and Table 4-37 on page 4-217 include columns for:

- The initial cache state.
- The cache state immediately before the transaction response is received.
- The final state for each of the possible response combinations.

The handling of a MakeReadUnique transaction at the Home depends on the availability or not of a precise Snoop Filter. Table 4-36 and Table 4-37 on page 4-217 also include the responses that are permitted with and without a precise Snoop Filter:

- The table column labeled: Snoop Filter - Precise, covers the cases when the precise state of the cache line at the Requester, at the response time, is known. The Home obtains the knowledge of precise state from a snoop filter, or by sending a SnpQuery snoop, or in some other IMPLEMENTATION DEFINED manner.
- The column labeled: Snoop Filter - Imprecise or Absent, covers the cases when the precise state of the cache line at the Requester, at the response time, is not known. This also includes the case when there is no snoop filter, or the Home might decide to ignore the available precise information, or not attempt to obtain the information.

Table 4-36 and Table 4-37 on page 4-217 use the following key:

| Y | Yes, permitted |
|---|----------------|
| - | Not permitted  |

Table 4-36 Cache state transitions at the Requester for the MakeReadUnique request (non-Excl and Excl)

| Cache State | At time of Response | Home sent invalidating snoop | Final | Snoop Filter                   |         |                     | Notes                                               |  |
|-------------|---------------------|------------------------------|-------|--------------------------------|---------|---------------------|-----------------------------------------------------|--|
|             |                     |                              |       | Comp Resp                      | Precise | Imprecise or Absent |                                                     |  |
| SD          | SD                  | No                           | UD    | Comp_UC                        | Y       | -                   | Returned data might be stale                        |  |
|             |                     |                              |       | CompData_UC                    | -       | Y                   |                                                     |  |
|             |                     |                              |       | RespSepData, DataSepResp_UC    | -       | Y                   |                                                     |  |
|             |                     |                              |       |                                |         |                     |                                                     |  |
| SC, SD      | SC                  | No                           | UC    | Comp_UC                        | Y       | -                   | Returned data might be stale                        |  |
|             |                     |                              |       | CompData_UC                    | -       | Y                   |                                                     |  |
|             |                     |                              |       | RespSepData, DataSepResp_UC    | -       | Y                   |                                                     |  |
|             |                     |                              | UD    | Comp_UD_PD                     | Y       | -                   | Data in response is identical to the Requester copy |  |
|             |                     |                              |       | CompData_UD_PD                 | -       | Y                   |                                                     |  |
|             |                     |                              |       | RespSepData, DataSepResp_UD_PD | -       | Y                   |                                                     |  |
| I           |                     | Yes                          | UC    | CompData_UC                    | Y       | Y                   | Line lost to an invalidating snoop                  |  |
|             |                     |                              |       | RespSepData, DataSepResp_UC    | Y       | Y                   |                                                     |  |
|             |                     |                              | UD    | CompData_UD_PD                 | Y       | Y                   |                                                     |  |
|             |                     |                              |       | RespSepData, DataSepResp_UD_PD | Y       | Y                   |                                                     |  |
| I, UC, UD   | Not permitted       |                              |       |                                |         |                     |                                                     |  |

Table 4-37 Additional Cache state transitions at the Requester for the MakeReadUnique(Excl) request

| Cache State | At time of Response | Home sent invalidating snoop | Final | Snoop Filter   |                     |   |
|-------------|---------------------|------------------------------|-------|----------------|---------------------|---|
|             |                     |                              |       | Comp Resp      | Imprecise or Absent |   |
| SC, SD      | SC                  | No                           | SC    | Comp_SC        | Y                   | - |
|             | I                   | Yes                          | SC    | CompData_SC    | Y                   | Y |
|             |                     |                              |       | RespSepData    | Y                   | Y |
|             |                     |                              |       | DataSepResp_SC |                     |   |
| SD          | SD                  | No                           | SD    | Comp_SC        | Y                   | - |
|             |                     |                              |       | CompData_SC    | -                   | Y |
|             |                     |                              |       | RespSepData    | -                   | Y |
|             |                     |                              |       | DataSepResp_SC |                     |   |

See *MakeReadUnique(Excl)* on page 6-288 for the additional *MakeReadUnique(Excl)* behavioral requirements.

### 4.7.2 Dataless request transactions

Table 4-38 shows the cache state transitions at the Requester, and the completion responses, for Dataless request transactions.

Table 4-38 Cache state transitions at the Requester for Dataless request transactions

| Request type          | Cache state |                  |           | Comp Response                          |
|-----------------------|-------------|------------------|-----------|----------------------------------------|
|                       | Initial     | Others permitted |           |                                        |
|                       | Expected    | Others permitted | Final     |                                        |
| CleanUnique           | 1           | UC, UCE          | UCE       | Comp_UC                                |
|                       | SC          | UC               | UC        | Comp_UC                                |
|                       | SD          | UD               | UD        | Comp_UC                                |
| MakeUnique            | 1, SC, SD   | UC, UCE          | UD        | Comp_UC                                |
| Evict                 | 1           | -                | 1         | Comp_I                                 |
| StashOnceUnique       | 1           | -                | 1         | Comp                                   |
| StashOnceSepUnique    | 1           | -                | 1         | Comp + StashDone<br>or CompStashDone   |
| StashOnceShared       | 1           | -                | 1         | Comp                                   |
| StashOnceSepShared    | 1           | -                | 1         | Comp + StashDone<br>or CompStashDone   |
| CleanShared           | 1, SC, UC   | -                | No Change | Comp_UC                                |
| CleanSharedPersist    |             |                  |           | Comp_SC                                |
|                       |             |                  |           | Comp_I                                 |
| CleanSharedPersistSep | 1, SC, UC   | -                | No Change | Comp_UC + Persist<br>or CompPersist_UC |
|                       |             |                  |           | Comp_SC + Persist<br>or CompPersist_SC |
|                       |             |                  |           | Comp_I + Persist<br>or CompPersist_I   |
| CleanInvalid          | 1           | -                | 1         | Comp_I                                 |
| MakeInvalid           | 1           | -                | 1         | Comp_I                                 |

Before a CleanInvalid, MakeInvalid, or Evict transaction it is permitted for the cache state to be UC, UCE or SC. However, it is required that the cache state transitions to the I state before the transaction is issued. Therefore, Table 4-38 shows I state as the only initial state.

### 4.7.3 Write request transactions

Table 4-39 shows the cache state transitions at the Requester, the WriteData response, and the combined or separate completion and DBIDResp response for Write and corresponding Combined Write request transactions. Combined Write request transactions are not listed in Table 4-39. See *Combined Write requests* on page 4-182.

Table 4-39 Requester cache state transitions for Write request transactions

| Request Type                            | Cache state at Requester |                                        | WriteData response                                          | Comp response                       |
|-----------------------------------------|--------------------------|----------------------------------------|-------------------------------------------------------------|-------------------------------------|
|                                         | Initial                  | Before WriteData response <sup>a</sup> |                                                             |                                     |
| WriteNoSnpPtl                           | I                        | -                                      | I<br>NCBWrData or<br>NCBWrDataCompAck or<br>WriteDataCancel | DBIDResp* + Comp<br>or CompDBIDResp |
| WriteNoSnpFull                          | I                        | -                                      | I<br>NCBWrData or<br>NCBWrDataCompAck                       | DBIDResp* + Comp<br>or CompDBIDResp |
| WriteNoSnpZero                          | I                        | -                                      | I<br>None                                                   | DBIDResp* + Comp<br>or CompDBIDResp |
| WriteUniquePtl<br>WriteUniquePtlStash   | I                        | I                                      | I<br>NCBWrData or<br>WriteDataCancel or<br>NCBWrDataCompAck | DBIDResp* + Comp<br>or CompDBIDResp |
| WriteUniqueZero                         | I                        | I                                      | I<br>None                                                   | DBIDResp* + Comp<br>or CompDBIDResp |
| WriteUniqueFull<br>WriteUniqueFullStash | I                        | I                                      | I<br>NCBWrData or<br>NCBWrDataCompAck                       | DBIDResp* + Comp<br>or CompDBIDResp |
| WriteBackFull                           | UD                       | UD                                     | I<br>CBWrData_UD_PD                                         | CompDBIDResp                        |
|                                         |                          | UC                                     | I<br>CBWrData_UC                                            | CompDBIDResp                        |
|                                         | UD, SD                   | SD                                     | I<br>CBWrData_SD_PD                                         | CompDBIDResp                        |
|                                         |                          | SC                                     | I<br>CBWrData_SC                                            | CompDBIDResp                        |
|                                         |                          | I                                      | I<br>CBWrData_I                                             | CompDBIDResp                        |
| WriteBackPtl                            | UDP                      | UDP                                    | I<br>CBWrData_UD_PD                                         | CompDBIDResp                        |
|                                         |                          | I                                      | I<br>CBWrData_I                                             | CompDBIDResp                        |
| WriteCleanFull                          | UD                       | UD                                     | UC<br>CBWrData_UD_PD                                        | CompDBIDResp                        |
|                                         |                          | UC                                     | UC<br>CBWrData_UC                                           | CompDBIDResp                        |
|                                         | UD, SD                   | SD                                     | SC<br>CBWrData_SD_PD                                        | CompDBIDResp                        |
|                                         |                          | SC                                     | SC<br>CBWrData_SC                                           | CompDBIDResp                        |
|                                         |                          | I                                      | I<br>CBWrData_I                                             | CompDBIDResp                        |
| WriteEvictFull                          | UC                       | UC                                     | I<br>CBWrData_UC                                            | CompDBIDResp                        |
|                                         |                          | SC                                     | I<br>CBWrData_SC                                            | CompDBIDResp                        |
|                                         |                          | I                                      | I<br>CBWrData_I                                             | CompDBIDResp                        |

Table 4-39 Requester cache state transitions for Write request transactions (continued)

| Request Type      | Cache state at Requester |                                        |       | WriteData response |                   | Comp response |  |
|-------------------|--------------------------|----------------------------------------|-------|--------------------|-------------------|---------------|--|
|                   | Initial                  | Before WriteData response <sup>a</sup> | Final |                    |                   |               |  |
| WriteEvictOrEvict | UC                       | UC <sup>b</sup>                        | I     | CBWrData_UC        | CompDBIDResp      |               |  |
|                   |                          |                                        | I     | None               | Comp <sup>c</sup> |               |  |
|                   | UC, SC                   | SC                                     | I     | CBWrData_SC        | CompDBIDResp      |               |  |
|                   |                          |                                        | I     | None               | Comp <sup>c</sup> |               |  |
|                   | I                        |                                        | I     | CBWrData_I         | CompDBIDResp      |               |  |
|                   |                          |                                        | I     | None               | Comp <sup>c</sup> |               |  |

a. A snoop might be received while a write is pending and results in a cache line state change before the WriteData response.

b. Once the request is sent the Requester is permitted to keep the cache state in UC but must not modify the cache line.

c. Comp is sent if the Home decides not to request data.

When the Requester receives a RetryAck response whose data is invalidated by a snoop, the Requester is permitted to send the Write request with AllowRetry set to zero, knowing that the subsequent Data response would be CopyBackWrData\_I.

###### — Note —

After completion of a WriteClean transaction, it is possible for the cache line in a Unique state to immediately transition to a Dirty state.

### 4.7.4 Atomic transactions

Table 4-40 shows the cache state transitions at the Requester, and the completion and response for Atomic transactions.

Table 4-40 Requester cache state transitions for Atomic request transactions

| Atomic request | Cache state      |             |                  | WriteData response | Comp response                         |
|----------------|------------------|-------------|------------------|--------------------|---------------------------------------|
|                | Initial          | Final       |                  |                    |                                       |
|                |                  | Expected    | Others permitted |                    |                                       |
| AtomicStore    | I, SC<br>UCE, SD | UC, UD, UDP | I                | NCBWrData          | DBIDResp* + Comp_I<br>or CompDBIDResp |
| AtomicLoad     | I, SC<br>UCE, SD | UC, UD, UDP | I                | NCBWrData          | DBIDResp* +<br>CompData_I             |
| AtomicSwap     | I, SC<br>UCE, SD | UC, UD, UDP | I                | NCBWrData          | DBIDResp* +<br>CompData_I             |
| AtomicCompare  | I, SC<br>UCE, SD | UC, UD, UDP | I                | NCBWrData          | DBIDResp* +<br>CompData_I             |

### 4.7.5 Other request transactions

DVMOp and PrefetchTgt requests do not have any cache state transitions associated with them.

## 4.8 Cache state transitions at a Snoopee

This section specifies the cache state transitions and completion responses for the following Snoop transactions:

- [Non-Forwarding and Non-stash Snoop transactions](#)
- [Stash snoop transactions on page 4-227](#)
- [Forwarding Snoop transactions on page 4-229](#)

A Snoopee, an RN-F that receives a snoop, performs two actions. One action is a state change of the cached line and the second action is sending a response message either to the Home, or to both the Home and the Requester.

The cache state change depends on the snoop type, the initial state of the cache line and the value of DoNotGoToSD in the snoop. See [Do not transition to SD on page 4-241](#).

The Snoopee must send a response to Home either with Data or without Data. In addition, for Forwarding snoops the Snoopee can also forward a Data response to the Requester.

The type of response sent is determined by the snoop type, initial cache state, cache state change, and the value of RetToSrc. See [Returning Data with Snoop response on page 4-240](#).

### 4.8.1 Non-Forwarding and Non-stash Snoop transactions

The Non-forwarding and Non-stash Snoop transactions are:

- SnpOnce
- SnpClean, SnpShared, SnpNotSharedDirty
- SnpUnique, SnpPreferUnique
- SnpCleanShared, SnpCleanInvalid, SnpMakeInvalid
- SnpQuery

#### SnpOnce

Table 4-41 on page 4-222 shows for SnpOnce, the initial, expected final, and other permitted final cache states at the snooped Requester, the RetToSrc field value, and the valid completion response from a snooped RN-F.

Table 4-41 Cache state transitions, RetToSrc value, and valid completion responses

| Snoop request type | Initial cache state | Final cache state |                  |                       | Snoop response    |
|--------------------|---------------------|-------------------|------------------|-----------------------|-------------------|
|                    |                     | Expected          | Others permitted | RetToSrc <sup>a</sup> |                   |
| SnpOnce            | I                   | I                 | -                | X                     | SnpResp_I         |
|                    | UC                  | UC                | I, SC            | X                     | SnpResp_UC        |
|                    |                     |                   |                  |                       | SnpRespData_UC    |
|                    |                     | SC                | I                | X                     | SnpResp_SC        |
|                    |                     |                   |                  | SnpRespData_SC        |                   |
|                    | I                   | -                 | X                | SnpResp_I             |                   |
|                    |                     |                   |                  | SnpRespData_I         |                   |
|                    | UCE                 | UCE               | I                | X                     | SnpResp_UC        |
|                    |                     | I                 | -                | X                     | SnpResp_I         |
|                    | UD                  | UD                | SD               | X                     | SnpRespData_UD    |
|                    |                     | SD                | -                | X                     | SnpRespData_SD    |
|                    |                     | SC                | I                | X                     | SnpRespData_SC_PD |
|                    | I                   | -                 | X                | SnpRespData_I_PD      |                   |
| UDP                | I                   | -                 | X                | SnpRespDataPt_I_PD    |                   |
|                    | UDP                 | -                 | X                | SnpRespDataPt_UD      |                   |
| SC                 | SC                  | I                 | 0                | SnpResp_SC            |                   |
|                    |                     |                   | 1                | SnpRespData_SC        |                   |
|                    | I                   | -                 | 0                | SnpResp_I             |                   |
|                    |                     |                   | 1                | SnpRespData_I         |                   |
| SD                 | SD                  | -                 | X                | SnpRespData_SD        |                   |
|                    | SC                  | I                 | X                | SnpRespData_SC_PD     |                   |
|                    | I                   | -                 | X                | SnpRespData_I_PD      |                   |

a. X indicates that the protocol requirements apply for both states of RetToSrc.

#### **SnpClean, SnpShared, SnpNotSharedDirty, and SnpPreferUnique**

Table 4-42 shows for SnpClean, SnpShared, SnpNotSharedDirty and SnpPreferUnique the initial, expected final, and other permitted final cache states at the snooped Requester, the RetToSrc field value, and the valid completion response from a snooped RN-F. Table 4-42 must be used to determine SnpPreferUnique cache state transitions when the Snoopee is in the middle of executing an Exclusive access sequence. A Snoopee that is not in the middle of executing an Exclusive access is permitted, but not expected, to use Table 4-42 to determine SnpPreferUnique cache state transitions.

See *SnpPreferUnique and SnpPreferUniqueFwd* on page 4-236 for constraints on determining when a Requester is in the middle of executing an exclusive sequence.

**Table 4-42 Cache state transitions, RetToSrc value, and valid completion responses**

| Snoop request type                                                   | Initial cache state | Final cache state |                  |                       | Snoop response |
|----------------------------------------------------------------------|---------------------|-------------------|------------------|-----------------------|----------------|
|                                                                      |                     | Expected          | Others permitted | RetToSrc <sup>a</sup> |                |
| SnpClean, SnpShared, SnpNotSharedDirty, SnpPreferUnique <sup>b</sup> | I                   | I                 | -                | X                     | SnpResp_I      |
|                                                                      | UC                  | SC                | I                | X                     | SnpResp_SC     |
|                                                                      |                     | I                 | -                | X                     | SnpRespData_SC |
|                                                                      | I                   | -                 | X                | SnpResp_I             |                |
| UCE                                                                  | I                   | -                 | X                | SnpRespData_I         |                |
|                                                                      | I                   | -                 | X                | SnpResp_I             |                |
| UD                                                                   | SD <sup>c</sup>     | -                 | X                | SnpRespData_SD        |                |
|                                                                      | SC                  | I                 | X                | SnpRespData_SC_PD     |                |
|                                                                      | I                   | -                 | X                | SnpRespData_I_PD      |                |
| UDP                                                                  | I                   | -                 | X                | SnpRespDataPtl_I_PD   |                |
| SC                                                                   | SC                  | SC                | I                | 0                     | SnpResp_SC     |
|                                                                      |                     | I                 | -                | 1                     | SnpRespData_SC |
|                                                                      | I                   | -                 | 0                | SnpResp_I             |                |
|                                                                      |                     | -                 | 1                | SnpRespData_I         |                |
| SD                                                                   | SD <sup>c</sup>     | -                 | X                | SnpRespData_SD        |                |
|                                                                      | SC                  | I                 | X                | SnpRespData_SC_PD     |                |
|                                                                      | I                   | -                 | X                | SnpRespData_I_PD      |                |

a. X indicates that the protocol requirements apply for both states of RetToSrc.

b. Applicable when the Snoopee is in the middle of executing an Exclusive sequence. Protocol compliant at any time. See also Table 4-43 on page 4-224.

c. This state transition is not permitted if DoNotGoToSD is set.

#### SnpUnique and SnpPreferUnique

Table 4-43 shows for SnpUnique and SnpPreferUnique the initial, expected final, and other permitted final cache states at the snooped Requester, the RetToSrc field value, and the valid completion response from a snooped RN-F for SnpUnique. Table 4-43 is expected to be used to determine SnpPreferUnique cache state transitions when the Snoopee is not in the middle of executing an Exclusive access sequence.

Table 4-43 Cache state transitions, RetToSrc value, and valid completion responses

| Snoop request type                      | Initial cache state | Final cache state |                  |                       | Snoop response             |
|-----------------------------------------|---------------------|-------------------|------------------|-----------------------|----------------------------|
|                                         |                     | Expected          | Others permitted | RetToSrc <sup>a</sup> |                            |
| SnpUnique, SnpPreferUnique <sup>b</sup> | I                   | I                 | -                | X                     | SnpResp_I                  |
|                                         | UC                  | I                 | -                | X                     | SnpResp_I<br>SnpRespData_I |
|                                         | UCE                 | I                 | -                | X                     | SnpResp_I                  |
|                                         | UD                  | I                 | -                | X                     | SnpRespData_I_PD           |
|                                         | UDP                 | I                 | -                | X                     | SnpRespDataPtl_I_PD        |
|                                         | SC                  | I                 | -                | 0                     | SnpResp_I                  |
|                                         |                     |                   |                  | 1                     | SnpRespData_I              |
|                                         | SD                  | I                 | -                | X                     | SnpRespData_I_PD           |

a. X indicates that the protocol requirements apply for both states of RetToSrc.

b. Only applicable when the Snoopee is not in the middle of executing an Exclusive sequence.

#### **SnpCleanShared, SnpCleanInvalid, and SnpMakeInvalid**

Table 4-44 shows for SnpCleanShared, SnpCleanInvalid, and SnpMakeInvalid the initial, expected final, and other permitted final cache states at the snooped Requester, the RetToSrc field value, and the valid completion response from a snooped RN-F.

**Table 4-44 Cache state transitions, RetToSrc value, and valid completion responses**

| Snoop request type | Initial cache state | Final cache state |                  |           | Snoop response      |
|--------------------|---------------------|-------------------|------------------|-----------|---------------------|
|                    |                     | Expected          | Others permitted | RetToSrc  |                     |
| SnpCleanShared     | I                   | I                 | -                | 0         | SnpResp_I           |
|                    | UC                  | UC                | I, SC            | 0         | SnpResp_UC          |
|                    |                     | SC                | I                | 0         | SnpResp_SC          |
|                    |                     | I                 | -                | 0         | SnpResp_I           |
|                    | UCE                 | I                 | -                | 0         | SnpResp_I           |
|                    | UD                  | UC                | I, SC            | 0         | SnpRespData_UC_PD   |
|                    |                     | SC                | I                | 0         | SnpRespData_SC_PD   |
|                    |                     | I                 | -                | 0         | SnpRespData_I_PD    |
|                    | UDP                 | I                 | -                | 0         | SnpRespDataPtl_I_PD |
|                    | SC                  | SC                | I                | 0         | SnpResp_SC          |
|                    | I                   | -                 | 0                | SnpResp_I |                     |
| SnpCleanInvalid    | SD                  | SC                | I                | 0         | SnpRespData_SC_PD   |
|                    |                     | I                 | -                | 0         | SnpRespData_I_PD    |
| SnpMakeInvalid     | I                   | I                 | -                | 0         | SnpResp_I           |
|                    | UC                  | I                 | -                | 0         | SnpResp_I           |
|                    | UCE                 | I                 | -                | 0         | SnpResp_I           |
|                    | UD                  | I                 | -                | 0         | SnpRespData_I_PD    |
|                    | UDP                 | I                 | -                | 0         | SnpRespDataPtl_I_PD |
|                    | SC                  | I                 | -                | 0         | SnpResp_I           |
|                    | SD                  | I                 | -                | 0         | SnpRespData_I_PD    |
|                    | I                   | I                 | -                | 0         | SnpResp_I           |
|                    | UC                  | I                 | -                | 0         | SnpResp_I           |
|                    | UCE                 | I                 | -                | 0         | SnpResp_I           |
| UD                 | I                   | -                 | 0                | SnpResp_I |                     |
| UDP                | I                   | -                 | 0                | SnpResp_I |                     |
| SC                 | I                   | -                 | 0                | SnpResp_I |                     |
| SD                 | I                   | -                 | 0                | SnpResp_I |                     |

#### SnpQuery

Table 4-45 shows for SnpQuery the initial, expected final, and other permitted final cache states at the snooped Requester, the RetToSrc field value, and the valid completion response from a snooped RN-F.

Table 4-45 Cache state transitions, RetToSrc value, and valid completion responses

| Snoop request type | Initial cache state | Final cache state |                  | RetToSrc | Snoop response |
|--------------------|---------------------|-------------------|------------------|----------|----------------|
|                    |                     | Expected          | Others permitted |          |                |
| SnpQuery           | I                   | I                 | -                | 0        | SnpResp_I      |
|                    | UC                  | UC                | -                | 0        | SnpResp_UC     |
|                    | UCE                 | UCE               | -                | 0        | SnpResp_UC     |
|                    | UD                  | UD                | -                | 0        | SnpResp_UD     |
|                    | UDP                 | UDP               | -                | 0        | SnpResp_UD     |
|                    | SC                  | SC                | -                | 0        | SnpResp_SC     |
|                    | SD                  | SD                | -                | 0        | SnpResp_SD     |

### 4.8.2 Stash snoop transactions

The following sub-sections show the permitted responses for the Stash type snoops.

#### **SnpUniqueStash and SnpMakeInvalidStash**

The permitted responses to SnpUniqueStash and SnpMakeInvalidStash are the same as the responses to SnpUnique and SnpMakeInvalid respectively.

The RetToSrc bit value must not be set to 1 in SnpUniqueStash and SnpMakeInvalidStash.

Any Snoop response to SnpUniqueStash and SnpMakeInvalidStash can include a Data Pull request. A Data Pull request in a Snoop response to SnpUniqueStash and SnpMakeInvalidStash must be treated as a ReadUnique request.

Table 4-46 shows the Snoopee cache state transitions and required Snoop responses. The Snoop responses do not include the Data Pull options. Data Pull is permitted with any Snoop response.

**Table 4-46 Snoop response to SnpUniqueStash and SnpMakeInvalidStash**

| Snoop request type  | Cache state |                   |                     | RetToSrc         | Snoop response      |
|---------------------|-------------|-------------------|---------------------|------------------|---------------------|
|                     | Initial     | Final<br>Expected | Others<br>permitted |                  |                     |
| SnpUniqueStash      | I           | I                 | -                   | 0                | SnpResp_I           |
|                     | UC          | I                 | -                   | 0                | SnpRespData_I       |
|                     |             |                   |                     |                  | SnpResp_I           |
|                     | UCE         | I                 | -                   | 0                | SnpResp_I           |
|                     | UD          | I                 | -                   | 0                | SnpRespData_I_PD    |
|                     | UDP         | I                 | -                   | 0                | SnpRespDataPtl_I_PD |
|                     | SC          | I                 | -                   | 0                | SnpResp_I           |
|                     |             |                   |                     |                  | SnpRespData_I       |
|                     |             |                   |                     |                  | SnpRespData_I_PD    |
| SD                  | I           | -                 | 0                   | SnpRespData_I_PD |                     |
| SnpMakeInvalidStash | Any         | I                 | -                   | 0                | SnpResp_I           |

#### SnpStashUnique and SnpStashShared

For SnpStashUnique and SnpStashShared, the Snoopee must not change cache state.

The Snoopee is permitted to not perform a cache lookup before responding, in which case the Snoop response must be SnpResp\_I.

The Snoopee is permitted to include the precise cache state in the response.

A Snoop response can include Data Pull only if the cache state in the response is precise.

The Snoopee can include a Data Pull in response to a SnpStashUnique only if the cache-data is not present, or present in a Shared state. The Snoopee can include Data Pull in response to SnpStashShared only if the cache cache-data is not present.

A Data Pull request in a Snoop response to SnpStashUnique must be treated as a ReadUnique request. A Data Pull request in a Snoop response to SnpStashShared must be treated as a ReadNotSharedDirty request.

The inclusion of Data Pull in the Snoop response must ensure that the initial state must not violate the initial state conditions permitted for the corresponding independent Read requests. See [Read transactions on page 4-163](#).

Table 4-47 shows the Snoopee cache state transitions, the required Snoop responses, and Data Pull options for SnpStashUnique.

Table 4-47 Snoop response to SnpStashUnique

| Snoop request type | Cache state |                   |                     | RetToSrc        | Snoop response  |
|--------------------|-------------|-------------------|---------------------|-----------------|-----------------|
|                    | Initial     | Final<br>Expected | Others<br>permitted |                 |                 |
| SnpStashUnique     | I           | I                 | -                   | 0               | SnpResp_I       |
|                    |             |                   |                     |                 | SnpResp_I_Read  |
|                    | UC          | UC                | -                   | 0               | SnpResp_UC      |
|                    |             |                   |                     |                 | SnpResp_I       |
|                    | UCE         | UCE               | -                   | 0               | SnpResp_UC      |
|                    |             |                   |                     |                 | SnpResp_UC_Read |
|                    |             |                   |                     |                 | SnpResp_I       |
|                    | UD          | UD                | -                   | 0               | SnpResp_UD      |
|                    |             |                   |                     |                 | SnpResp_I       |
|                    | UDP         | UDP               | -                   | 0               | SnpResp_UD      |
|                    |             |                   |                     | SnpResp_I       |                 |
| SC                 | SC          | -                 | 0                   | SnpResp_SC      |                 |
|                    |             |                   |                     | SnpResp_SC_Read |                 |
|                    |             |                   |                     | SnpResp_I       |                 |
| SD                 | SD          | -                 | 0                   | SnpResp_SD      |                 |
|                    |             |                   |                     | SnpResp_SD_Read |                 |
|                    |             |                   |                     | SnpResp_I       |                 |

Table 4-48 shows the Snoopee cache state transitions, the required Snoop responses, and Data Pull options for SnpStashShared.

Table 4-48 Snoop response to SnpStashShared

| Snoop request type | Cache state |                   |                     | RetToSrc | Snoop response                             |
|--------------------|-------------|-------------------|---------------------|----------|--------------------------------------------|
|                    | Initial     | Final<br>Expected | Others<br>permitted |          |                                            |
| SnpStashShared     | I           | I                 | -                   | 0        | SnpResp_I_Read<br>SnpResp_I                |
|                    | UC          | UC                | -                   | 0        | SnpResp_UC<br>SnpResp_I                    |
| UCE                | UCE         | UCE               | -                   | 0        | SnpResp_UC<br>SnpResp_UC_Read<br>SnpResp_I |
|                    |             |                   |                     |          | SnpResp_I                                  |
| UD                 | UD          | UD                | -                   | 0        | SnpResp_UD<br>SnpResp_I                    |
|                    |             |                   |                     |          | SnpResp_I                                  |
| UDP                | UDP         | UDP               | -                   | 0        | SnpResp_UD<br>SnpResp_I                    |
|                    |             |                   |                     |          | SnpResp_I                                  |
| SC                 | SC          | SC                | -                   | 0        | SnpResp_SC<br>SnpResp_I                    |
|                    |             |                   |                     |          | SnpResp_I                                  |
| SD                 | SD          | SD                | -                   | 0        | SnpResp_SD<br>SnpResp_I                    |
|                    |             |                   |                     |          | SnpResp_I                                  |

### 4.8.3 Forwarding Snoop transactions

Forwarding (Fwd) type snoop are used by Home to support DCT. The rules, common to all Forwarding snoop at the Snoopee are:

- Expected, but not required, to forward a copy of the cache line to the Requester if the cache line is in one of the following states:
  - UD
  - UC
  - SD
  - SC
- The Snoopee is permitted, but not expected, to convert the Snoop to its corresponding Non-forwarding type.
- Must not forward data in Unique state in response to a Non-invalidating type snoop.
- Snoopee receiving a Snoop request with the DoNotGoToSD bit set, except when the Snoop is SnpOnceFwd, must not transition to SD, even if the coherency conditions permit it.

- In certain cases, based on the Snoope type, the state of the cache line at the Snoopee, and the RetToSrc value in the Snoope request, the Snoopee forwards a copy to Home along with a copy to the Requester. Forwarding snoops must not be used if the original request requests tags.

If tags are available, Clean tags are permitted to be forwarded to the Requester along with the data.

- Home is not permitted to send a Forwarding type snoop for:

- Atomic transactions
- Passing Exclusive read transactions

**Note**

Exclusive read transactions that fail due to Non-exclusive support for the address range being accessed are treated as corresponding Non-exclusive reads, Home can therefore use Forwarding type snoops in these cases.

For the rules that are specific to a particular Forwarding snoop see the individual sub-sections in *Forwarding Snoop transactions* on page 4-229.

The tables in the following individual sub-sections show the Snoopee state transitions and the corresponding responses to the Requester and the Home.

The first column in the tables shows the initial cache state, and is the combined data and tag state. Table 4-49 shows the combined state used and the corresponding data and possible tag state combinations.

Table 4-49 Combined state and the corresponding data and tag states

| Combined state | Data state | Tag state           |
|----------------|------------|---------------------|
| I              | I          | I                   |
| UC             | UC         | I<br>Clean          |
| UCE            | UCE        | I                   |
| UD             | UD         | I<br>Clean<br>Dirty |
| UDP            | UDP        | I                   |
| SC             | SC         | I<br>Clean          |
| SD             | SD         | I<br>Clean<br>Dirty |

The last three columns in the tables correspond to the TagOp value in the Data responses to Home. They are organized, based on the initial state of the tags:

#### **Dirty** Two columns:

- First column: Indicates if the transition itself is permitted or not. This column is only relevant when the tag initial state is Dirty.

Table 4-50 shows the conventions used, P and NP are only relevant when the data initial state is UD or SD and the tag initial state is Dirty.

Table 4-50 Key to table conventions

| Symbol | Description                     |
|--------|---------------------------------|
| P      | The transition is permitted     |
| NP     | The transition is not permitted |
| -      | TagOp is not applicable         |

- Second column: The response TagOp value when the transition is permitted. The TagOp value in the response:
  - — Must be *Update* if the response state includes Pass Dirty.
  - — Must be *Transfer* if the response does not include Pass Dirty.

#### Invalid, Clean

One column:

- TagOp in the response can be:
  - — *Invalid* if the initial tag state is Invalid or Clean.
  - — *Transfer* when the initial tag state is Clean.

In Snoop responses to Home without data, TagOp is inapplicable.

#### SnpOnceFwd

The rules, in addition to the common rules, to be followed by a Snoopee that receives a SnpOnceFwd are:

- Snoopee must forward the cache line in I state.
  - — As a consequence, the Snoopee must not forward Pass Dirty to the Requester.
- Snoopee must return data to Home only when Dirty state is changed to Clean or Invalid.
- RetToSrc bit in the snoop must be set to zero.
- Snoopee can ignore the DoNotGoToSD value in the snoop.

Table 4-51 shows the Snoopee cache state transitions and the required Snoop responses.

See Table 4-50 for the symbol key.

Table 4-51 SnpOnceFwd Snoopee state transitions with Clean and Dirty tags

| Snoopee cache state |       | Response to |                 | TagOp value in response to Home |                    |       |          |
|---------------------|-------|-------------|-----------------|---------------------------------|--------------------|-------|----------|
| Initial             | Final | RetToSrc    |                 | Initial tag state               |                    |       |          |
|                     |       | Expected    | Other permitted | Requester                       | Home               | Dirty | I. Clean |
| I                   | I     | -           | 0               | No Fwd                          | SnpResp_I          | -     | -        |
| UC                  | UC    | -           | 0               | CompData_I                      | SnpResp_UC_Fwded_I | -     | -        |
|                     | SC    | I           | 0               | CompData_I                      | SnpResp_SC_Fwded_I | -     | -        |
|                     | I     | -           | 0               | CompData_I                      | SnpResp_I_Fwded_I  | -     | -        |

Table 4-51 SnpOnceFwd Snoopee state transitions with Clean and Dirty tags (continued)

| Snoopee cache state |                   | Response to        |          | TagOp value in response to Home |                           |                   |                     |
|---------------------|-------------------|--------------------|----------|---------------------------------|---------------------------|-------------------|---------------------|
| Initial             | Final<br>Expected | Other<br>permitted | RetToSrc | Requester                       | Home                      | Initial tag state |                     |
|                     |                   |                    |          |                                 |                           | Dirty             | I. Clean            |
| UCE                 | UCE               | -                  | 0        | No Fwd                          | SnpResp_UC                | -                 | -                   |
|                     | I                 | -                  | 0        | No Fwd                          | SnpResp_I                 | -                 | -                   |
| UD                  | UD                | -                  | 0        | CompData_I                      | SnpResp_UD_Fwded_I        | P <sup>a</sup>    | -                   |
|                     | SD                | -                  | 0        | CompData_I                      | SnpResp_SD_Fwded_I        | P <sup>a</sup>    | -                   |
|                     | SC                | I                  | 0        | CompData_I                      | SnpRespData_SC_PD_Fwded_I | P                 | Update <sup>b</sup> |
|                     | I                 | -                  | 0        | CompData_I                      | SnpRespData_I_PD_Fwded_I  | P                 | Update              |
| UDP                 | UDP               | -                  | 0        | No Fwd                          | SnpRespDataPtl_UD         | -                 | -                   |
|                     | I                 | -                  | 0        | No Fwd                          | SnpRespDataPtl_I_PD       | -                 | I                   |
| SC                  | SC                | I                  | 0        | No Fwd                          | SnpResp_SC                | -                 | -                   |
|                     |                   |                    |          | CompData_I                      | SnpResp_SC_Fwded_I        | -                 | -                   |
|                     | I                 | -                  | 0        | No Fwd                          | SnpResp_I                 | -                 | -                   |
|                     |                   |                    |          | CompData_I                      | SnpResp_I_Fwded_I         | -                 | -                   |
| SD                  | SD                | -                  | 0        | CompData_I                      | SnpResp_SD_Fwded_I        | P <sup>a</sup>    | -                   |
|                     | SC                | I                  | 0        | CompData_I                      | SnpRespData_SC_PD_Fwded_I | P                 | Update              |
|                     | I                 | -                  | 0        | CompData_I                      | SnpRespData_I_PD_Fwded_I  | P                 | Update              |

1. This transition is permitted, even though the Snoop response does not include data and the tag state is Dirty, because Dirty tags are retained by the Snoopee.
2. This transition from tag state of Dirty is permitted because a Dirty copy of tags and data are passed to the Home.
3. This transaction from an initial state of Dirty data, and Invalid or Clean tags, includes the Snoop response of data with Clean tags when available.

#### SnpCleanFwd, SnpNotSharedDirtyFwd

The rules, in addition to the common rules, to be followed by a Snoopee that receives a SnpCleanFwd or a SnpNotSharedDirtyFwd are:

- Snoopee must forward the cache line in SC state.
- Snoopee must transition to either SD, SC, or I state.
- For behavior related to the RetToSrc bit see *Returning Data with Snoop response on page 4-240*.

Table 4-52 shows the Snoopee cache state transitions and the required Snoop responses.

See Table 4-50 on page 4-231 for the symbol key.

Table 4-52 SnpCleanFwd and SnpNotSharedDirtyFwd Snoopee state transitions with Clean and Dirty tags

| Snoopee cache (data+tag) state |                   |                    | Response to    |             | TagOp value in response to Home |          |          |             |
|--------------------------------|-------------------|--------------------|----------------|-------------|---------------------------------|----------|----------|-------------|
| Initial                        | Final<br>Expected | Other<br>permitted | RetToSrc       |             | Initial tag state               |          |          |             |
|                                |                   |                    | Requester      | Home        | Dirty                           | I, Clean |          |             |
| I                              | I                 | -                  | X <sup>a</sup> | No Fwd      | SnpResp_I                       | -        | -        | -           |
| UC                             | SC                | I                  | 0              | CompData_SC | SnpResp_SC_Fwded_SC             | -        | -        | -           |
|                                |                   |                    | 1              | CompData_SC | SnpRespData_SC_Fwded_SC         | -        | -        | I, Transfer |
|                                |                   |                    | 0              | CompData_SC | SnpResp_I_Fwded_SC              | -        | -        | -           |
| UCE                            | I                 | -                  | 1              | CompData_SC | SnpRespData_I_Fwded_SC          | -        | -        | I, Transfer |
|                                |                   |                    | X <sup>a</sup> | No Fwd      | SnpResp_I                       | -        | -        | -           |
| UD                             | SD <sup>b</sup>   | -                  | 0              | CompData_SC | SnpResp_SD_Fwded_SC             | P        | -        | -           |
|                                |                   |                    | 1              | CompData_SC | SnpRespData_SD_Fwded_SC         | P        | Transfer | I, Transfer |
|                                |                   |                    | X <sup>a</sup> | CompData_SC | SnpRespData_SC_PD_Fwded_SC      | P        | Update   | I, Transfer |
| UDP                            | I                 | -                  | X <sup>a</sup> | CompData_SC | SnpRespData_I_PD_Fwded_SC       | P        | Update   | I, Transfer |
|                                |                   |                    | X <sup>a</sup> | No Fwd      | SnpRespDataPl_I_PD              | -        | -        | I           |
| SC                             | SC                | I                  | 0              | CompData_SC | SnpResp_SC_Fwded_SC             | -        | -        | -           |
|                                |                   |                    | 1              | CompData_SC | SnpRespData_SC_Fwded_SC         | -        | -        | I, Transfer |
|                                |                   |                    | 0              | CompData_SC | SnpResp_I_Fwded_SC              | -        | -        | -           |
| SD                             | SD <sup>b</sup>   | -                  | 1              | CompData_SC | SnpRespData_I_Fwded_SC          | -        | -        | I, Transfer |
|                                |                   |                    | 0              | CompData_SC | SnpResp_SD_Fwded_SC             | P        | -        | -           |
|                                |                   |                    | X <sup>a</sup> | CompData_SC | SnpRespData_SC_PD_Fwded_SC      | P        | Update   | I, Transfer |
| SC                             | I                 | -                  | X <sup>a</sup> | CompData_SC | SnpRespData_I_PD_Fwded_SC       | P        | Update   | I, Transfer |
|                                |                   |                    | X <sup>a</sup> | CompData_SC | SnpRespData_I_PD_Fwded_SC       | P        | Update   | I, Transfer |

a. The protocol requirements apply for both states of RetToSrc.

b. This state transition is not permitted if DoNotGoToSD is asserted.

#### SnpSharedFwd

The rules, in addition to the common rules, to be followed by a Snoopee that receives a SnpSharedFwd are:

- Snoopee is permitted to forward the cache line in either SD or SC state.
- Snoopee must transition to either SD, SC, or I state.
- For behavior related to the RetToSrc bit see [Returning Data with Snoop response on page 4-240](#).

Table 4-53 shows the Snoopee cache state transition and the required Snoop responses.

See Table 4-50 on page 4-231 for the symbol key.

Table 4-53 SnpSharedFwd Snoopee state transitions with Clean and Dirty tags

| Snoopee cache state |                 |                 | Response to    |                |                            | TagOp value in response to Home |             |             |
|---------------------|-----------------|-----------------|----------------|----------------|----------------------------|---------------------------------|-------------|-------------|
| Initial             | Final           |                 | Requester      | Home           | Initial tag state          | Dirty                           | I, Clean    |             |
|                     | Expected        | Other permitted |                |                |                            |                                 |             |             |
| I                   | I               | -               | X <sup>a</sup> | No Fwd         | SnpResp_I                  | -                               | -           |             |
|                     | SC              | I               | 0              | CompData_SC    | SnpResp_SC_Fwded_SC        | -                               | -           |             |
| UC                  | I               | -               | 1              | CompData_SC    | SnpRespData_SC_Fwded_SC    | -                               | I, Transfer |             |
|                     |                 | -               | 0              | CompData_SC    | SnpResp_I_Fwded_SC         | -                               | -           |             |
|                     | I               | -               | 1              | CompData_SC    | SnpRespData_I_Fwded_SC     | -                               | I, Transfer |             |
|                     |                 | -               | 0              | CompData_SC    | SnpResp_I_Fwded_SC         | -                               | -           |             |
| UCE                 | I               | -               | X <sup>a</sup> | No Fwd         | SnpResp_I                  | -                               | -           |             |
| UD                  | SD <sup>b</sup> | -               | 0              | CompData_SC    | SnpResp_SD_Fwded_SC        | P                               | -           |             |
|                     |                 | -               | 1              | CompData_SC    | SnpRespData_SD_Fwded_SC    | P                               | Transfer    |             |
|                     | SC              | I               | -              | 0              | CompData_SD_PD             | SnpResp_SC_Fwded_SD_PD          | NP          | -           |
|                     |                 |                 | -              | 1              | CompData_SD_PD             | SnpRespData_SC_Fwded_SD_PD      | NP          | I, Transfer |
| -                   |                 | -               | X <sup>a</sup> | CompData_SC    | SnpRespData_SC_PD_Fwded_SC | P                               | Update      |             |
| I                   | I               | -               | 0              | CompData_SD_PD | SnpResp_I_Fwded_SD_PD      | NP                              | -           |             |
|                     |                 | -               | 1              | CompData_SD_PD | SnpRespData_I_Fwded_SD_PD  | NP                              | I, Transfer |             |
|                     | -               | -               | X <sup>a</sup> | CompData_SC    | SnpRespData_I_PD_Fwded_SC  | P                               | Update      |             |
| UDP                 | I               | -               | X <sup>a</sup> | No Fwd         | SnpRespDataPtl_I_PD        | -                               | I           |             |
| SC                  | SC              | I               | 0              | CompData_SC    | SnpResp_SC_Fwded_SC        | -                               | -           |             |
|                     |                 | -               | 1              | CompData_SC    | SnpRespData_SC_Fwded_SC    | -                               | I, Transfer |             |
|                     | I               | -               | 0              | CompData_SC    | SnpResp_I_Fwded_SC         | -                               | -           |             |
|                     |                 | -               | 1              | CompData_SC    | SnpRespData_I_Fwded_SC     | -                               | I, Transfer |             |

Table 4-53 SnpSharedFwd Snoopee state transitions with Clean and Dirty tags (continued)

| Snoopee cache state | Final           |                 | Response to    |                | TagOp value in response to Home |          |          |             |
|---------------------|-----------------|-----------------|----------------|----------------|---------------------------------|----------|----------|-------------|
|                     | Expected        | Other permitted | Requester      | Home           | Initial tag state               |          |          |             |
|                     |                 |                 |                |                | Dirty                           | I, Clean |          |             |
| SD                  | SD <sup>b</sup> | -               | 0              | CompData_SC    | SnpResp_SD_Fwded_SC             | P        | -        | -           |
|                     |                 |                 | 1              | CompData_SC    | SnpRespData_SD_Fwded_SC         | P        | Transfer | I, Transfer |
| SC                  | I               |                 | 0              | CompData_SD_PD | SnpResp_SC_Fwded_SD_PD          | NP       | -        | -           |
|                     |                 |                 | 1              | CompData_SD_PD | SnpRespData_SC_Fwded_SD_PD      | NP       | -        | I, Transfer |
|                     |                 |                 | X <sup>a</sup> | CompData_SC    | SnpRespData_SC_PD_Fwded_SC      | P        | Update   | I, Transfer |
| I                   | -               |                 | 0              | CompData_SD_PD | SnpResp_I_Fwded_SD_PD           | NP       | -        | -           |
|                     |                 |                 | 1              | CompData_SD_PD | SnpRespData_I_Fwded_SD_PD       | NP       | -        | I, Transfer |
|                     |                 |                 | X <sup>a</sup> | CompData_SC    | SnpRespData_I_PD_Fwded_SC       | P        | Update   | I, Transfer |

a. The protocol requirements apply for both states of RetToSrc.  
b. This state transition is not permitted if DoNotGoToSD is asserted.

#### SnpUniqueFwd

Use of the SnpUniqueFwd snoop is only permitted if the cache line is cached at a single RN-F:

- Home is permitted to send the SnpUniqueFwd snoop to an RN-F in Shared state if Home determines that the Invalidating snoop needs to be sent to only one cache.

The rules, in addition to the common rules, to be followed by a Snoopee that receives a SnpUniqueFwd are:

- Snoopee must forward the cache line in Unique state.
- Snoopee that has the cache line in Dirty state must Pass Dirty to the Requester not to Home.
- Snoopee must transition to I state.
- Snoopee must not return data to Home.

RetToSrc bit in the snoop must be set to zero.

Table 4-54 on page 4-236 shows the Snoopee cache state transitions and the required Snoop responses.

See Table 4-50 on page 4-231 for the symbol key.

Table 4-54 SnpUniqueFwd Snoopee state transitions with Clean and Dirty tags

| Snoopee cache (data+tags) state |          |                 | Response to |                | TagOp value in response to Home |                   |                    |
|---------------------------------|----------|-----------------|-------------|----------------|---------------------------------|-------------------|--------------------|
| Initial                         | Final    | Other permitted | RetToSrc    | Requester      | Home                            | Initial tag state |                    |
|                                 | Expected |                 | Dirty       |                |                                 | I, Clean          |                    |
| I                               | I        | -               | 0           | No Fwd         | SnpResp_I                       | -                 | -                  |
| UC                              | I        | -               | 0           | CompData_UC    | SnpResp_I_Fwded_UC              | -                 | -                  |
| UCE                             | I        | -               | 0           | No Fwd         | SnpResp_I                       | -                 | -                  |
| UD                              | I        | -               | 0           | CompData_UD_PD | SnpResp_I_Fwded_UD_PD           | NP <sup>a</sup>   | -                  |
|                                 |          |                 |             | No Fwd         | SnpRespData_I_PD                | P                 | Update I, Transfer |
| UDP                             | I        | -               | 0           | No Fwd         | SnpRespDataPtl_I_PD             | -                 | I                  |
| SC                              | I        | -               | 0           | CompData_UC    | SnpResp_I_Fwded_UC              | -                 | -                  |
| SD                              | I        | -               | 0           | CompData_UD_PD | SnpResp_I_Fwded_UD_PD           | NP <sup>a</sup>   | -                  |
|                                 |          |                 |             | No Fwd         | SnpRespData_I_PD                | P                 | Update I, Transfer |

a. This transition is not permitted because Dirty tags are lost. The Dirty tags are lost because the Snoop response to the Home does not include data with which to pass the Dirty tags to the Home.

#### SnpPreferUnique and SnpPreferUniqueFwd

Use of the SnpPreferUniqueFwd snoop is only permitted if the cache line is cached at a single RN-F.

The rules, in addition to the common rules, to be followed by a Snoopee that receives a SnpPreferUniqueFwd and does not treat it as the Non-forwarding snoop are:

- When the Snoopee is in the process of executing an Exclusive access sequence, using the same address:
  - Snoopee must forward the cache line in SC state.
  - Snoopee must transition to either SD or SC state.
  - Snoopee must not transition to I state, except when in UCE or UDP state.
  - For behavior related to the RetToSrc bit see [Returning Data with Snoop response on page 4-240](#) related to SnpNotSharedDirtyFwd.
  - A Snoopee that is not in the middle of executing an Exclusive access sequence is permitted, but not expected, to treat the snoop as a Non-invalidating snoop.
- When the Snoopee is not in the process of executing an Exclusive access sequence, using the same address, and treats the snoop as an Invalidating snoop:
  - Snoopee must forward the cache line in Unique state.
  - Snoopee that has the cache line in Dirty state must Pass Dirty to the Requester not to Home.
  - Snoopee must transition to I state.
  - Snoopee must not return data to Home.
  - RetToSrc bit value in the snoop is ignored and treated as zero.

For SnpPreferUnique and SnpPreferUniqueFwd, it is IMPLEMENTATION DEFINED when an agent is in the process of executing an exclusive sequence. This specification cannot determine whether a Snoopee will treat SnpPreferUnique as an invalidating snoop or a non-invalidating snoop. To determine this, the Snoop response must be inspected. It is protocol compliant for a Snoopee to always treat the snoop as non-invalidating.

Table 4-55 and Table 4-56 on page 4-239 show the Snoopee cache state transitions and the required Snoop responses.

See Table 4-50 on page 4-231 for the symbol key.

Table 4-55 State transitions for SnpPreferUniqueFwd when Snoopee is executing an exclusive sequence

| Snoopee cache (Data+tag) state |                |                 | Response to |             | TagOp value in response to Home |          |             |
|--------------------------------|----------------|-----------------|-------------|-------------|---------------------------------|----------|-------------|
| Initial                        | RetToSrc       |                 | Requester   | Home        | Initial tag state               |          |             |
|                                | Final Expected | Other Permitted |             |             | Dirty                           | I, Clean |             |
| I                              | I              | -               | X           | No Fwd      | SnpResp_I                       | -        | -           |
| UC                             | SC             | -               | 0           | CompData_SC | SnpResp_SC_Fwded_SC             | -        | -           |
|                                |                |                 | 1           | CompData_SC | SnpRespData_SC_Fwded_SC         | -        | I, Transfer |
| UCE                            | I              | -               | X           | No Fwd      | SnpResp_I                       | -        | -           |
| UD                             | SD*            | -               | 0           | CompData_SC | SnpResp_SD_Fwded_SC             | P        | -           |
|                                |                |                 | 1           | CompData_SC | SnpRespData_SD_Fwded_SC         | P        | I, Transfer |
|                                | SC             | -               | X           | CompData_SC | SnpRespData_SC_PD_Fwded_SC      | P        | Update      |
| UDP                            | I              | -               | X           | No Fwd      | SnpRespDataPri_I_PD             | -        | I           |
| SC                             | SC             | -               | 0           | CompData_SC | SnpResp_SC_Fwded_SC             | -        | -           |
|                                |                |                 | 1           | CompData_SC | SnpRespData_SC_Fwded_SC         | -        | I, Transfer |
| SD                             | SD*            | -               | 0           | CompData_SC | SnpResp_SD_Fwded_SC             | P        | -           |
|                                |                |                 | 1           | CompData_SC | SnpRespData_SC_Fwded_SC         | P        | I, Transfer |
|                                | SC             | -               | X           | CompData_SC | SnpRespData_SC_PD_Fwded_SC      | P        | Update      |

Table 4-56 shows the expected and permitted Snoopee cache state transitions and responses to the SnpPreferUniqueFwd Snoop request when the Snoopee is not executing an Exclusive sequence.

See Table 4-50 on page 4-231 for the symbol key.

Table 4-56 State transitions for SnpPreferUniqueFwd when Snoopee is not executing an exclusive sequence

| Snoopee cache (Data+tag)<br>state | Response to       |                    |          | TagOp value in<br>response to Home |                       |                   |          |
|-----------------------------------|-------------------|--------------------|----------|------------------------------------|-----------------------|-------------------|----------|
|                                   | Final<br>Expected | Other<br>Permitted | RetToSrc | Requester                          | Home                  | Initial tag state |          |
|                                   |                   |                    |          |                                    |                       | Dirty             | I, Clean |
| I                                 | I                 | -                  | X        | No Fwd                             | SnpResp_I             | -                 | -        |
| UC                                | I                 | -                  | X        | CompData_UC                        | SnpResp_I_Fwded_UC    | -                 | -        |
| UCE                               | I                 | -                  | X        | No Fwd                             | SnpResp_I             | -                 | -        |
| UD                                | I                 | -                  | X        | CompData_UD_PD                     | SnpResp_I_Fwded_UD_PD | NP                | -        |
|                                   |                   |                    | X        | No Fwd                             | SnpRespData_I_PD      | P                 | Update   |
| UDP                               | I                 | -                  | X        | No Fwd                             | SnpRespDataPl_I_PD    | -                 | I        |
| SC                                | I                 | -                  | X        | CompData_UC                        | SnpResp_I_Fwded_UC    | -                 | -        |
| SD                                | I                 | -                  | X        | CompData_UD_PD                     | SnpResp_I_Fwded_UD_PD | NP                | -        |
|                                   |                   |                    | X        | No Fwd                             | SnpRespData_I_PD      | P                 | Update   |

## 4.9 Returning Data with Snoop response

The rules for returning a copy of the cache line with the Snoop response are detailed below.

For Non-forwarding snoops, except SnpMakeInvalid, the rules for returning a copy of the cache line to the Home are:

- Irrespective of the value of RetToSrc, must return a copy if the cache line is Dirty.
- Irrespective of the value of RetToSrc, optionally can return a copy if the cache line is Unique Clean.
- If the RetToSrc value is 1, must return a copy if the cache line is Shared Clean and the Snoopee retains a copy of the cache line.
- If the RetToSrc value is 0, must not return a copy if the cache line is Shared Clean.

For Forwarding snoops where data is being forwarded, the rules for returning a copy of the cache line to the Home are:

- Irrespective of the value of RetToSrc, must return a copy if a Dirty cache line cannot be forwarded or kept.
- If the RetToSrc value is 1, must return a copy if the cache line is Dirty or Clean.
- If the RetToSrc value is 0, must not return a copy if the cache line is Clean.

RetToSrc is inapplicable and must be set to zero in:

- SnpQuery and Stash snoops
- SnpCleanShared, SnpCleanInvalid, and SnpMakeInvalid
- SnpOnceFwd and SnpUniqueFwd

RetToSrc is applicable and can take any value in all other snoops except SnpDVMOp.

RetToSrc is inapplicable and must be set to zero in SnpDVMOp.

Home must only set RetToSrc on the Snoop request to a single Request Node.

## 4.10 Do not transition to SD

Do not transition to SD is a modifier on Non-invalidating snoops.

It specifies when a Snoopee must not transition to SD state as a result of the Snoop request.

The field name is DoNotGotoSD.

\_\_\_\_ Note \_\_\_\_\_\_

- A non-forced change or silent change from UD to SD is permitted irrespective of the value of DoNotGoToSD.
- Any forced change from Unique to Shared must obey DoNotGoToSD.

See *Do not transition to SD state, DoNotGoToSD* on page 13-434 for the field applicability and field value encoding.

## 4.11 Hazard conditions

This section lists the responsibilities of the RN-F and HN-F to handle address hazards and race conditions among Snoopable transactions. Ordering among Non-snoopable transactions and among Snoopable transactions is described in *Ordering on page 2-114*.

In addition to many Requesters issuing transactions at the same time, the protocol also permits each Requester to make multiple outstanding requests, and to receive multiple outstanding snoop requests. It is the responsibility of the interconnect, that is, ICN(HN-F, HN-I and MN), to ensure that there is a defined order in which transactions to the same cache line can occur, and that the defined order is the same for all components.

### 4.11.1 At the RN-F node

An RN-F node must respond to received Snoop requests, except for SnpDVMOp(\$ync), in a timely manner without creating any Protocol layer dependency on completion of outstanding requests.

If a pending request to the same cache line is present at the RN-F and the pending request has not received any Data response packets:

- The Snoop request must be processed normally.
- The cache state must transition as applicable for each Snoop request type.
- The cached data or CopyBack request data must be returned with the Snoop response, or forwarded to the Requester, if required by the Snoop request type, Snoop request attributes, and cache state.

If a pending request to the same cache line is present at the RN-F and the pending request has received at least one Data response packet:

- The RN-F must wait to receive all Data response packets before responding to the Snoop request.
- Once all the Data response packets are received by RN-F:
  - The Snoop request must be processed normally.
  - The cache state must transition as applicable for each Snoop request type.
  - The cached data must be returned with the Snoop response, or forwarded to the Requester, if required by the Snoop request type, Snoop request attributes, and cache state.

If the pending request is a CopyBack request then the following additional requirements apply:

- Request transaction flow must be completed after receiving the CompDBIDResp.
- The cache state in the WriteData response must be the state of the cache line after the snoop request is processed, not the state at the time of sending the CopyBack request.
- A Request Node is permitted to not send valid CopyBack Data, if the cache line state after the Snoop response is sent is I or SC. The cache state in the WriteData response, after CopyBack Data is taken away by the snoop, must be I and all byte enables must be deasserted and the corresponding data must be set to zero.
- If data is included with WriteData it must be the same data that as sent with the Snoop response or more up to date data, except when the Snoop request is SnpOnce and the Resp field value in the Snoop response is UC or UD.

###### — Note —

More recent data than that sent with the Snoop response can only be provided if the snoop was a SnpOnce, SnpOnceFwd, or SnpCleanShared and the Snoop response indicates that the cache line can be further modified.

For non-ordered transactions, the Request Node can send CompAck without waiting for DataSepResp. For ordered transactions, the Request Node can send CompAck as soon as the first packet of DataSepResp is received. In both cases, a Request Node must not respond to a Snoop request before receiving all data packets.

The RN-F might receive multiple snoop requests before it receives a response for a pending CopyBack request for the same cache line, in which case the data response carries the cache line state after completion of the response to the last Snoop request. Such a scenario is possible because the CopyBack request can be queued behind multiple Read and Dataless requests at the HN-F.

### 4.11.2 At the ICN(HN-F) node

An HN-F orders transactions to the same cache line by sequencing transaction responses and Snoop transactions to the Requesters. As the interconnect is not required to be ordered, the arrival order of these messages, in certain cases, might not be the same as the order in which they were issued at the HN-F.

If a Response message that includes data requires multiple packets or beats of transfers over the interconnect, then receiving or sending the message by Home implies sending or receiving all the packets corresponding to that message. That is, when a Home starts sending the message, it must send all packets of the message without dependence on completion of any other request or response message.

Similarly, a Home, when it accepts part of the Data message, must accept the remaining packets of that message without any dependence on forward progress of any other request or response message.

When a subsequent forwarding of data depends upon receiving a Data message, the forwarding of data action can occur after receiving the first Data packet. A subsequent Non-data forwarding action that is processing of a subsequent request at Home as a consequence of sending or receiving of data by Home, must wait until all data is sent or received.

While a Snoop transaction response is pending, the only transaction responses that are permitted to be sent to the same address are:

- RetryAck for a CopyBack.
- RetryAck and DBIDResp for a WriteUnique and Atomics.
- RetryAck and, if applicable, a ReadReceipt for a Read request type.
- RetryAck for a Dataless request type.

Once a completion is sent for a transaction, the HN-F must not send a Snoop request to the same cache line until it receives:

- A CompAck for any Read and Dataless requests except for ReadOnce\* and ReadNoSnp.
- A WriteData response for CopyBack and Atomic requests.
- For WriteUnique, a WriteData response, and, if applicable, CompAck.



# Chapter 5Interconnect Protocol Flows

This chapter shows interconnect protocol flows for different transaction types, and interconnect hazard conditions. The protocol flows are illustrated using Time-Space diagrams. It contains the following sections:

- *Read transaction flows* on page 5-246
- *Dataless transaction flows* on page 5-256
- *Write transaction flows* on page 5-260
- *Atomic transaction flows* on page 5-263
- *Stash transaction flows* on page 5-270
- *Hazard handling examples* on page 5-273

See *Time-Space diagrams* on page xiii for details of the conventions used to illustrate protocol flow in this specification.

In the transaction flow diagrams that follow:

- There are multiple coherent Request Nodes, an HN-F, and an SN-F.
- If the HN-F receives multiple data responses, that is, one response from a snooped RN-F and another from an SN-F, then the data being forwarded to the Requester is highlighted in bold.
- There is no interconnect cache at the HN-F. This results in all requests to the HN-F initiating a request to the SN-F.

## 5.1 Read transaction flows

This section gives examples of the interconnect protocol flow for Read transactions.

### 5.1.1 Read transactions with DMT and without snoops

For Read transactions without snoops, this specification recommends the use of *Direct Memory Transfer* (DMT).

Figure 5-1 shows an example DMT transaction flow using the ReadShared transaction.

In Figure 5-1, a response from SN-F to HN-F is not required because CompAck from the Requester is used to deallocate the request at Home.

![Sequence diagram showing a DMT Read transaction example without snoops. The diagram involves three entities: RN-F (Requester), HN-F (Home Node), and SN-F (Snooper Node). The sequence starts with RN-F sending a ReadShared request to HN-F. HN-F then sends a ReadNoSnp request to SN-F. Simultaneously, UC (Unicast Channel) sends CompData_UC to RN-F. Finally, UC sends CompAck to HN-F.](9cd8cbd45367c7606351059944a1df8c_img.jpg)

Sequence diagram showing a DMT Read transaction example without snoops. The diagram involves three entities: RN-F (Requester), HN-F (Home Node), and SN-F (Snooper Node). The sequence starts with RN-F sending a ReadShared request to HN-F. HN-F then sends a ReadNoSnp request to SN-F. Simultaneously, UC (Unicast Channel) sends CompData\_UC to RN-F. Finally, UC sends CompAck to HN-F.

Figure 5-1 DMT Read transaction example without snoops

The steps in the ReadShared transaction flow in Figure 5-1 are:

1. RN-F sends a Read request to HN-F.
2. HN-F sends a Read request to SN-F.
   - The ID field values in the Read request are based on where the data response is to be sent. Data can be sent to the Requester or to the HN-F. See Figure 2-23 on page 2-93 that shows an example of how the ID field values are derived.
3. SN-F sends a data response directly to RN-F.
4. RN-F sends CompAck to HN-F as the request is ReadShared and requires CompAck to complete the transaction.

### 5.1.2 Read transaction with DMT and with snoops

For Read transactions with snoops and data from memory, DMT is recommended.

Figure 5-2 shows an example DMT transaction flow using the ReadShared transaction.

From SN-F to HN-F, a response is not required because CompAck from the Requester is used to deallocate the request at Home.

![Sequence diagram illustrating a DMT Read transaction example with snoops and data from memory. The participants are RN-F0, RN-F1, HN-F, and SN-F. RN-F0 sends a ReadShared request to HN-F. HN-F sends a Snoop request to RN-F1. RN-F1 sends a SnpResp_1 response back to HN-F. HN-F sends a ReadNoSnp request to SN-F. SN-F sends a CompData_UC response to UC. UC sends a CompAck response back to HN-F.](4b841b9a63579b046703607c2071f46e_img.jpg)

Sequence diagram illustrating a DMT Read transaction example with snoops and data from memory. The participants are RN-F0, RN-F1, HN-F, and SN-F. RN-F0 sends a ReadShared request to HN-F. HN-F sends a Snoop request to RN-F1. RN-F1 sends a SnpResp\_1 response back to HN-F. HN-F sends a ReadNoSnp request to SN-F. SN-F sends a CompData\_UC response to UC. UC sends a CompAck response back to HN-F.

Figure 5-2 DMT Read transaction example with snoops and data from memory

The steps in the ReadShared transaction flow in Figure 5-2 are:

1. RN-F0 sends a Read request to HN-F.
2. HN-F sends a Snoop request to RN-F1.
3. HN-F sends a Read request to SN-F after receiving the Snoop response from RN-F1, which guarantees that RN-F1 has not responded with data.
   - The ID field values in the Read request are based on where the data response is to be sent. Data can be sent to the Requester or to the HN-F. See Figure 2-23 on page 2-93 that shows an example of how the ID field values are derived.
4. SN-F sends a data response directly to RN-F0.
5. RN-F0 sends CompAck to HN-F as the request is ReadShared and requires CompAck to complete the transaction.

### 5.1.3 Read transaction with DCT

For Read transactions with snoops and data from other Request Node caches, *Direct Cache Transfer* (DCT) is recommended.

#### DCT from cache line in UC state

Figure 5-3 shows an example flow for a DCT transaction. The Requester is RN-F0 and the forwarding cache is at RN-F1.

![](7794bd28c00de405117ee43927db22bb_img.jpg)

Sequence Diagram (Figure 5-3) illustrating the DCT flow:

- RN-F0 (I state) sends **ReadShared** (TxnID = A) to RN-F1 (UC state).
- RN-F1 (UC state) sends **SnpSharedFwd** (FwdNID = RN-F0) (FwdTxnID = A) (TxnID = B) to HN-F (SC state).
- RN-F1 (UC state) transitions to SC state.
- RN-F1 (SC state) sends **CompData\_SC** (HomeNID = HN-F) (TxnID = A) (DBID = B) to RN-F0 (I state).
- RN-F1 (SC state) sends **SnpResp\_SC\_Fwded\_SC** (TxnID = B) to HN-F (SC state).
- RN-F0 (I state) sends **CompAck** (TgtID = HN-F) (TxnID = B) to HN-F (SC state).
- HN-F (SC state) transitions to I state.

Figure 5-3 Direct Cache Transfer from cache line in UC state

The steps in the DCT transaction flow in Figure 5-3 are:

1. RN-F0 sends a **ReadShared** request to HN-F.
2. HN-F sends a **SnpSharedFwd**, a Forwarding snoop request to RN-F1.
3. RN-F1 cache line state transitions from UC to SC.
4. RN-F1 forwards **CompData\_SC** response to RN-F0.
5. RN-F1 also sends a **SnpResp\_SC\_Fwded\_SC** snoop response to HN-F that indicates:
   - The data was forwarded to the Requester.
   - The final state of the cache line in the snooped cache is SC.
   - The state in which the cache line can be cached at the Requester is SC.
6. After receiving the **CompData** response, RN-F0 sends a **CompAck** response to HN-F to conclude the transaction.

###### Note

Steps 4 and 5 in the DCT transaction flow can occur in any order as CompData and SnpResp are sent on different channels.

#### Double data return in a DCT transaction

Figure 5-4 shows an example DCT transaction flow that sends the data to HN-F and forwards the data to the RN-F0.

![](eae3310620c34c279e6058946c628bb3_img.jpg)

Sequence Diagram (Figure 5-4) illustrating the Double Data Return (DCT) transaction flow between four entities: RN-F0, RN-F1, HN-F, and SN-F.

The flow proceeds as follows:

1. RN-F0 (I) sends a ReadShared request (TxnID = A) to HN-F.
2. HN-F sends a SnpSharedFwd request (FwdNID = RN-F0, FwdTxnID = A, TxnID = B) to RN-F1 (UC).
3. RN-F1 (UC) transitions to UC->SC state.
4. RN-F1 sends CompData\_SC (HomeNID = HN-F, TxnID = A, DBID = B) to RN-F0 (I->SC).
5. RN-F1 also sends SnpResp\_SC\_Fwded\_SC (TxnID = B) to HN-F.
6. RN-F0 (I->SC) sends CompAck (TgtID = HN-F, TxnID = B) to HN-F.

Figure 5-4 Direct Cache Transfer from cache line in UC state

The steps in the DCT transaction flow in Figure 5-4 are:

1. RN-F0 sends a ReadShared request to HN-F.
2. HN-F sends a SnpSharedFwd Snoop request to RN-F1.
3. RN-F1 cache line state transitions from UD to SC.
4. RN-F1 sends CompData\_SC response to RN-F0.
5. RN-F1 also sends a SnpRespData\_SC\_PD\_Fwded\_SC Snoop response to HN-F that includes a copy of the cache line and passes responsibility for the Dirty cache line to HN-F:
   - The data was forwarded to the Requester.
   - The final state of the cache line in the snooped cache is SC.
   - The state in which the cache line can be cached at the Requester is SC.
6. The RN-F0 sends CompAck after it receives the Data response to conclude the transaction.

### 5.1.4 Read transaction without DMT or DCT

Figure 5-5 shows an example of the flow without DMT using the ReadNoSnp transaction. In this example, the ReadNoSnp has the ExpCompAck set in the original request.

The request does not generate any snoop and receives the data from a response to a memory read by the HN-F.

![Sequence diagram showing the ReadNoSnp transaction flow between RN-F0, RN-F1, HN-F, and SN-F. RN-F0 issues a ReadNoSnp request to HN-F. HN-F sends a ReadNoSnp request to SN-F. SN-F returns CompData_I to HN-F. HN-F returns CompData_I to RN-F0. RN-F0 returns CompAck to HN-F. HN-F returns CompAck to RN-F0. The CompData_I transfer is marked in bold.](d749e56ccf5da1a12d1fd717e03c0796_img.jpg)

Sequence diagram showing the ReadNoSnp transaction flow between RN-F0, RN-F1, HN-F, and SN-F. RN-F0 issues a ReadNoSnp request to HN-F. HN-F sends a ReadNoSnp request to SN-F. SN-F returns CompData\_I to HN-F. HN-F returns CompData\_I to RN-F0. RN-F0 returns CompAck to HN-F. HN-F returns CompAck to RN-F0. The CompData\_I transfer is marked in bold.

Figure 5-5 ReadNoSnp transaction flow

The steps in the ReadNoSnp transaction flow in Figure 5-5 are:

1. RN-F0 issues a ReadNoSnp transaction.
2. HN-F receives and allocates the request.

###### **Note**

HN-F does not send snoop as the request is recognized as a Non-snoopable request type.

1. HN-F sends a ReadNoSnp to SN-F.
2. SN-F returns data response to HN-F.
3. HN-F in turn returns the data to RN-F0. If ExpCompAck was not asserted in the ReadNoSnp request, then HN-F deallocates the request.
4. If ExpCompAck was asserted in the ReadNoSnp request, RN-F0 sends a CompAck response to HN-F.
5. RN-F0 deallocates the request.
6. HN-F receives the CompAck response and deallocates the request.

Figure 5-5 shows the transaction flow, the copy of data being transferred is marked in bold.

### 5.1.5 Read transaction with snoop response with partial data and no memory update

An example of this type of flow is a ReadUnique transaction.

RN-F1 has the cache line in UDP state. RN-F1 responds to the snoop with a Snoop response with partial cache line data and passes responsibility for updating memory.

HN-F waits for the data response from memory, merges the partial Snoop response data with the data response from memory, and sends the resultant data to the Requester.

HN-F does not update memory because responsibility for updating memory is passed on to the Requester.

Figure 5-6 shows the transaction flow, the copy of data being transferred is marked in bold.

![](d4113c481c8cd2c067f1b9a4850e1b7e_img.jpg)

Sequence Diagram (Figure 5-6) illustrating the ReadUnique transaction flow with a partial data snoop response and no memory update.

The participants are RN-F0, RN-F1, RN-F2, HN-F, and SN-F.

1. RN-F0 initiates the transaction by sending a ReadUnique request to RN-F1.
2. RN-F1 sends a SnoopUnique request to HN-F.
3. HN-F sends a ReadNoSnp request to SN-F.
4. SN-F responds to HN-F with CompData\_I.
5. HN-F merges the data (labeled Merge data) and sends CompData\_UD\_PD to RN-F0.
6. RN-F1 sends a SnoopRespDataPt\_I\_PD response to RN-F0.
7. RN-F0 sends a CompAck response to RN-F1.

The copy of data being transferred is marked in bold in the CompData\_UD\_PD message.

Figure 5-6 ReadUnique with partial data snoop response

### 5.1.6 Read transaction with snoop response with partial data and memory update.

An example of this type of flow is a ReadClean transaction.

RN-F1 has the cache line in UDP state. RN-F1 responds to the snoop with a Snoop response with partial cache line data and passes responsibility for updating memory.

HN-F waits for the data response from memory, merges the partial Snoop response data with the data response from memory, and sends the resultant data to the Requester.

HN-F updates memory as the responsibility for updating memory is not passed on to the Requester.

Figure 5-7 shows the transaction flow, the copy of data being transferred is marked in bold.

![](7c320c137b880b30ff882c610c458aa1_img.jpg)

Sequence Diagram (Figure 5-7) illustrating the ReadClean transaction flow with partial data snoop response.

Participants (Lanes): RN-F0, RN-F1, RN-F2, HN-F, SN-F.

Initial State: RN-F0 is in I state. RN-F1 is in UDP state. RN-F2 is in I state. HN-F is in I state. SN-F is in I state.

Flow:

1. RN-F0 sends ReadClean to RN-F1.
2. RN-F1 sends SnpClean to HN-F.
3. RN-F1 sends SnpResp\_I to HN-F.
4. RN-F1 sends SnpRespDataPt\_I\_PD to HN-F.
5. RN-F1 sends CompData\_UC to HN-F.
6. RN-F1 sends CompAck to HN-F.
7. HN-F sends ReadNoSnp to SN-F.
8. HN-F sends WriteNoSnp to SN-F.
9. HN-F sends CompDBIDResp to SN-F.
10. HN-F sends NCBWrData to SN-F.
11. HN-F sends Merge data to HN-F.

Legend: I-UC (Initial state), UDP (UDP state), I (I state), UC (UC state).

NCBWrData = NonCopyBackWrData

Figure 5-7 ReadClean with partial data snoop response

### 5.1.7 ReadOnce\* and ReadNoSnp with early Home deallocation

Figure 5-8 shows the optimized flow for an unordered ReadOnce request.

![](3375f61bcb16670e0c6c97ddc6c0b151_img.jpg)

Figure 5-8 is a sequence diagram illustrating the optimized flow for an unordered ReadOnce request across four entities: RN-F0, RN-F1, HN-F, and SN-F.

The flow steps are:

1. RN-F0 sends a ReadOnce request (ExpCompAck = 0, Order[1:0] = 0b00) to HN-F.
2. HN-F sends a ReadNoSnp request (Order[1:0] = 0b01) to SN-F.
3. SN-F sends a ReadReceipt response to HN-F.
4. HN-F deallocates the request.
5. SN-F sends CompData\_UC directly to RN-F0.

Figure 5-8 DMT optimization for unordered ReadOnce

The steps in the optimized ReadOnce transaction flow in Figure 5-8 are:

1. RN-F0 sends an unordered ReadOnce request to HN-F with Order[1:0] set to 0b00.
2. HN-F sends a DMT ReadNoSnp request to SN-F with the Order[1:0] set to 0b01.
3. SN-F sends ReadReceipt to Home.
4. HN-F deallocates the request after receiving the ReadReceipt response.
5. SN-F sends CompData\_UC directly to RN-F0.

###### **Note**

Use of a ReadNoSnp transaction from Home to Subordinate, in the case where CompAck is not required, avoids the need to send a RespSepData response from Home to Requester.

### 5.1.8 ReadNoSnp transaction with DMT and separate Non-data and Data-only response

Figure 5-9 shows an example DMT transaction flow with separate non-data and data-only response.

In this example, there is no ordering requirement and RN-F can send CompAck to HN-F to deallocate the request at Home without waiting for DataSepResp.

![Sequence diagram showing the DMT Read transaction flow with separate Non-data and Data-only response. The participants are RN-F (Requester), HN-F (Home Node), and SN-F (Subordinate Node). The flow is as follows: 1. RN-F sends ReadNoSnp (ExpCompAck = 1) (Order[1:0] = 0b00) to HN-F. 2. HN-F sends ReadNoSnpSep to SN-F. 3. HN-F sends ReadReceipt to RN-F. 4. SN-F sends DataSepResp to RN-F. 5. RN-F sends RespSepData to HN-F. 6. RN-F sends CompAck to HN-F.](a192e195c8e81a06511ed6fbe4496ba7_img.jpg)

Sequence diagram showing the DMT Read transaction flow with separate Non-data and Data-only response. The participants are RN-F (Requester), HN-F (Home Node), and SN-F (Subordinate Node). The flow is as follows: 1. RN-F sends ReadNoSnp (ExpCompAck = 1) (Order[1:0] = 0b00) to HN-F. 2. HN-F sends ReadNoSnpSep to SN-F. 3. HN-F sends ReadReceipt to RN-F. 4. SN-F sends DataSepResp to RN-F. 5. RN-F sends RespSepData to HN-F. 6. RN-F sends CompAck to HN-F.

Figure 5-9 DMT Read transaction example with separate Non-data and Data-only

The steps in the ReadNoSnp transaction in Figure 5-9 are:

1. RN-F sends a ReadNoSnp request to HN-F.
2. HN-F sends a ReadNoSnpSep request to SN-F.
   - This tells SN-F that a data only response is required.
3. HN-F sends a RespSepData response to RN-F.
   - This tells RN-F that the request has been allocated at HN-F and that there will be a separate data response.
4. SN-F sends a ReadReceipt to HN-F.
   - This tells HN-F that the request to the Subordinate is completed and ensures that the SN will not respond with RetryAck for that request. As the request is a ReadNoSnp with Order field set to zero, the request at HN-F can be deallocated on receipt of ReadReceipt.
5. RN-F sends CompAck after receiving RespSepData.
   - For ReadNoSnp, CompAck is not functionally required, HN-F that deallocates the request after receiving the ReadReceipt from SN-F can drop the CompAck.
6. SN-F, as Completer, sends DataSepResp to RN-F returning the read data.

### 5.1.9 ReadNoSnp transaction with DMT with ordering and separate Non-data and Data-only

Figure 5-10 shows an example DMT transaction flow with ordering and separate Non-data and Data-only.

ReadNoSnp with non-zero Order field in Figure 5-10 requires that:

- Next ordered request can be sent only after receiving of RespSepData.
- RN-F must wait for RespSepData and at least one packet of DataSepResp before sending CompAck.
- HN-F must not send next ordered request to SN-F until it receives CompAck.

![](4974405a0cc820542a1459e323131fe7_img.jpg)

Sequence Diagram (Figure 5-10) illustrating a DMT Read transaction example with ordering and separate Non-data and Data-only flows. The diagram shows three participants: RN-F (Requester), HN-F (Handler), and SN-F (Sender).

The flow proceeds as follows:

1. RN-F sends ReadNoSnp (ExpCompAck = 1, Order[1:0] = 0b10) to HN-F.
2. HN-F sends ReadNoSnpSep (Order[1:0] = 0b01) to SN-F.
3. SN-F sends ReadReceipt to HN-F.
4. SN-F sends DataSepResp to RN-F.
5. HN-F sends CompAck to RN-F.

Figure 5-10 DMT Read transaction example with ordering and separate Non-data and Data-only

## 5.2 Dataless transaction flows

This section gives examples of the interconnect protocol flow for Dataless transactions.

### 5.2.1 Dataless transaction without memory update

An example of this type of flow is a MakeUnique transaction.

RN-F1 has the cache line in UC state. RN-F1 responds to the snoop with a Snoop response without data and changes the cache line state to I.

HN-F waits for all Snoop responses and then sends a Comp\_UC response to the Requester.

HN-F does not send a Read request to SN-F because the request is a Dataless transaction.

Figure 5-11 shows the transaction flow.

![](f12298018adfbe3dde093da202961946_img.jpg)

Sequence diagram illustrating the transaction flow for a MakeUnique transaction without memory update.

The participants are RN-F0, RN-F1, RN-F2, HN-F, and SN-F.

1. RN-F0 (I state) sends a MakeUnique request to HN-F.
2. RN-F1 (UC state) sends SnpMakeInvalid to HN-F.
3. RN-F2 (I state) sends SnpMakeInvalid to HN-F.
4. RN-F1 (UC state) sends SnpResp\_I to HN-F.
5. RN-F2 (I state) sends SnpResp\_I to HN-F.
6. HN-F sends Comp\_UC to RN-F0.
7. HN-F sends CompAck to RN-F0.

The diagram shows that the cache line state transitions from I to UC on RN-F0, and from UC to I on RN-F1 and RN-F2.

Figure 5-11 MakeUnique without memory update

### 5.2.2 Dataless transaction with memory update

An example of this type of flow is a CleanUnique transaction.

RN-F1 has the cache line in SD state and responds to the snoop with a Snoop response with data and PD asserted.

HN-F waits for all Snoop responses and then sends a Comp\_UC response to the Requester.

HN-F sends a Write request to update memory with the data received from RN-F1.

Figure 5-12 shows the transaction flow.

![](25e6322e8823f054e2cff4470e808f97_img.jpg)

Sequence Diagram (Figure 5-12) illustrating the CleanUnique transaction flow with memory update.

Participants (Lifelines): RN-F0 (SC), RN-F1 (SD), RN-F2 (I), HN-F, SN-F.

Flow:

1. RN-F0 (SC) sends CleanUnique to RN-F1 (SD).
2. RN-F1 (SD) sends SnpCleanInvalid to HN-F.
3. RN-F2 (I) sends SnpCleanInvalid to HN-F.
4. RN-F1 (SD) sends SnpRespData\_I\_PD to HN-F.
5. RN-F2 (I) sends SnpResp\_I to HN-F.
6. HN-F sends WriteNoSnp to SN-F.
7. HN-F sends CompDBIDResp to SN-F.
8. SN-F sends NCBWrData to HN-F.
9. HN-F sends Comp\_UC to RN-F0 (SC).
10. RN-F0 (SC) sends CompAck to HN-F.

Definition: NCBWrData = NonCopyBackWrData.

Figure 5-12 CleanUnique with memory update

### 5.2.3 Persistent CMO with snoop and separate Comp and Persist

In this example of CleanSharedPersistSep transaction flow, the *Point of Persistence (PoP)* is at the SN-F.

RN-F1 has the cache line in SC state. RN-F1 responds to the snoop with a Snoop response without data.

HN-F waits for all Snoop responses and then sends a Comp\_SC response to the Requester.

HN-F sends a CleanSharedPersistSep request to SN-F, only after completing the writing back of all snooped Dirty data, if any, to the SN-F. SN-F responds to the request with Comp.

SN-F sends a Persist response to RN-F0 to indicate that the request has reached the PoP, and data from any prior writes to the same location is pushed to the PoP.

Figure 5-13 shows the transaction flow.

![](432ee6a5741db7c73d5872406edcc168_img.jpg)

Sequence diagram illustrating the CleanSharedPersistSep transaction flow between four entities: RN-F0, RN-F1, HN-F, and SN-F.

The flow proceeds as follows:

1. RN-F0 (SC state) sends CleanSharedPersistSep to HN-F.
2. HN-F sends SnpCleanShared to RN-F1.
3. RN-F1 sends SnpResp\_SC to HN-F.
4. HN-F sends CleanSharedPersistSep to SN-F.
5. SN-F sends Comp to HN-F.
6. HN-F sends Comp\_SC to RN-F0.
7. SN-F sends Persist to RN-F0.

Figure 5-13 CleanSharedPersistSep transaction flow

### 5.2.4 Evict transaction

Figure 5-14 shows the Evict transaction flow.

RN-F0 moves the cache line to I state and issues an Evict transaction.

HN-F receives and allocates the request.

— Note —

The Evict request is a hint. A Comp response can be given by HN-F without updating the Snoop Filter or Snoop Directory.

HN-F returns the Comp response and deallocates the request.

RN-F0 deallocates the request.

![Sequence diagram illustrating the Evict transaction flow. The diagram shows three participants: RN-F (Requester), HN-F (Host), and SN-F (Snoop Filter). RN-F transitions from UC state to UC->I state, then sends an Evict message to HN-F. HN-F receives the Evict message and performs an Update Snoop Filter or Snoop Directory operation. HN-F then sends a Comp_I response back to RN-F, which transitions back to UC state.](37f5d3fa8039758bf92dd860449041b0_img.jpg)

Sequence diagram illustrating the Evict transaction flow. The diagram shows three participants: RN-F (Requester), HN-F (Host), and SN-F (Snoop Filter). RN-F transitions from UC state to UC->I state, then sends an Evict message to HN-F. HN-F receives the Evict message and performs an Update Snoop Filter or Snoop Directory operation. HN-F then sends a Comp\_I response back to RN-F, which transitions back to UC state.

Figure 5-14 Evict transaction flow

— Note —

The cache state at the Requester must change to Invalid before the Evict message is sent.

## 5.3 Write transaction flows

This section gives examples of the interconnect protocol flow for Write transactions.

### 5.3.1 Write transaction with no snoop and separate responses

Figure 5-15 shows a WriteNoSnp transaction flow.

![](4c086ba480ee1ec965508c765ad78ab8_img.jpg)

Sequence diagram illustrating the WriteNoSnp transaction flow between RN-F0, RN-F1, RN-F2, HN-F, and SN-F.

The flow steps are:

1. RN-F0 issues WriteNoSnp to HN-F.
2. HN-F allocates the request and sends DBIDResp back to RN-F0.
3. HN-F sends WriteNoSnp to SN-F.
4. SN-F sends CompDBIDResp back to HN-F.
5. HN-F sends Comp to RN-F0.

Legend: NCBWrData = NonCopyBackWrData.

Figure 5-15 WriteNoSnp with separate responses from HN to RN

The steps in the WriteNoSnp transaction flow in Figure 5-15 are:

1. RN-F0 issues a WriteNoSnp transaction.
2. HN-F receives and allocates the request.
3. HN-F sends DBIDResp without Comp.
4. RN-F0 responds with data.
5. HN-F sends a Comp after it receives CompDBIDResp from SN-F.

###### **Note**

This flow example shows Comp is sent after CompDBIDResp is received from SN-F. However, HN-F is permitted to send Comp anytime after it receives the WriteNoSnp request from RN-F0.

1. RN-F0 waits for Comp from HN-F and deallocates its request.

Figure 5-15 shows the flow, the copy of data being transferred is marked in bold.

### 5.3.2 Write transaction with snoop and separate responses

An example of this type of flow is a WriteUniquePtl transaction.

The Comp\_I response from HN-F must be sent when the coherency activity is complete at HN-F.

Figure 5-16 shows the transaction flow. The copy of data being transferred is marked in bold.

![](4395f755df1821bc4ea454e1db69133c_img.jpg)

Sequence Diagram (Figure 5-16) illustrating the WriteUniquePtl transaction flow with snoop and separate responses.

Participants (Lanes): RN-F0, RN-F1, RN-F2, HN-F, SN-F.

Flow:

1. RN-F0 sends WriteUniquePtl to HN-F.
2. RN-F1 sends SnpCleanInvalid to HN-F.
3. RN-F2 sends UD to HN-F.
4. HN-F sends DBIDResp to RN-F0.
5. HN-F sends SnpRespData\_I\_PD to RN-F1.
6. HN-F sends SnpResp\_I to RN-F2.
7. HN-F sends NCBWrData to RN-F0.
8. HN-F sends Comp to RN-F0.
9. HN-F sends Merge data to SN-F.
10. HN-F sends WriteNoSnp to SN-F.
11. SN-F sends CompDBIDResp to HN-F.
12. SN-F sends NCBWrData to HN-F.

NCBWrData = NonCopyBackWriteData

Figure 5-16 WriteUniquePtl with snoop

### 5.3.3 CopyBack Write transaction to memory

An example of this type of flow is a WriteBackFull transaction.

The data received from RN-F0 is written to SN-F by HN-F using a WriteNoSnp transaction.

Figure 5-17 shows the transaction flow. The copy of data being transferred is marked in bold.

![](9a7bf8e22cb92698c082e53f2e3b7ac1_img.jpg)

Sequence Diagram (Figure 5-17) illustrating the WriteBackFull returning Data Buffer Identifier flow:

- UD (Requester) sends WriteBackFull to HN-F (Requester).
- HN-F sends CompDBIDResp to UD.
- UD sends CBWrData **UD PD** to HN-F.
- HN-F sends WriteNoSnp to SN-F (Requester).
- SN-F sends CompDBIDResp to HN-F.
- HN-F sends NCBWrData to SN-F.

Legend:

CBWrData = CopyBackWrData  
NCBWrData = NonCopyBackWrData

Figure 5-17 WriteBackFull returning Data Buffer Identifier

## 5.4 Atomic transaction flows

This section shows flows for different Atomic transaction types. It contains the following subsections:

- [Atomic transactions with data return](#)
- [Atomic transaction without data return on page 5-266](#)
- [Atomic operation executed at the SN on page 5-268](#)

### 5.4.1 Atomic transactions with data return

This flow is applicable to:

- AtomicLoad
- AtomicCompare
- AtomicSwap

#### Atomic transaction with snoops and data return

Figure 5-18 shows the atomic operation executed at HN-F.

![](4bfb6bb23e005e280ded1e8e6c85bc46_img.jpg)

Sequence Diagram (Figure 5-18) illustrating Atomic transactions with data return, executed at HN-F.

Participants: RN-F0, RN-F1, RN-F2, HN-F, SN-F.

Initial state: RN-F0 sends an Atomic transaction (AtomicLoad, AtomicSwap, AtomicCompare) to HN-F.

HN-F performs a Speculative Read and sends ReadNoSnp to SN-F.

SN-F sends RespData\_I to HN-F.

HN-F sends SnpRespData\_I\_PD (Old\_Data) to RN-F2.

HN-F sends SnpUnique to RN-F1.

HN-F sends UD->I to RN-F2.

HN-F sends DBIDResp to RN-F0.

HN-F sends NCBWrData (Txn\_Data) to RN-F0.

HN-F executes the Atomic operation.

HN-F sends WriteNoSnp to SN-F.

HN-F sends CompDBIDResp to RN-F0.

HN-F sends NCBWrData (New\_Data) to RN-F0.

Definition: NCBWrData = NonCopyBackWrData.

Figure 5-18 AtomicLoad, AtomicSwap, or AtomicCompare executed at HN-F

The steps in Figure 5-18 are:

1. RN-F0 sends an Atomic transaction to HN-F.

1. After receiving the Atomic request, HN-F:
   - Sends DBIDResp to RN-F0 to obtain the Atomic transaction data.
   - Sends SnpUnique Snoop request to other RN-Fs after determining that snoops are required.
   - HN-F is permitted to send a speculative ReadNoSnp to SN-F.
2. RN-F2 has the cache line in UD state and responds by sending data and invalidating its own cached copy.
   - The response is SnpRespData\_1 PD.
   - This data is marked as (Old\_Data) in Figure 5-18 on page 5-263 to distinguish it from both the data sent by the Requester and the data written to SN-F after the atomic operation is executed.
   - HN-F also receives a second Snoop response, SnpResp\_1, from RN-F1.
3. After receiving all Snoop responses, HN-F sends CompData\_1 to the Requester.
   - The data sent with Comp is the old copy of the data.
   - This data must not be cached in a coherent state at RN-F0.
4. In response to the DBIDResp sent previously, HN-F receives the NonCopyBackWrData\_1 response from the Requester.
   - This data is marked as (Txn\_Data) in Figure 5-18 on page 5-263 to distinguish it from the data sent by RN-F2 in response to the Snoop request from HN-F.
5. Once HN-F receives the NonCopyBackWrData\_1 response from the Requester, and the Snoop response with data from RN-F2, it executes the atomic operation.
6. The resulting value after atomic operation execution, marked as New\_Data in the figure, is written to SN-F.
7. In this example, the read data received due to the speculative read is discarded by HN-F.

###### **Note**

In Figure 5-18 on page 5-263, the CompData\_1 response from HN-F can be sent when all Snoop responses are received.

Alternatively, to aid error reporting, CompData\_1 can be delayed until NCBWrData is received from the Requester and the atomic operation is executed.

#### Atomic transaction without snoops and with data return

Figure 5-19 shows the atomic operation executed at the Home Node.

![](803d28c4ff40048d49d27149450e94eb_img.jpg)

Sequence Diagram (Figure 5-19) illustrating the atomic transaction flow between the Remote Node (RN), Remote Node F1 (RN-F1), Remote Node F2 (RN-F2), Home Node (HN), and System Node (SN).

The diagram shows the following sequence of messages:

1. RN sends AtomicLoad, AtomicSwap, or AtomicCompare to HN.
2. HN sends ReadNoSnp to SN.
3. SN sends RespData\_I (Old\_Data) to HN.
4. HN sends NCBWrData (Txn\_Data) to RN.
5. HN executes the Atomic operation.
6. HN sends WriteNoSnp to SN.
7. SN sends CompDBIDResp to HN.
8. HN sends NCBWrData (New\_Data) to RN.
9. RN sends DBIDResp to HN.
10. RN sends CompData\_I (Old\_Data) to HN.
11. RN sends NCBWrData = NonCopyBackWrData to HN.

Figure 5-19 AtomicLoad, AtomicSwap, or AtomicCompare executed at HN

### 5.4.2 Atomic transaction without data return

This flow is applicable to AtomicStore transactions.

#### Atomic transaction with snoops and without data return

Figure 5-20 shows the atomic operation executed at HN-F. The flow is similar to the Atomic transaction with snoop and with data return, except that the Comp response to RN-F0 does not include data.

![](904d62ce9ad52d0d8ba32329559ab61d_img.jpg)

Sequence Diagram (Figure 5-20) illustrating the AtomicStore operation executed at HN-F, involving RN-F0, RN-F1, RN-F2, HN-F, and SN-F.

Initial state: RN-F0, RN-F1, RN-F2, and HN-F are in a locked state (indicated by a black circle at the bottom of their lifelines).

Flow:

1. RN-F0 sends `AtomicStore` to HN-F.
2. RN-F1 sends `SnpUnique` to HN-F.
3. RN-F2 sends `UD` to HN-F.
4. HN-F sends `SnpUnique` to RN-F1.
5. HN-F sends `SnpRespData_I_PD (Old_Data)` to RN-F2.
6. HN-F sends `UD->` to RN-F2.
7. HN-F sends `NCBWrData (Txn_Data)` to RN-F2.
8. HN-F executes `Atomic operation`.
9. HN-F sends `WriteNoSnp` to SN-F.
10. SN-F sends `CompDBIDResp` to HN-F.
11. HN-F sends `NCBWrData (New_Data)` to RN-F0.
12. RN-F0 sends `Comp` to HN-F.

Annotation below RN-F0 lifeline: `NCBWrData = NonCopyBackWrData`.

Figure 5-20 AtomicStore executed at HN-F

#### Atomic transaction without snoops and without data return

Figure 5-21 shows the atomic operation executed at the Home Node. The flow is similar to the Atomic transaction without snoop and with data return except that the Comp response to the Request Node does not include data.

![](2d875f1cf7b8a0d1a261bda1867435ae_img.jpg)

Sequence Diagram (Figure 5-21) illustrating the AtomicStore operation executed at the Home Node (HN) without snoops and without data return.

Participants: Request Node (RN), Request Node F1 (RN-F1), Request Node F2 (RN-F2), Home Node (HN), Subordinate Node (SN).

Flow:

1. RN sends AtomicStore to HN.
2. HN sends ReadNoSnp to SN.
3. SN sends RespData\_I (Old\_Data) to HN.
4. HN executes Atomic operation.
5. HN sends WriteNoSnp to SN.
6. HN sends CompDBIDResp to RN.
7. HN sends NCBWrData (New\_Data) to RN.

Legend: NCBWrData = NonCopyBackWrData.

Figure 5-21 AtomicStore executed at HN

**Note**

- In Figure 5-21, the read from the Subordinate Node is required to obtain the Old\_Data and is not speculative.
- The Comp response from the Home Node can be combined with the DBIDResp response.

### 5.4.3 Atomic operation executed at the SN

Figure 5-22 shows an example Atomic transaction flow where the SN-F is executing the atomic operation.

![](714b494f885bafb91be24c5c088be613_img.jpg)

Sequence Diagram (Figure 5-22) illustrating the AtomicStore transaction flow:

Participants: RN-F0, RN-F1, RN-F2, UD, HN-F, SN-F.

1. RN-F0 sends an AtomicStore (Normal, Snoopable) request to HN-F.

2. HN-F sends DBIDResp to RN-F0.

3. HN-F sends SnpUnique to RN-F1 and RN-F2.

4. RN-F1 sends UD-> to HN-F.

5. HN-F sends SnpRespData\_1\_PD (Old\_Data) to RN-F1.

6. HN-F sends SnpResp\_1 to RN-F2.

7. RN-F2 sends NCBWrData (Txn\_Data) to HN-F.

8. HN-F sends WriteNoSnp to SN-F.

9. HN-F sends CompDBIDResp to SN-F.

10. HN-F sends NCBWrData (Old\_Data) to SN-F.

11. HN-F sends AtomicStore to SN-F.

12. HN-F sends DBIDResp to SN-F.

13. HN-F sends NCBWrData (Txn\_Data) to SN-F.

14. SN-F sends Comp to HN-F.

Legend: NCBWrData = NonCopyBackWrData

Figure 5-22 AtomicStore executed at SN-F

The steps in Figure 5-22 are:

1. RN-F0 sends an AtomicStore transaction to HN-F.
   - The Atomic request is to a Snoopable address location.
2. After receiving the Atomic request, HN-F:
   - Sends DBIDResp to RN-F0 to obtain the Atomic transaction data.
   - Sends a SnpUnique to other RN-Fs after determining that snoops are required.
3. RN-F2 has the cache line in UD state and responds by sending data and invalidating its own cached copy.
   - The response is SnpRespData\_1\_PD.
   - This data is marked as (Old\_Data) in Figure 5-22 to distinguish it from both the data sent by the Requester and the data written to SN-F after the atomic operation is executed.

- HN-F also receives a second Snoop response,  $\text{SnpResp}_I$ , from the other snooped RN-F.

1. HN-F writes the received data to SN-F using a WriteNoSnp transaction.
2. In response to the DBIDResp sent previously, HN-F receives the NonCopyBackWrData response from the Requester.
3. HN-F after sending the Snoop response data to SN-F, sends an AtomicStore transaction request to SN-F, and executes the sequence of messages required to complete the Atomic transaction.
4. The HN-F deallocates the request once the Comp response is sent to the Requester and the Comp response for the Atomic transaction is received from SN-F.
   - The Comp response from HN-F can be sent when all the Snoop responses are received.

## 5.5 Stash transaction flows

This section shows example interconnect protocol flows for the two Stash transaction types:

- *Write with Stash hint*
- *Independent Stash request* on page 5-272

### 5.5.1 Write with Stash hint

Figure 5-23 shows an example WriteUniqueStash with Data Pull transaction flow.

![](b65639df5934fac8fadf9f13c7d8e38d_img.jpg)

Sequence Diagram (Figure 5-23) illustrating the WriteUniqueStash with Data Pull transaction flow.

Participants (Lifelines): RN, RN-F1, RN-F2, HN-F, SN-F.

Initial state: RN is active (indicated by a filled circle at the bottom of the lifeline).

Flow:

1. RN sends WriteUniqueFullStash (StashNID = RN-F1) to HN-F.
2. HN-F sends DBIDResp to RN.
3. HN-F sends SnpMakeInvalidStash to RN-F1 and SnpUnique to RN-F2.
4. RN-F1 sends SC-> to RN.
5. RN-F2 sends SnpResp\_I to HN-F.
6. RN-F1 sends SnpResp\_I\_Read to HN-F.
7. RN-F2 sends Comp\_I to HN-F.
8. RN-F1 sends CompData\_UD\_PD to RN-F2.
9. RN-F2 sends CompAck to HN-F.
10. HN-F sends Comp\_I to RN-F1.
11. HN-F sends CompData\_UD\_PD to RN-F1.
12. HN-F terminates (indicated by a filled circle at the bottom of the lifeline).

Definition: NCBWrData = NonCopyBackWriteData.

Figure 5-23 WriteUniqueStash with Data Pull

The steps in Figure 5-23 are:

1. The Request Node sends a WriteUniqueFullStash request to HN-F with the Stash target identified as RN-F1. Typically, the requesting Request Node is an RN-I.
2. HN-F sends SnpMakeInvalidStash to RN-F1 and SnpUnique to RN-F2.
3. RN-F1 and RN-F2 send SnpResp response to HN-F. The Snoop response from RN-F1 also includes a Read request, that is, the Data Pull.

1. HN-F treats the Read request from RN-F1 as a ReadUnique, and sends a combined CompData to RN-F1. CompData response includes the data written by the Request Node.
2. RN-F1 sends CompAck to HN-F to complete the Read transaction.

### 5.5.2 Independent Stash request

Figure 5-24 shows an example StashOnce with Data Pull transaction flow.

![](d489a845358c38eeb263a2a2f09cbf87_img.jpg)

Sequence diagram illustrating the StashOnceShared with Data Pull transaction flow. The participants are RN (Request Node), RN-F1 (Request Node F1), HN-F (Host Node F), and SN-F (Storage Node F).

1. RN sends StashOnceShared (StashNID = RN-F1) to HN-F.
2. HN-F sends Comp to RN-F1.
3. HN-F sends ReadNoSnp to SN-F.
4. HN-F sends SnpResp\_I\_Read to RN-F1.
5. HN-F sends CompData\_I to RN-F1.
6. RN-F1 sends CompData\_UC to I->UC.
7. RN-F1 sends CompAck to HN-F.

Figure 5-24 StashOnceShared with Data Pull

The steps in Figure 5-24 are:

1. The Request Node sends a StashOnceShared request to HN-F with the Stash target identified as RN-F1.
2. HN-F sends a Comp response after establishing processing order for the received request that is guaranteeing the request is processed before a request to the same address received later from any Requester.
3. HN-F sends a SnpStashShared snoop to RN-F1, and a ReadNoSnp request to SN-F to fetch data.
4. RN-F1 sends SnpResp\_I\_Read response to HN-F.
5. HN-F treats the Read request from RN-F1 as a ReadNotSharedDirty, and sends a combined CompData to RN-F1.
6. RN-F1 sends CompAck to HN-F to complete the Read transaction.

## 5.6 Hazard handling examples

This section shows how CopyBack-Snoop request hazard conditions are handled at the Requester, and how various requests to request and request to snoop request hazard conditions are handled at the HN-F. It contains the following subsections:

- [CopyBack-Snoop hazard at RN-F](#)
- [Request hazard at HN-F on page 5-276](#)
- [Read - CopyBack or Dataless - CopyBack hazard at HN-F on page 5-278](#)
- [Request-CompAck to HN-F race hazard on page 5-279](#)

### 5.6.1 CopyBack-Snoop hazard at RN-F

Figure 5-25 shows a Snoop request to an RN-F s Hazarding a pending CopyBack request at Time C.

![](090f012618e458eb073599905057ad26_img.jpg)

Figure 5-25 is a sequence diagram illustrating the CopyBack-Snoop hazard at RN-F. The participants are RN-F0, RN-F1, and HN-F.

The sequence starts with a Snoop Shared (SnShared) request from RN-F0 to HN-F. This request is associated with a hazard detected but ignored, as the cache line state transitions from UD to SC.

At Time C, a CopyBack request (Req2: WriteBack) is sent from RN-F0 to HN-F. This request is associated with a hazard detected and blocked, as HN-F is currently processing a ReadShared request (Req1) and cannot proceed with Req2.

At Time D, the CopyBack request completes with a WriteData response (CopyBackWrData\_SC) from HN-F to RN-F0. The cache line state transitions from SC to I.

At Time E, the Snoop Shared request completes (SnRespData\_SC\_PD) from HN-F to RN-F0. The cache line state transitions from I to UD.

At Time F, the ReadShared request (Req1) completes (CompData\_SC) from HN-F to RN-F1. The cache line state transitions from I to SC.

At Time G, the ReadShared request completes (CompAck) from HN-F to RN-F1. The cache line state transitions from SC to I.

At Time H, the CopyBack request (Req2) progresses un-blocked (CompDBIDResp) from HN-F to RN-F0. The cache line state transitions from I to UD.

Legend: PS = PresentState, NS = NextState.

Figure 5-25 CopyBack-Snoop hazard at RN-F example

The steps required to resolve this hazard are:

1. At Time C:
   - The SnShared transaction ignores the hazard and reads the cache line data.
   - The cache line state is changed from UD to SC.

#### 2. At Time D:

- The CompDBIDResp for the CopyBack is sent to RN-F0.
- RN-F0 sends back a CopyBackWrData\_SC response.
- The cache line state is changed from SC to I.

The data is clean for coherence and is not required to be sent to the interconnect for correct functionality. However, the protocol requires the CopyBack flow to be consistent irrespective of a snoop hazard.

The cache line state in the WriteData response is SC because that is the state of the cache line when the WriteData response is sent.

###### — Note —

- The response to a Snoop request that hazards with an outstanding Evict must be SnpResp\_I.
- The only response that can be received for a CopyBack request, while a Snoop response to a Snoop request to the same address is pending, is a RetryAck. This includes data, if applicable.

Figure 5-26 on page 5-275 shows a further example of a Snoop request hazarding with an outstanding CopyBack request. In this example, the Snoop request is a SnpOnce request generated as a result of a ReadOnce request from RN-F1. The SnpOnce request receives a copy of the data with the Snoop response but does not change the cache line state. In this case, the final data response from RN-F0 indicates that the data is Dirty and that HN-F must write the data back to memory.

![](2c34e38fea2319ce5b56ccb7cd92347e_img.jpg)

UD

RN-F0

RN-F1

UD->UD

UD->I

I

ReadOnce

WriteBack

SnpOnce

SnpRespData\_UD

CompData\_I

CompAck

CompDBIDResp

CBWrData\_UD  
(PS=UD, NS[implied]=I)

CopyBack  
Completed with a  
WriteData response

Hazard detected  
but ignored

Hazard detected  
WriteBack progress  
blocked

ReadOnce  
does not  
write back  
Data

WriteBack progress  
un-blocked

WrNoSnp

PS = PresentState  
NS = NextState

HN-F

SN-F

Figure 5-26 CopyBack-Snoop hazard with no cache state change example

### 5.6.2 Request hazard at HN-F

If more than one request to the same cache line is ready to be processed at the HN-F, then the HN-F can select the next request in any order. This exception for this is when the two requests have an ordering requirement and are from the same source, then the order of processing must match the order of arrival.

Figure 5-27 shows an example where a ReadShared and a ReadUnique, for the same cache line, arrive at the HN-F at approximately the same time.

![](3543fd17386ce28b752f8859d8ffa85d_img.jpg)

Figure 5-27 is a sequence diagram illustrating a Read-Read request hazard example. The diagram shows interactions between five components: RN-F0, RN-F1, RN-F2, HN-F, and SN-F, over time (vertical lines).

**Initial State:** RN-F0 is in SC (Shared Cache) state. RN-F1 and RN-F2 are in I (Invalid) state.

**Time A (Hazard Detection):**

- RN-F0 sends Req2: ReadUnique to HN-F.
- RN-F2 sends Req1: ReadShared to HN-F.
- HN-F sends ReadNoSnp to SN-F.
- HN-F detects a hazard (indicated by a red diamond) and blocks Req2 progress.

**Time B (Resolution):**

- HN-F sends CompData\_I to SN-F.
- HN-F sends CompData\_SC to RN-F1.
- HN-F sends CompAck to RN-F1.
- HN-F sends Req2 progress un-blocked (indicated by a green diamond).
- HN-F sends ReadNoSnp to SN-F.
- HN-F sends CompData\_I to SN-F.
- HN-F sends CompData\_UC to RN-F0.
- HN-F sends CompAck to RN-F0.

**Final State:** RN-F0 transitions from SC to UC (Unique Cache). RN-F1 transitions from I to SC (Shared Cache). RN-F2 remains in I state.

Figure 5-27 Read-Read request hazard example

The steps required to resolve this hazard in Figure 5-27 are:

1. At Time A:
   - ReadUnique from RN-F0 arrives and hazards a ReadShared request from RN-F2 for which the HN-F has already sent Snoop requests.
   - ReadUnique progress is blocked at the HN-F.
2. At Time B:
   - The HN-F has completed the ReadShared transaction request from RN-F2.

- The ReadShared transaction is considered to be complete and the HN-F unblocks the ReadUnique transaction request from RN-F0.

Except for ReadNoSnp, the flows are similar if the two transactions, that Figure 5-27 on page 5-276 shows, are replaced by any Read request type, or Dataless request type:

- A Read transaction request without DMT or DCT or separate Comp and data response is completed at the HN-F when both of the following are true:
  - All CompData is sent and, if applicable, CompAck is received. A CompAck is only required for transactions that assert ExpCompAck in the original request message.
  - A memory update is completed if required.

### 5.6.3 Read - CopyBack or Dataless - CopyBack hazard at HN-F

A hazard between a Read or Dataless request and a CopyBack request at the HN-F is treated similarly to the Read-Read hazard described in *Request hazard at HN-F* on page 5-276. See also *CopyBack-Snoop hazard at RN-F* on page 5-273.

Figure 5-28 shows the case where a ReadShared and a WriteBack, for the same cache line, arrive at the HN-F at approximately the same time.

![](b901a12fcec4a8b989748ba61e192196_img.jpg)

Figure 5-28 is a sequence diagram illustrating the Read - CopyBack or Dataless - CopyBack hazard at HN-F. The timeline shows interactions between RN-F0, RN-F1, RN-F2, HN-F, and SN-F.

**Initial State:** RN-F0 (UD), RN-F1 (I), RN-F2 (I), HN-F (A), SN-F (A).

**Step 1 (Time A):** RN-F2 sends Req2: WriteBack to HN-F. HN-F sends Req1: ReadShared to RN-F0. HN-F sends SnpShared to RN-F0. HN-F detects a hazard (Req2 progress blocked) and blocks the WriteBack request.

**Step 2 (Time B):** RN-F0 sends SnpRespData\_SC\_PD to HN-F. HN-F sends CompData\_SC to RN-F1. HN-F sends WriteNoSnp to SN-F. HN-F sends CompDBIDResp to RN-F1. RN-F1 sends CompAck to HN-F. HN-F sends NCBWrData to SN-F.

**Step 3 (Time C):** RN-F1 sends CompDBIDResp to HN-F. HN-F sends CopyBackWrData\_SC (PS = SC, NS(implied) = I) to RN-F0. HN-F unblocks the WriteBack request (Req2 progress un-blocked).

**Legend:** PS = PresentState, NS = NextState.

Figure 5-28 Read - CopyBack or Dataless - CopyBack hazard example

The steps required to resolve this hazard in Figure 5-28 are:

1. At Time A:
   - A WriteBack encounters a hazardous condition at the HN-F. The reason for the hazard is a ReadShared transaction that is already in progress.
   - The hazard detection results in the WriteBack being blocked.
   - The ReadShared transaction receives data with the snoop response and must update memory in addition to sending the data to the Requester.
2. At Time B:
   - The WriteBack is unblocked because the HN-F has sent the data response to the Requester and a WriteData response to memory for the ReadShared transaction.

If the ReadShared request reaches the HN-F, after the HN-F has started processing the WriteBack request, then the ReadShared request will be blocked until completion of the WriteBack request.

A CopyBack request is completed at HN-F when both of the following are true:

- A data message corresponding to the CopyBack request is received.
- A memory update is completed if necessary.

### 5.6.4 Request-CompAck to HN-F race hazard

After completion, a request might silently evict the cache line from the cache and generate another request to the same address. For example:

1. The regenerated request reaches the HN-F before the CompAck response associated with the earlier request.
2. The HN-F detects an address hazard and blocks the processing of the new request until the CompAck response is received.

In such a scenario, on arrival at HN-F, the CompAck response deallocates the previous request from the HN-F and unblocks the processing of the new request.



# Chapter 6Exclusive accesses

This chapter describes the mechanisms that the architecture includes to support Exclusive accesses. It contains the following sections:

- [Overview on page 6-282](#)
- [Exclusive monitors on page 6-283](#)
- [Exclusive transactions on page 6-286](#)

## 6.1 Overview

The principles of Exclusive accesses are that a *Logical Processor (LP)* performing an exclusive sequence does the following:

- Performs an Exclusive Load from a location.
- Calculates a value to store to that location.
- Performs an Exclusive Store to the location.

Two different forms of Exclusive access are supported:

- Exclusive accesses to a Snoopable memory location.
- Exclusive accesses to a Non-snoopable memory location.

If the location is updated since the Exclusive Load, by a different LP, then the Exclusive Store must fail. In this case, the store does not occur and the LP does not update the value held at the location.

###### **Note**

- The term Exclusive Load is used to describe the action of an LP executing an appropriate program instruction such as LDREX. This action requires:
  - Obtaining the data from the location to which it wants to perform an exclusive sequence.
  - Indicating that it is starting an exclusive sequence.
- The term Exclusive Load transaction is used to describe a transaction issued on the interface to obtain data for an Exclusive Load, if the data is not available in the cache at the LP. Not every Exclusive Load requires an Exclusive Load transaction.
- The term Exclusive Store is used to describe the action of an LP executing an appropriate program instruction, such as STREX. This action requires:
  - Determining if the exclusive sequence has passed or failed.
  - If appropriate, updating the data at the location.An Exclusive Store can pass or fail and this result is known to the executing processor. When an Exclusive Store passes, the data value at the address location is updated. When an Exclusive Store fails, this indicates that the data value at the address location has not been updated, and the exclusive sequence must be restarted.
- The term Exclusive Store transaction is used to describe a transaction issued on the interface that might be required to complete an Exclusive Store. Not every Exclusive Store requires an Exclusive Store transaction. An Exclusive Store transaction can pass or fail and this result is made known to the LP using the transaction response.

## 6.2 Exclusive monitors

The progress of an exclusive sequence is tracked by an exclusive monitor. The location of the monitor and the request type generated to support the Exclusive accesses depends on the memory attributes of the address.

The attributes of Exclusive accesses must be such that they are guaranteed to be observed by an exclusive monitor. For example, if there is a cache between the Requester and monitor, then the Exclusive accesses should be Non-cacheable.

### 6.2.1 Snoopable memory location

For a Snoopable memory location two monitors are defined:

**LP monitor** Each LP within an RN-F must implement an exclusive monitor that observes the location used by an exclusive sequence. The LP monitor is set when the LP executes an Exclusive Load. The LP monitor is reset when either:

- The location is updated by another LP, which is indicated by an Invalidating snoop request to the same address.
- There is a store to the location by the same LP. Resetting the monitor, if the store from the same LP is Non-exclusive, is IMPLEMENTATION DEFINED.

**PoC monitor** An HN-F must implement a PoC monitor that can pass or fail an Exclusive Store transaction. A pass indicates that the transaction has been propagated to other coherent RN-Fs. A fail indicates that the transaction has not been propagated to other coherent RN-Fs and therefore the Exclusive Store cannot pass.

The monitor is used to ensure that an Exclusive Store transaction from an LP is only successful if that LP could not have received a snoop transaction, relating to an Exclusive Store to the same address from another LP, after it issued its own Exclusive Store transaction.

The minimum requirement of the PoC monitor is to record when any LP performs a Snoopable transaction related to an exclusive sequence.

If an LP has performed a transaction related to an exclusive sequence, and it then performs an Exclusive Store transaction before a successful Exclusive Store transaction from another LP is scheduled, then the Exclusive Store transaction must be successful.

The monitor must support the parallel monitoring of all exclusive-capable Logical Processors in the system.

When the HN-F receives a transaction associated with an Exclusive Load or an Exclusive Store, the monitor registers that the LP is attempting an exclusive sequence.

When the HN-F receives an Exclusive Store transaction:

- If the PoC monitor has registered that the LP is performing an exclusive sequence, that is, it has not been reset by an Exclusive Store transaction from another LP, then the Exclusive Store transaction is successful and is permitted to proceed. In such a case, registered attempts of all other LPs must be reset. It is recommended, but not required, that the PoC monitor for the successful LP is left as registered.
- If the PoC monitor has not registered that the LP is performing an exclusive sequence, that is, it has been reset by an Exclusive Store from another LP, then the Exclusive Store transaction is failed and is not permitted to proceed. The monitor must register that the LP is attempting an Exclusive sequence.

###### — Note —

A successful Store transaction from an LP does not have to reset that the LP is performing an exclusive sequence. The LP can continue to perform a sequence of Exclusive Store transactions, which will all be successful, until another LP performs a successful Exclusive Store transaction. For store transactions in which the LP is not identifiable, the store must be handled as from a different LP than the one which set the monitor.

From initial system reset, the first LP to perform an Exclusive Store transaction can be successful, but this specification does not require it. At that point, all other LPs must then register the start of their exclusive sequence for their Exclusive Store transaction to be successful.

When an Exclusive Store transaction from one LP passes and the registered attempts of all other LPs is reset, the other LPs can only register a new exclusive sequence after the CompAck response is observed for the Exclusive Store transaction that passed.

###### — Note —

An LP and PoC monitor pair are required to support an Exclusive access to a Snoopable memory location.

### 6.2.2 Additional address comparison

The PoC monitor can be enhanced to include some address comparison. A full address comparison is not required and it is permitted to only record a subset of address bits. This approach reduces the chances of an Exclusive Store transaction failing because of an Exclusive Store transaction from another Logical Processor to a different address location. The number of bits of address comparison used is IMPLEMENTATION DEFINED.

Where an additional address comparison monitor is used, the monitored address bits are recorded at the start of an exclusive sequence on either a Load Exclusive or Store Exclusive transaction. It is reset by a successful Exclusive Store transaction from another LP to a matching address.

A monitor that includes an additional address comparison must still include a minimum monitor of a single bit for every Exclusive-capable LP to ensure forward progress.

An Exclusive Store transaction is permitted to progress if one of the following occurs:

- The address monitor has registered an exclusive sequence for a matching address from the same LP and has not been reset by an Exclusive Store transaction from a different LP with a *matching address*.
- The minimum single-bit monitor has been set by an exclusive sequence from the same LP, and it has not been reset by an Exclusive Store transaction from a different LP to any address.

###### — Note —

- The term *matching address* is used to describe where a monitor only records a subset of address bits. The address bits that are recorded are identical, but the address bits that are not recorded can be different.
- An implementation does not require an address monitor for each Exclusive-capable LP. Because the address monitor provides a performance enhancement, it is acceptable to have fewer address monitors and for the use of these to be IMPLEMENTATION DEFINED. For example, address monitors can be used on a first-come first-served basis, or by allocation to particular Logical Processors. Alternatively, a more complex algorithm might be implemented.
- Additional PoC exclusive monitor functionality can be provided to prevent interference, or denial of service, caused by one agent in the system issuing many Exclusive access transactions. It is recommended that Secure Exclusive accesses are permitted to make forward progress independently of the progress of Non-secure accesses.

### 6.2.3 Alternatives to a PoC monitor

An HN-F is permitted to use the following mechanisms instead of a PoC monitor to determine the results of an Exclusive access:

- A precise Snoop Filter, to track if the Requester at the time of Exclusive Store processing retains a copy of the cache line.
- Snooping by the Home Node, to determine if the Requester still holds a copy of the cache line.

###### — Note —

Prior to CHI Issue E, a Home Node that supports Exclusive accesses was required to implement a PoC monitor.

### 6.2.4 Non-snoopable memory location

For a Non-snoopable memory location, a single monitor is used:

**System monitor** The System monitor tracks Exclusive accesses to a Non-snoopable region. This monitor type is set by a ReadNoSnp(Excl) transaction and reset by an update to the location by another LP.

System monitors can be placed at a PoS or at endpoint devices. Potentially, the number of devices in the system is much larger than the number of PoS and placing System monitors at a PoS can:

- Reduce System monitor duplication.
- Reduce the time taken for the system to detect failure of an Exclusive access.

A System monitor must be located so it can observe all transactions to the monitored location.

## 6.3 Exclusive transactions

The following transaction types support Exclusive accesses through an Excl bit:

- Exclusive Load transaction to a Snoopable location:
  - ReadClean
  - ReadNotSharedDirty
  - ReadShared
  - ReadPreferUnique
- Exclusive Store transaction to a Snoopable location:
  - CleanUnique
  - MakeReadUnique
- Exclusive Load transaction to a Non-snoopable location:
  - ReadNoSnp
- Exclusive Store transaction to a Non-snoopable location:
  - WriteNoSnp

The communicating node pairs are:

- For Exclusives to a Snoopable location:
  - RN-F to ICN(HN-F).
- For Exclusives to a Non-snoopable location:
  - RN-F, RN-D, RN-I to ICN(HN-F, HN-I).
  - ICN(HN-F) to SN-F.
  - ICN(HN-I) to SN-I.

An exclusive transaction must use the correct LPID value, See [Logical Processor Identifier on page 2-113](#).

### 6.3.1 Responses to exclusive requests

Transaction responses to exclusive requests are similar to the normal responses to reads and writes with the following exceptions:

- ReadClean, ReadNotSharedDirty, and ReadShared Exclusive transactions:
  - Must not use separate Comp and data response.
  - Requests that do not fail must not use either DMT or DCT.
- ReadNoSnp Exclusive transactions that do not fail, must not use DMT.
- WriteNoSnpFull and WriteNoSnpPtl transactions, must not use DWT if the Exclusive monitor is located at the Home and the Exclusive check passes.

However, the response for the following Exclusive transactions must also indicate if the exclusive request has passed or failed:

- ReadClean
- ReadNotSharedDirty
- ReadShared
- ReadNoSnp
- CleanUnique
- WriteNoSnpFull
- WriteNoSnpPtl

The RespErr field in the response is used for this purpose. See [Response Error, RespErr on page 13-439](#). The RespErr field value of 0b01, Exclusive Okay, indicates a pass and a RespErr field value of 0b00, Normal Okay, indicates an Exclusive access failure.

The Exclusive Okay response must only be given for a transaction that has the Excl attribute set.

Not all memory locations are required to support Exclusive accesses. An Exclusive Load transaction to a location that does not support Exclusive accesses must not be given an Exclusive Okay response.

Whether or not an Exclusive Store transaction to a location that does not support Exclusive accesses will update that location is IMPLEMENTATION DEFINED.

It is recommended that an Exclusive Store transaction is not performed to a location that does not support Exclusive accesses.

ReadPreferUnique and MakeReadUnique do not use RespErr to determine the pass or fail of an Exclusive operation. An Exclusive MakeReadUnique response with Shared cache state indicates the failure of an Exclusive access. When the response cache state is Unique, the Requester must use its Local Monitor state to determine if the Exclusive access is a pass.

Table 6-1 shows the Snoopable attributes of the request, the relevant monitor type and possible reasons for fail conditions and response requirements.

Table 6-1 Responses to an Exclusive access request

| Request type                                                    | Snoopable | Monitor type     | Fail condition                              | Response                                                                         |
|-----------------------------------------------------------------|-----------|------------------|---------------------------------------------|----------------------------------------------------------------------------------|
| ReadNoSnp(Excl)                                                 | No        | System           | Target does not support Exclusive accesses  | Target must return a data response                                               |
| WriteNoSnp(Excl)                                                | No        | System           | Address content modified                    | The Requester must still complete the write flow by sending the Data message     |
|                                                                 |           |                  | Address not present due to monitor overflow |                                                                                  |
|                                                                 |           |                  | Target does not support Exclusive accesses  |                                                                                  |
| ReadClean(Excl)<br>ReadNotSharedDirty(Excl)<br>ReadShared(Excl) | Yes       | LP, PoC          | Target does not support Exclusive accesses  | Target must return a data response                                               |
| ReadPreferUnique                                                | Yes       | LP, Optional PoC | None                                        | If a PoC monitor is available, the appropriate monitor bit must be set           |
| CleanUnique(Excl)                                               | Yes       | LP, PoC          | Address content modified                    | Target must return a Comp response                                               |
|                                                                 |           |                  | Address not present due to monitor overflow |                                                                                  |
|                                                                 |           |                  | Target does not support Exclusive accesses  |                                                                                  |
| MakeReadUnique(Excl)                                            | Yes       | LP, Optional PoC | Address content modified                    | Target uses PoC monitor, Precise snoop filter, or SnpQuery to determine response |

#### MakeReadUnique(Excl)

When performing an Exclusive Store operation, MakeReadUnique(Excl) is the preferred alternative over the CleanUnique(Excl) request.

The permitted responses to the MakeReadUnique(Excl) request are included in Table 4-36 on page 4-216 and Table 4-37 on page 4-217.

#### Result of an Exclusive access

The result of an Exclusive access is determined in the following manner:

- RespErr value of Exclusive Okay is not permitted in response to a MakeReadUnique(Excl).
- The Requester must use its local exclusive monitor along with the cache state in the response to determine the success of an Exclusive Store.
  - When the cache state in the response is Shared, the Requester must assume that the Exclusive access has failed.
  - When the cache state in the response is Unique, the Requester must use its own local monitor to determine the result of the Exclusive access.

#### Home behavior

If the Home, after checking the PoC monitor, determines the Exclusive Store passes, it must invalidate all other cached copies of the cache line and then send a Comp response with the cache state of Unique to the Requester. The cache state can include [ \_PD] if a cached copy in SD state was invalidated and the responsibility of writing back of the Dirty data is being passed to the Requester.

To avoid an Exclusive access livelock, the monitor must be capable of simultaneously tracking each individual LP Exclusive thread in the system.

A Home is permitted to use a precise Snoop Filter to determine the success or failure of an Exclusive access. If the Snoop Filter indicates that the Requester has lost the cache line, then it must be assumed that the Exclusive access has failed.

In the absence of precise caching information from the Snoop Filter, the Home can use the SnpQuery snoop to determine the presence and state of the cache line at the Requester.

When a Home determines that an Exclusive Store transaction has failed, the following rules must be followed:

- If the Requester has lost the cache line, then the Home is expected to send SnpPreferUniqueFwd or SnpPreferUnique to get a copy of the cache line. The Home is permitted to send SnpNotSharedDirty(Fwd), or SnpClean(Fwd), or SnpShared instead. The snoop must not be SnpSharedFwd nor any Invalidating snoop.
- The sender of the data is permitted to return, as appropriate, a UC or UD state in the response to the Requester if no other cached copies exist.  
  The responder must return data with SC state, if other copies exist.

SD state is not permitted in the response to the Requester. This is because the Home cannot determine from the MakeReadUnique(Exc!) request whether the Requester will accept data in SD state.

Data is provided in response to a MakeReadUnique(Exc!) transaction when a cache line is lost to a snoop between the issuing of the MakeReadUnique(Exc!) transaction and the point at which the Home actions the transaction or the Home cannot determine that the data has been retained.

### 6.3.2 System responsibilities

A system that implements the CHI protocol has the following responsibilities:

- Should include a monitor per LP for the efficient handling of Exclusive accesses.
- Must have a starvation prevention mechanism for all exclusive requests, whether using the monitor mechanism or some other means.
- It is recommended that progress on Secure exclusive requests is independent of progress on Non-secure Exclusive requests.

### 6.3.3 Exclusive accesses to Snoopable locations

This section describes the behavior of an LP when performing Exclusive accesses to a Snoopable address location.

#### Snoopable Exclusive Load

The LP starts an exclusive sequence with an Exclusive Load. The start of the exclusive sequence must set the LP exclusive monitor.

An LP wanting to perform an Exclusive access to a Snoopable location might already hold the cache line in its local cache:

- If the LP holds the cache line in a Unique state, it is permitted, but not recommended, that it performs an Exclusive Load transaction.
- If the LP holds the cache line in a Shared state, it is permitted, but not required, that it performs an Exclusive Load transaction.
- If the LP does not hold a copy of the cache line, it is recommended that the LP uses an Exclusive Load transaction to obtain the cache line. It is permitted to use ReadClean, ReadShared, ReadNotSharedDirty, or ReadPreferUnique without the Excl attribute asserted.

#### Snoopable Exclusive Load to Snoopable Exclusive Store

After the execution of an Exclusive Load, an LP will typically calculate a new value to store to the location before it attempts the Exclusive Store.

It is not required that an LP always completes an Exclusive sequence. For example, the value obtained by the Exclusive Load can indicate that a semaphore is held by another LP and that the value cannot be changed until the semaphore is released by the other LP. Therefore, a new Exclusive sequence can be started with no attempt to complete the current Exclusive sequence.

During the time between the Exclusive Load and the Exclusive Store, the LP exclusive monitor must monitor the location to determine whether another LP might have updated the location.

#### Snoopable Exclusive Store

An LP must not permit an Exclusive Store transaction to be in progress at the same time as any transaction that registers that it is performing an exclusive sequence. The LP must wait for all messages for any such transaction to be exchanged, or to receive a RetryAck response, before issuing an Exclusive Store transaction. The transactions that register that an LP is performing an exclusive sequence are:

- Exclusive Load transactions to any location.
- Exclusive Store transactions to any location.

When an LP executes an Exclusive Store the following behavior is required:

- If the LP exclusive monitor has been reset the Exclusive Store must fail and the LP must not issue an Exclusive Store transaction. The LP must restart the exclusive sequence.

###### — Note —

When the LP monitor has been reset, not issuing a transaction for an Exclusive Store that must eventually fail avoids unnecessary invalidation of other copies of the cache line.

- If the cache line is held in a Unique state and the LP exclusive monitor is set, then the Exclusive Store has passed and it can update the location without issuing a transaction.

- If the cache line is held in a Shared state and the LP exclusive monitor is set, the LP must issue an Exclusive Store transaction. A CleanUnique or MakeReadUnique transaction with the `Excl` attribute asserted must be used. The LP exclusive monitor must continue to operate and check that the cache line is not updated while the CleanUnique or MakeReadUnique transaction is in progress.

An Exclusive CleanUnique transaction response is handled in the following way.

The transaction will receive a Normal Okay or an Exclusive Okay response.

If the transaction receives an Exclusive Okay response, then this indicates that the transaction has passed and has completed invalidating all other copies of the cache line. After an exclusive transaction completes with an Exclusive Okay response, the LP must again check the LP exclusive monitor:

- If the LP exclusive monitor is set, the Exclusive Store has passed and the update is performed.
- If the LP exclusive monitor is not set, it indicates that an update to the cache line has occurred between the point that the Exclusive Store transaction was issued and the point that it completed. The Exclusive Store must fail and the exclusive sequence must be restarted.
- If the LP has not been able to track the exclusive nature of the cache line, because the cache line has been evicted, then the Exclusive Store must fail and the exclusive sequence must be restarted.

If the Exclusive Store transaction receives a Normal Okay response, this indicates another LP has been permitted to progress a transaction associated with an Exclusive Store. The transaction associated with the Exclusive Store, from this LP, has failed and has not propagated to other Logical Processors in the system. When an Exclusive Store transaction completes with a Normal Okay response, the options are:

- The LP can fail the Exclusive Store and restart the exclusive sequence with or without checking the state of the cache line when the access completed.
- The LP can check the LP exclusive monitor, and if the LP exclusive monitor has been reset, then the LP must fail the Exclusive Store and restart the exclusive sequence.
- The LP can check the LP exclusive monitor, and if the LP exclusive monitor is set, then the LP can repeat the Exclusive Store transaction.

For handling of an Exclusive MakeReadUnique at the Home Node see *Home behavior* on page 6-289.

#### Exclusive accesses to Non-snoopable locations

The following restrictions apply to Exclusive accesses to Non-snoopable locations:

- The address of an Exclusive access must be aligned to the total number of bytes in the transaction.
- The number of bytes to be transferred in an Exclusive access must be a legal data transfer size, that is, 1 byte, 2 bytes, 4 bytes, 8 bytes, 16 bytes, 32 bytes, or 64 bytes.

Failure to observe these restrictions results in behavior that is **UNPREDICTABLE**.

For Exclusive read and Exclusive write transactions to be considered a pair, the following criteria must apply:

- The addresses of the Exclusive read and the Exclusive write must be identical.
- The value of the control signals, that is `MemAttr` and `SnpAttr` of the Exclusive read and the Exclusive write transaction, must be identical.
- The data size in the Exclusive read and the Exclusive write must be identical.
- The `LPI` value of the Exclusive read must match the `LPI` value of the Exclusive write transaction.

The minimum number of bytes to be monitored during an exclusive operation is defined by the transaction size. The System monitor can monitor a larger number of bytes, up to 64, which is the maximum size of an Exclusive access. However, this can result in a successful Exclusive access being indicated as failing because a neighboring byte was updated while the Exclusive access was in progress.

Multiple Exclusive transactions to Non-snoopable memory locations, either read or write, to the same or different addresses, from the same LP must not be outstanding at the same time.

If the Subordinate Node does not support Exclusive accesses, as indicated by an Exclusive Fail on the Exclusive ReadNoSnp, then the write will update the location if the write is given an Exclusive Fail response.

If the Subordinate Node does support Exclusive accesses, as indicated by an Exclusive Pass on the Exclusive ReadNoSnp, then the write will not update the location if the write is given an Exclusive Fail response.

# Chapter 7Cache Stashing

This chapter describes the cache stashing mechanism whereby data that is written from a Request Node can be installed in a peer cache. It contains the following sections:

- [Overview on page 7-294](#)
- [Write with Stash hint on page 7-296](#)
- [Independent Stash request on page 7-297](#)
- [Stash target identifiers on page 7-299](#)
- [Stash messages on page 7-300](#)

## 7.1 Overview

Cache stashing is a mechanism to install data within particular caches in a system. Cache stashing ensures that data is located close to its point of use, improving the system performance.

Cache stashing is permitted to Snoopable memory only.

This specification supports two main forms of cache stashing transaction:

### WriteUniqueStash

Write with stash hint. This is used when the cache in which the data should be allocated is known at the point in time that the data is written. A write with stash hint can be a [Full] or [Ptl] cache line write, and this will affect the Snoop transactions that are used. See [Write with Stash hint on page 7-296](#).

### StashOnce

Independent stash request. This is used when the request to stash data into a particular cache is separated from the writing of the data. An independent Stash transaction can indicate if the cache line should be held in a Unique or Shared state by using a StashOnceUnique or StashOnceSepUnique, or a StashOnceShared or StashOnceSepShared transaction respectively, which corresponds to whether the next expected use of the cache line is for storing or for reading. See [Independent Stash request on page 7-297](#).

Both forms of cache stashing can target installation of data at different cache levels. The Stash target cache can be a peer cache, specified by using the peer cache target NodeID, or a logical processor cache within the peer node, if the peer node has multiple logical processors. The logical processor is identified by the LPID in the target cache field. See [Stash target identifiers on page 7-299](#).

The Cache stashing requests can also target the cache below the peer cache in the cache hierarchy, which can be an interconnect cache or a system cache. This is done by not specifying the peer cache NodeID. See [Stash target not specified on page 7-299](#).

In all cases of cache stashing, the Stashing is only a performance hint and it is permitted for the Stash request receiver to not perform the stashing behavior.

### 7.1.1 Snoop requests and Data Pull

The following Snoop requests are used to notify a peer cache that it is the target of a Stash request:

- SnpUniqueStash
- SnpMakeInvalidStash
- SnpStashUnique
- SnpStashShared

Table 7-1 shows the Snoop requests associated with each of the Stash requests.

Table 7-1 Stash request and the corresponding Snoop request

| Stash request        | Snoop request       |
|----------------------|---------------------|
| WriteUniquePtlStash  | SnpUniqueStash      |
| WriteUniqueFullStash | SnpMakeInvalidStash |
| StashOnceUnique      | SnpStashUnique      |
| StashOnceSepUnique   |                     |
| StashOnceShared      | SnpStashShared      |
| StashOnceSepShared   |                     |

A Snoopee that receives a Stash Snoop request does one of the following:

- Provides a Snoop response that also acts as a Read request for the associated cache line. Including a Read request with Snoop response is referred to as a Data Pull. Table 7-2 shows the type of Read request that is implied by a Data Pull in the response to each Stash Snoop request.

Table 7-2 Snoop response with Data Pull and implied Read request

| Snoop request       | Implied Read request |
|---------------------|----------------------|
| SnpUniqueStash      | ReadUnique           |
| SnpMakeInvalidStash | ReadUnique           |
| SnpStashUnique      | ReadUnique           |
| SnpStashShared      | ReadNotSharedDirty   |

- Provides a Snoop response without a Data Pull response so ignoring the cache stash hint.

The value of the DataPull field in the SnpResp and SnpRespData responses indicates if Data Pull is requested. See [Data Pull, DataPull on page 13-433](#) for legal values for DataPull.

The use of Data Pull to complete a Snoop request with Stash is optional.

If the Snoopee is not able to support the Data Pull transaction flow, it is permitted to ignore the stash operation.

## 7.2 Write with Stash hint

The rules for sending and processing a WriteUniqueFullStash and WriteUniquePtlStash request at the Stash requester, the Home, and the Stash target node are as follows:

Requester responsibilities:

- Sends a WriteUniqueFullStash or WriteUniquePtlStash request depending on whether a full cache line or a partial cache line is to be written.
- The request is expected to include a Stash target.

Home responsibilities:

- Permitted to send a RetryAck response to a WriteUniqueStash request and follow the Retry transaction flow.
- Sends SnpUniqueStash to the identified Stash target.
- Sends SnpUnique to all other Requesters that share the cache line.
- Permitted to send SnpMakeInvalidStash and SnpMakeInvalid instead of SnpUniqueStash and SnpUnique respectively for WriteUniqueFullStash.
- Send Comp to the Requester after the coherency action is completed.
- Permitted to ignore the stash hint in the Write request and process the request as a regular WriteUnique.
- Handles a request without a Stash target in the manner described in *Stash target not specified on page 7-299*.
- Permitted to use DMT to get data from SN-F to the Stash target in response to a Data Pull request, when the data is neither available at Home nor obtained from any caches.
- Permitted to use separate Non-data and Data-only response to the Stash target in response to a Data Pull request.

The Stash target responsibilities:

- The responses that include Data Pull are:
  - SnpResp\_I\_Read
  - SnpRespData\_I\_Read
  - SnpRespData\_I\_PD\_Read
  - SnpRespDataPtl\_I\_PD\_Read
- Must not request Data Pull if:
  - Snoop has an address hazard with an outstanding request.
  - The Stash target has an outstanding request to the same address that has received a DBIDRespOrd but has not completed.
- When requesting Data Pull:
  - The Stash target must guarantee the Read data is accepted without any structural or protocol dependencies that might result in deadlock.
  - The Read request is treated by Home as ReadUnique.
  - The Stash target must populate the DBID field in the response with the TxnID that is to be used by Home for the Read transaction. If the Snoop response with Data Pull includes data, then the DBID field value in all data packets must be the same.
- Permitted to ignore the Stash hint and handle the snoop as SnpUnique.

## 7.3 Independent Stash request

The second mechanism for implementing cache stashing is to permit the Stash request to be sent separated in time from the writing of Stash data. Examples of when such a mechanism is useful are:

- When the data that is being written is not required by the target immediately. This delayed Stash avoids polluting the cache with data that is not used immediately.
- When the data is already in the system and the data has to be prefetched into caches.
- When the process using the data being written is not scheduled when the data is written, and therefore the precise target of the Stash data is not known until later.

In these cases, a Requester can use StashOnce or StashOnceSep requests to request Home or a peer node to fetch a cache line.

The rules for sending and processing an independent Stash request at the Stash requester, Home, and the Stash target are as follows:

Requester Node responsibilities:

- Sends StashOnceUnique or StashOnceSepUnique to Home if the stashed cache line is to be modified.
- Sends StashOnceShared or StashOnceSepShared to Home if the stashed cache line is not to be modified.
- Sends StashOnceSep only if the Requester is capable of handling the StashDone response.
- The StashOnce and StashOnceSep requests provide a Stash target when the data is to be stashed in a peer cache.
- The StashOnce and StashOnceSep requests do not provide a Stash target when the data is to be allocated in the next level cache.
- The Requester, upon receiving the Comp response, is permitted to release some request resources, while keeping track of the number of outstanding StashDone responses. This count of the number of outstanding StashDone responses can be done per Stash group, using the Requester defined Stash Group ID, specified by the StashGroupID field value.

Home Node responsibilities:

- Permitted to send a RetryAck response to a Stash request and follow the Retry transaction flow.
- Send a SnpStashUnique to the target RN-F for StashOnceUnique and StashOnceSepUnique.
- Send a SnpStashShared to the target RN-F for StashOnceShared and StashOnceSepShared.
- Permitted to not send a Snoop request in response to a Stash request.
- Must send a Comp response, even if it abandons the Stash request.
- For the StashOnce, the Home must send a Comp only after establishing processing order for the received request that is guaranteeing that any request to the same address received later from any Requester is ordered behind this request. The Comp response must come from the PoC.
- For the StashOnceSep request, the Home must send a Comp only after establishing the guarantee that it will not send a RetryAck response. The StashDone response must only be sent after establishing the guarantee that the request is ordered at the Home.
- Fetches the addressed cache line from memory into the shared system cache when a Stash request without a Stash target is received.
- Permitted to send Comp after receiving the Stash request, and before sending any SnpStash or receiving the Snoop response.
- Send Comp with a Non-Invalid state, if the cache line is cached in the cache at the next level.

Send Comp\_I if the cache line is not cached, or it is not known if the cache line is cached, in the cache at the next level.

- Send a Comp\_I response if either the cache look up at Home is a miss or Home did not look up the cache before responding.
- Permitted to use DMT to get data from SN-F to the Stash target in response to a Data Pull request.
- Permitted to use separate Non-data and Data-only response to the Stash target in response to a Data Pull request.

Stash target responsibilities:

- The snoop must not change the state of the cache line at the Stash target.
- The snoop is treated as a hit at the Stash target to obtain a copy of the cache line.
- Must not request Data Pull if:
  - Snoop has an address hazard with an outstanding request.
  - Response is sent before performing a local cache lookup.
  - The snoop is SnpStashShared and the cache has a copy of the cache line.
  - The Stash target has an outstanding request to the same address that has received a DBIDRespOrd but not yet completed.
- When requesting Data Pull:
  - The Stash target must guarantee the Read data is accepted without any structural or protocol dependencies that might result in deadlock.
  - The DataPull request is treated by Home as ReadNotSharedDirty for SnpOnceShared.
  - The DataPull request is treated by Home as ReadUnique for SnpOnceUnique.
  - The Home must treat the Stash request and the DataPull request atomically as a single request. That is, the Home must not order any other request to the same address between the Stash request and the corresponding DataPull request.
  - The Stash target must populate the DBID field in the response with the TxnID that is to be used by Home for the Read transaction.
- A DataPull request can be sent, but is not required to be sent, when the snoop is SnpStashUnique and a shared copy is present.
- The Stash target is permitted, but not required, to wait until it completes the local cache lookup before sending the Snoop response.
- The cache state in the Snoop response is not required to be precise:
  - An imprecise response must be SnpResp\_I.
  - Any state other than I in the response must be precise.

###### — Note —

- For StashOnce\*, care is needed to avoid any action that could result in the deallocation of the cache line from the cache where it is expected to be used.
- A StashOnce\*Unique transaction can cause the invalidation of a copy of the cache line and care must be taken to ensure such transactions do not interfere with Exclusive access sequences.

The requirements regarding the sending of Stash type snoops from a Home, and the permitted responses by the target, are the same as the request/response rules for StashOnceSep transactions. See [Stash transactions on page 2-69](#).

## 7.4 Stash target identifiers

For all Stash requests, both options of specified and non-specified Stash target are supported.

### 7.4.1 Stash target specified

If the Stash target is available in the Stash request then Home sends the snoop with a stash hint to the specified target. The specified target can be a Request Node or a logical processor within a Request Node.

### 7.4.2 Stash target not specified

The Home Node that receives a WriteUniquePtlStash or WriteUniqueFullStash request without a Stash target does the following:

- If the cache line is cached in a Unique state at a Request Node, then Home can treat that Request Node as the Stash target.
- If the cache line is not cached in a Unique state then Home must only send SnpUnique as required, and must not send SnpUniqueStash to any Request Node.
- For WriteUniquePtlStash, if the cache line is not in any cache, it is recommended that the Home prefetches and allocates the cache line in the system cache. It is permitted, but not recommended, to perform a partial write to main memory.
- For WriteUniqueFullStash, if the cache line is not in any cache then Home is permitted to allocate the cache line in the shared system cache.

The Home Node that receives a StashOnce or StashOnceSep request without a Stash target does the following:

- If the cache line is not cached in any peer cache, it is recommended that the cache line is allocated in the shared system cache.
- If the cache line is cached in a peer cache, then it is **IMPLEMENTATION DEFINED** if a snoop is sent to transfer a copy of the cache line and allocate it in the shared system cache. For StashOnceUnique and StashOnceSepUnique, it is also **IMPLEMENTATION DEFINED** if all cached copies are invalidated before allocating the cache line in the shared system cache.

## 7.5 Stash messages

Stash messages are classified as:

- Write requests:
  - WriteUniqueFullStash
  - WriteUniquePtIStashSee [Write transactions on page 4-176](#).
- Dataless requests:
  - StashOnceUnique
  - StashOnceSepUnique
  - StashOnceShared
  - StashOnceSepSharedSee [Dataless transactions on page 4-169](#).
- Snoop requests:
  - SnpUniqueStash
  - SnpMakeInvalidStash
  - SnpStashUnique
  - SnpStashSharedSee [Snoop request types on page 4-191](#).
- Stash responses:
  - Comp
  - StashDone
  - CompStashDoneSee [Stash transactions on page 2-69](#).

### 7.5.1 Supporting REQ packet fields

The fields defined in the REQ packet to support Stash requests are:

- StashNID, StashLPID
- StashNIDValid, StashLPIDValid

Table 7-3 shows the valid StashNIDValid and StashLPIDValid encodings.

Table 7-3 Valid StashNIDValid and StashLPIDValid encodings

| StashNIDValid | StashLPIDValid | Comments                              |
|---------------|----------------|---------------------------------------|
| 0             | 0              | Stash target is not specified         |
| 0             | 1              | Reserved                              |
| 1             | 0              | Only a target RN is specified         |
| 1             | 1              | Both target RN and LPID are specified |

See [Protocol flit fields on page 13-416](#).

### 7.5.2 Supporting SNP packet fields

The fields defined in the SNP packet to support Stash requests are:

- StashLPID
- StashLPIDValid

See [Protocol flit fields on page 13-416](#).

### 7.5.3 Supporting RSP packet field

The field defined in the RSP packet to support Stash requests is DataPull.

See [Protocol flit fields on page 13-416.](#)

### 7.5.4 Supporting DAT packet fields

The field defined in the DAT packet to support Stash requests is DataPull.

See [Protocol flit fields on page 13-416.](#)



# Chapter 8DVM Operations

This chapter describes *Distributed Virtual Memory* (DVM) operations that the protocol uses to manage virtual memory. It contains the following sections:

- [DVM transaction flow on page 8-304](#)
- [DVM Operation types on page 8-315](#)
- [DVM Operations on page 8-322](#)

## 8.1 DVM transaction flow

All DVM transactions have similar requirements and are mapped to a single flow. The following sections show the Non-sync and Sync DVM transaction requirements:

- [Non-sync type DVM transaction flow](#)
- [Sync type DVM transaction flow on page 8-305](#)
- [Flow control on page 8-307](#)
- [DVMOp field value restrictions on page 8-309](#)
- [Field value requirements on page 8-314](#)

### 8.1.1 Non-sync type DVM transaction flow

Figure 8-1 shows the steps in a Non-sync type DVM transaction.

![](4806036bb147faa6a60223e6187e01bd_img.jpg)

Sequence Diagram: Non-sync type DVM transaction flow.

Participants (Lanes): RN-F0, Core-1, RN-F1, Core-2, RN-F2, MN.

Flow:

1. RN-F0 sends DVMOp(Non-sync) to MN.
2. MN sends DBIDResp to RN-F0.
3. MN sends NCBWrData to Core-1.
4. Core-1 sends Snoop sent to core to Core-2.
5. Core-1 sends SnpDVMOp\_P1 to Core-2.
6. Core-1 sends SnpDVMOp\_P2 to Core-2.
7. Core-2 sends SnpDVMOp\_P1 to Core-1.
8. Core-2 sends SnpDVMOp\_P2 to Core-1.
9. Core-2 sends SnpResp\_I to Core-1.
10. Core-2 sends SnpResp\_I to Core-1.
11. Core-1 sends Comp to RN-F0.

Annotation on RN-F0:

DVMOp(Sync) can only be sent after all prior DVMOp transactions receive Comp responses.

Definition:

NCBWrData = NonCopyBackWrData

Figure 8-1 Non-sync type DVM transaction flow

The required steps that Figure 8-1 on page 8-304 shows are:

1. RN-F0 sends a DVMOp(Non-sync) to the Miscellaneous Node using the appropriate write semantics for the DVMOp type.
2. The Miscellaneous Node accepts the DVMOp(Non-sync) request and provides a DBIDResp response.
3. The RN-F0 sends an 8-byte data packet on the data channel.
4. The MN broadcasts the SnpDVMOp snoop request to all the RN-F and RN-D nodes in the system. The SnpDVMOp is sent on the Snoop channel, and requires two Snoop requests. The two parts of the SnpDVMOp are labeled by the suffix \_P1 and \_P2.

###### **Note**

- Both parts of the message must carry the same *Transaction ID* (TxnID).
- The Request Node must have resources available to accept the SnpDVMOp. See *Flow control on page 8-307*.

1. After completing the required actions, each recipient of the SnpDVMOp sends a single SnpResp response to the Miscellaneous Node.

###### **Note**

Sending of a SnpResp implies that the target Request Node has forwarded the SnpDVMOp to the required Request Node structures and has freed up the resources needed to accept another DVM operation. It does not imply that the requested DVM operation has completed. See *Sync type DVM transaction flow*.

1. After receiving all the SnpResp responses, the Miscellaneous Node sends a Comp response to the requesting node.

#### DVM early Comp for Non-sync DVMOps

The Miscellaneous Node in the interconnect is permitted to send Comp for a Non-sync DVMOp without waiting to complete the required snooping of Request Nodes. Such a Miscellaneous Node must take the responsibility of ordering this Non-sync DVMOp against any Sync DVMOp received later from the same source. If a Miscellaneous Node cannot provide such an ordering guarantee, then it must wait for the snooping to be completed before sending a Comp response for a Non-sync DVMOp.

A Miscellaneous Node that is enabled to send early Comp for a Non-sync DVMOp is permitted to opportunistically combine Comp and DBIDResp responses into a single CompDBIDResp response.

###### **Note**

- Sending of a Comp response early for Non-sync DVMOp reduces round-trip latency for DVMOp completion. This enables a greater number of DVMOp transactions to be pipelined from a single source.
- Such an early completion also enables a Sync DVMOp, which is waiting for completions of all related DVMOp transactions sent earlier from the same Request Node.

The Miscellaneous Node must still wait for the Snoop response for a Sync DVMOp to be received before sending a Comp to the Requester for that Sync DVMOp.

### 8.1.2 Sync type DVM transaction flow

Figure 8-2 on page 8-306 shows the flow in a Sync DVM transaction.

![](9a7529944212e1276302d5db7ee841e0_img.jpg)

Sequence Diagram illustrating the Sync DVM transaction flow between RN-F0, Core-1, RN-F1, and MN.

Participants (Lifelines): RN-F0, Core-1, RN-F1, MN.

Flow:

1. RN-F0 sends `DVMOp(Sync)` to MN.
2. MN sends `DBIDResp` to RN-F0.
3. RN-F0 sends `NCBWrData` to MN.
4. MN sends `SnpDVMOp_P1` to Core-1.
5. MN sends `SnpDVMOp_P2` to Core-1.
6. Core-1 sends `SnpResp_1` to MN.
7. Core-1 sends `Comp` to RN-F0.

Annotation: `SnpResp` only sent after all DVM related operations are complete in the core.

Legend: `NCBWrData` = NonCopyBackWrData

Figure 8-2 Sync DVM transaction flow

The required steps that Figure 8-2 on page 8-306 shows are:

1. RN-F0 sends a DVMOp(Sync) to the Miscellaneous Node.

###### — Note —

All previous DVMOp requests whose completion needs to be guaranteed by the DVMOp(Sync) must have received a Comp response before the Request Node can send a DVMOp(Sync).

1. The Miscellaneous Node accepts the DVMOp(Sync) request and sends a DBIDResp response to the Requester.
2. The RN-F0 sends a data packet on the data channel with a data size of 8 bytes.
3. The Miscellaneous Node sends the SnpDVMOp to RN-F1. The SnpDVMOp is sent on the Snoop channel, and requires two Snoop requests. The two parts of a SnpDVMOp are labeled by the suffix \_P1 and \_P2.
4. After completing the DVM Sync operation, RN-F1 sends a SnpResp response to the Miscellaneous Node.

###### — Note —

Sending of a SnpResp implies that all DVM-related operations have completed at the Request Node structures and the target Request Node has freed up the resources needed to accept another SnpDVMOp.

1. After receiving the SnpResp, the Miscellaneous Node sends a Comp response to RN-F0.

### 8.1.3 Flow control

DVMOp request flow control:

- A DVMOp can receive a RetryAck response from a Miscellaneous Node.
- A DVMOp that receives a RetryAck response must wait for a PcrdGrant response from the Miscellaneous Node that has the appropriate PcrdType.
- All previous DVMOp requests whose completion needs to be guaranteed by the DVMOp(Sync) must have received a Comp response before the Request Node can send the DVMOp(Sync).
- The interconnect must guarantee forward progress on DVMOp(Non-Sync), which requires that there should be at least one tracker entry in the Miscellaneous Node reserved for DVMOp(Non-Sync).
- It is permitted to overlap a DVMOp(Non-sync) and a DVMOp(Sync), from the same Request Node, if the DVMOp(Sync) is not required to guarantee completion of the DVMOp(Non-sync).

SnpDVMOp flow control:

- Each SnpDVMOp transaction requires two SnpDVMOp request packets.
- Both SnpDVMOp request packets corresponding to a single transaction must use the same TxnID.
- The two SnpDVMOp request packets corresponding to a single transaction can be sent or received in any order.
- Multiple SnpDVMOp(Non-sync) transactions can be outstanding from a Miscellaneous Node.
- Only one SnpDVMOp(Sync) transaction can be outstanding from a Miscellaneous Node to a Request Node.
- To prevent deadlocks, due to the two part SnpDVMOp requests that use the Snoop channel, a SnpDVMOp transaction must only be sent when the receiving Request Node has pre-allocated resources to accept both parts of the SnpDVMOp transaction.
- A Sync DVM operation at a Request Node that has issued a StashOnceSep request must wait until all outstanding StashDone responses are received for StashOnceSep requests that use invalidated page entries.

- A Request Node must provide a response to a SnpDVMOp transaction only after it has received both SnpDVMOp request packets corresponding to that transaction.
- A Request Node must provide a response to a SnpDVMOp only when it can accept a further SnpDVMOp from a Miscellaneous Node.
- Each RN-F and RN-D in the system specifies the number of SnpDVMOp transactions it can accept concurrently.
- Each RN-F and RN-D in the system must be able to accept at least one SnpDVMOp(Non-Sync) transaction in addition to a SnpDVMOp(Sync) transaction.
- The minimum number of SnpDVMOp transactions that must be accepted concurrently is two. This is the default number for Request Nodes that do not specify a number.

### 8.1.4 DVMOp field value restrictions

Field value restrictions during a DVMOp transaction are shown:

- Request messages in Table 8-1
- Data messages in Table 8-2 on page 8-310
- Snoop messages in Table 8-3 on page 8-311
- Response messages:
  - DBIDResp in Table 8-4 on page 8-312
  - SnpResp in Table 8-5 on page 8-313
  - Comp in Table 8-6 on page 8-314

Table 8-1 shows the Request message field value restrictions for a DVMOp transaction.

Table 8-1 Request message field value restrictions for DVMOp

| Field Name     | Restriction                                                                                         |
|----------------|-----------------------------------------------------------------------------------------------------|
| QoS            | None. Can take any value.                                                                           |
| TgtID          | Expected to be node ID of Miscellaneous Node. Can be remapped to correct TgtID by the interconnect. |
| SrcID          | Source ID of the Requester that initiated the DVM message.                                          |
| TxnID          | An ID generated by the Requester. Must follow the same rules as any other transaction.              |
| ReturnNID      | Must be all zeros.                                                                                  |
| StashNID       |                                                                                                     |
| SLCrepHint     |                                                                                                     |
| StashNIDValid  | Must be zero.                                                                                       |
| Endian         |                                                                                                     |
| Deep           |                                                                                                     |
| ReturnTxnID    | Must be all zeros.                                                                                  |
| StashLPIDValid |                                                                                                     |
| StashLPID      |                                                                                                     |
| Opcode         | Must be DVMOp.                                                                                      |
| Size           | Must be 8-byte.                                                                                     |
| Addr           | Req_Addr_Width.<br>See <i>DVM Operations</i> on page 8-322                                          |
| NS             | Must be zero.                                                                                       |
| LikelyShared   | Must be zero.                                                                                       |
| AllowRetry     | Can take any value, because a DVMOp can be given a Retry.                                           |
| Order          | Must be all zeros                                                                                   |
| PCrdType       | Must be all zeros if AllowRetry is asserted, otherwise the Credit type value.                       |
| MemAttr        | Must be all zeros.                                                                                  |

Table 8-1 Request message field value restrictions for DVMOp (continued)

| Field Name | Restriction                                                    |
|------------|----------------------------------------------------------------|
| SnpAttr    | None. Can take any value. See <i>DVM domain</i> on page 8-321. |
| LPID       | None. Can take any value.                                      |
| Excl       | Must be zero.                                                  |
| SnoopMe    |                                                                |
| ExpCompAck | Must be zero.                                                  |
| TagOp      | Must be zero.                                                  |
| TraceTag   | None.                                                          |
| MPAM       | Must be all zeros.                                             |
| RSVDC      | None. Can take any value.                                      |

Table 8-2 shows the Data message field value restrictions for a DVMOp transaction.

Table 8-2 Data message field value restrictions for DVMOp

| Field Name | Restriction                                                  |
|------------|--------------------------------------------------------------|
| QoS        | None. Can take any value.                                    |
| TgtID      | Must be the same as SrcID returned in the DBIDResp response. |
| SrcID      | Must be ID of the original Requester.                        |
| TxnID      | Must be the same as DBID of the DBIDResp response.           |
| HomeNID    | Must be all zeros.                                           |
| Opcode     | Must be NonCopyBackWriteData.                                |
| RespErr    | Must be 0b00 or 0b10.                                        |
| Resp       | Must be all zeros.                                           |
| FwdState   | Must be all zeros.                                           |
| DataPull   |                                                              |
| DataSource |                                                              |
| CBusy      | Must be all zeros.                                           |
| DBID       | None. Can take any value.                                    |
| CCID       | Must be all zeros.                                           |
| DataID     | Must be all zeros.                                           |
| TagOp      | Must be all zeros.                                           |
| Tag        | Must be zero.                                                |
| TU         | Must be zero.                                                |
| TraceTag   | None.                                                        |

Table 8-2 Data message field value restrictions for DVMOp (continued)

| Field Name | Restriction                                                                  |
|------------|------------------------------------------------------------------------------|
| RSVDC      | None.                                                                        |
| BE         | Only BE[7:0] must be asserted.                                               |
| Data       | Unused bits must be zero for Data[63:0] and Data[n:64] = Can take any value. |
| DataCheck  | Must be the appropriate value for the Data field.                            |
| Poison     | None. Can take any value.                                                    |

Table 8-3 shows the Snoop message field (SnpDVMOp) value restrictions during a DVMOp transaction.

Table 8-3 Snoop message field value restrictions for DVMOp

| Field Name  | Restriction                                                          |
|-------------|----------------------------------------------------------------------|
| QoS         | None. Can take any value.                                            |
| SrcID       | Must be node ID of MN.                                               |
| TxnID       | An ID generated by MN.                                               |
| FwdNID      | None. Used as Range and Num[4:0] fields. See Table 8-9 on page 8-320 |
| VMIDExt     | Must be used for VMID extension.                                     |
| Opcode      | Must be SnpDVMOp.                                                    |
| Addr        | (Req_Addr_Width - 3).<br>See <i>DVM Operations</i> on page 8-322.    |
| NS          | Must be zero.                                                        |
| DoNotGoToSD | Must be zero.                                                        |
| RetToSrc    | Must be zero.                                                        |
| TraceTag    | None.                                                                |
| MPAM        | Must be all zeros.                                                   |

Table 8-4 shows the Response DBIDResp message field value restrictions during a DVMOp transaction.

Table 8-4 Response DBIDResp message field value restrictions for DVMOp

| Field Name                                     | Restriction                                  |
|------------------------------------------------|----------------------------------------------|
| QoS                                            | None. Can take any value.                    |
| TgtID                                          | Must be ID of the original Requester.        |
| SrcID                                          | Must be ID of the MN that is handling DVMs.  |
| TxnID                                          | Must match TxnID of the original request.    |
| Opcode                                         | Must be DBIDResp.                            |
| RespErr                                        | Must be all zeros.                           |
| Resp                                           | Must be all zeros.                           |
| FwdState<br>DataPull                           | Must be all zeros.                           |
| CBusy                                          | Expected to be populated by the Completer.   |
| DBID<br>TagGroupID<br>StashGroupID<br>PGroupID | Generated by the MN that is handling DVMOps. |
| PCrdType                                       | Must be all zeros.                           |
| TagOp                                          | Must be all zeros.                           |
| TraceTag                                       | None.                                        |

Table 8-5 shows the Response SnpResp message field value restrictions during a DVMOp transaction.

Table 8-5 Response SnpResp message field value restrictions for DVMOp

| Field Name                                     | Restriction                                             |
|------------------------------------------------|---------------------------------------------------------|
| QoS                                            | None. Can take any value.                               |
| TgtID                                          | Must be ID of the MN that is handling DVMOps.           |
| SrcID                                          | Must be ID of the node that is responding to the snoop. |
| TxnID                                          | Must match the TxnID of the SnpDVMOp snoop request.     |
| Opcode                                         | Must be SnpResp.                                        |
| RespErr                                        | Must be all zeros.                                      |
| Resp                                           | Must be all zeros.                                      |
| FwdState<br>DataPull                           | Must be all zeros.                                      |
| CBusy                                          | Expected to be populated by the Completer.              |
| DBID<br>TagGroupID<br>StashGroupID<br>PGroupID | None. Can take any value.                               |
| PCrdType                                       | Must be all zeros.                                      |
| TagOp                                          | Must be all zeros.                                      |
| TraceTag                                       | None.                                                   |

Table 8-6 shows the Response Comp and CompDBIDResp message field value restrictions during a DVMOp transaction.

Table 8-6 Response Comp and CompDBIDResp message field value restrictions for DVMOp

| Field Name   | Restriction                                 |
|--------------|---------------------------------------------|
| QoS          | None. Can take any value.                   |
| TgtID        | Must be ID of the original Requester.       |
| SrcID        | Must be ID of the MN that is handling DVMs. |
| TxnID        | Must match TxnID of the original request.   |
| Opcode       | Must be Comp.                               |
| RespErr      | None. Can take any value.                   |
| Resp         | Must be all zeros.                          |
| FwdState     | Must be all zeros.                          |
| DataPull     |                                             |
| CBusy        | Expected to be populated by the Completer.  |
| DBID         | Generated by the MN that is handling DVMs.  |
| TagGroupId   |                                             |
| StashGroupId |                                             |
| PGroupId     |                                             |
| PCrdType     | Must be all zeros.                          |
| TagOp        | Must be all zeros.                          |
| TraceTag     | None.                                       |

### 8.1.5 Field value requirements

Both SnpDVMOp request packets, corresponding to a single DVMOp, must have the same value in the following fields:

- TxnID
- Opcode
- SrcID
- TgtID

## 8.2 DVM Operation types

The following DVM Operations are supported:

- TLB Invalidate.
- Branch Predictor Invalidate.
- Instruction Cache Invalidate:
  - Physical address invalidate.
  - Virtual address invalidate.
- Synchronization.

### 8.2.1 DVMOp payload

The payload of a DVM operation from the Request Node to the Miscellaneous Node is distributed within:

- The address field in the DVM request from the Request Node.
- The lower 8 bytes of write data in the NonCopyBackWrData packet.

The payload of a DVM operation from the Miscellaneous Node to the Request Node is distributed over two SnpDVMOp request packets using the address fields.

The various fields in the payload and their encodings are shown in Table 8-7.

Table 8-7 DVMOp fields and encodings

| Field           | Bits | Function                                                                                                                                                                                                                                                                                                                                               |
|-----------------|------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| VA Valid        | 1    | 0b1 indicates that the specified address is valid.                                                                                                                                                                                                                                                                                                     |
| VMID Valid      | 1    | 0b1 indicates that the Virtual Machine Identifier (VMID) or Virtual Index (VI) is valid.                                                                                                                                                                                                                                                               |
| ASID Valid      | 1    | 0b1 indicates that the Address Space Identifier (ASID) or VI is valid.                                                                                                                                                                                                                                                                                 |
| Security        | 2    | Indicates that the transaction applies to:<br>0b00 Secure and Non-secure<br>0b01 Non-secure address from a Secure context<br>0b10 Secure and Non-secure if DVMOp type is PICI and invalidation is all. Secure in all other cases.<br><br>— Note —<br>This update applies retrospectively to all prior issues of this specification.<br>0b11 Non-secure |
| Exception Level | 2    | Indicates that the transaction applies to:<br>0b00 Hypervisor and all Guest OS<br>0b01 EL3*<br>0b10 Guest OS<br>0b11 Hypervisor                                                                                                                                                                                                                        |
| DVMOp type      | 3    | Indicates the DVM operation type as:<br>0b000 TLB Invalidate<br>0b001 Branch Predictor Invalidate<br>0b010 Physical Instruction Cache Invalidate<br>0b011 Virtual Instruction Cache Invalidate<br>0b100 Synchronization<br>0b101-0b111 Reserved                                                                                                        |
| VMID            | 8    | Virtual Machine ID VMID[7:0] or Virtual Index VA[27:20]                                                                                                                                                                                                                                                                                                |

Table 8-7 DVMOp fields and encodings (continued)

| Field                                 | Bits                 | Function                                                                                                                                                                                                                                                                                                                                                                                            |
|---------------------------------------|----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ASID                                  | 16                   | Address Space ID or Virtual Index VA[19:12] <sup>b</sup>                                                                                                                                                                                                                                                                                                                                            |
| Staged Invalidation                   | 2                    | Indicates Stage 2 or Stage 1 invalidation:<br>0b00 <ul><li>DVMv7: Any transaction.</li><li>DVMv8: Both Stage 1 and Stage 2 invalidation.</li></ul> 0b01 Stage 1 invalidation only.<br>0b10 Stage 2 invalidation only.<br>0b11 Reserved.                                                                                                                                                             |
| Leaf Entry Invalidation               | 1                    | 0b1 indicates that only leaf level translation invalidation is required.                                                                                                                                                                                                                                                                                                                            |
| Range <sup>c</sup>                    | 1                    | Range can take any value. When:<br><b>Range = 1</b> The transaction is a range-based TLBI operation.<br><b>Range = 0</b> The transaction is a non-range based TLBI operation.<br>Range is inapplicable and must be zero for non-TLBI DVM transactions.                                                                                                                                              |
| Num <sup>c</sup>                      | 5                    | Used as a constant multiplication factor in the range calculation. All binary values are valid.                                                                                                                                                                                                                                                                                                     |
| Scale <sup>c</sup>                    | 2                    | Used as a constant in address range exponent calculation. All binary values are valid.                                                                                                                                                                                                                                                                                                              |
| Translation Table Level <sup>c</sup>  | 2                    | Hint of Translation Table Level, which includes the addresses to be invalidated:<br>0b00 The entries in the range can be using any level for the translation table entries.<br>0b01 All entries to invalidate are Level1 translation table entries.<br>0b10 All entries to invalidate are Level2 translation table entries.<br>0b11 All entries to invalidate are Level3 translation table entries. |
| Translation Granule Size <sup>c</sup> | 2                    | Translation Granule Size takes the following values:<br>0b00 Reserved<br>0b01 4K<br>0b10 16K<br>0b11 64K                                                                                                                                                                                                                                                                                            |
| BaseAddr or<br>VA or<br>PA            | 37<br>49-53<br>44-52 | Range base address<br>Virtual address<br>Physical address                                                                                                                                                                                                                                                                                                                                           |
| VMIDEExt                              | 8                    | Virtual Machine ID VMID[15:8]                                                                                                                                                                                                                                                                                                                                                                       |

a. DVMv8 only.  
b. When used as Virtual Index, the upper 8 bits of ASID are Can take any value.  
c. Inapplicable and must be set to zero in non-TLBI DVM Operations. See [Range-based TLBI payload on page 8-318](#) and [Level Hint in TLBI Operations on page 8-320](#) for details of how these fields are used in TLBI operations.

### 8.2.2 DVMOp and SnpDVMOp packet

Table 8-8 shows the distribution of the payload in the DVMOp request from the Request Node, using 8-byte write semantics, and the distribution of the payload in the SnpDVMOp requests from the Miscellaneous Node.

In the DVMOp, the combination of the address field in the request and the 8-byte write data transports the complete payload. REQ.Addr[3] is not used in the request and must be set to zero.

In the two SnpDVMOp requests the combination of the two address fields transports the complete payload. SNP.Addr[0] is used in a SnpDVMOp request to indicate which part of the payload is being transported.

The valid combinations of *Maximum PA* (MPA) and *Maximum VA* (MVA) address bits are:

- MPA = 44 : MVA = 49
- MPA = 45 : MVA = 51
- MPA = 46 to 52 : MVA = 53

See *Range-based TLBI payload* on page 8-318 and *Level Hint in TLBI Operations* on page 8-320.

Table 8-8 DVMOp and SnpDVMOp request payloads

| X in<br>Req.Addr[x]<br>Dat.Data[x] | Num bits | DVMOp Request       |                            |
|------------------------------------|----------|---------------------|----------------------------|
|                                    |          | Request             | Data                       |
| 2:0                                | 3        | -                   | Num[2:0] <sup>a</sup>      |
| 3                                  | 1        | 0                   | Num[3] <sup>a</sup>        |
| 4                                  | 1        | VA Valid            | Scale[0]<br>PA[6]<br>VA[6] |
| 5                                  | 1        | VMID Valid          | Scale[1]<br>PA[7]<br>VA[7] |
| 6                                  | 1        | ASID Valid          | TTL[0]<br>PA[8]<br>VA[8]   |
| 7                                  | 1        | Security[0]         | TTL[1]<br>PA[9]<br>VA[9]   |
| 8                                  | 1        | Security [1]        | TG[0]<br>PA[10]<br>VA[10]  |
| 9                                  | 1        | Exception Level [0] | TG[1]<br>PA[11]<br>VA[11]  |
| 10                                 | 1        | Exception Level [1] | VA[12]<br>PA[12]           |
| 13:11                              | 3        | DVMOp type[2:0]     | VA[15:13]<br>PA[15:13]     |

| X in<br>Snp.Addr[x] | Num bits | SnpDVMOp Request    |                            |
|---------------------|----------|---------------------|----------------------------|
|                     |          | Part 1              | Part 2                     |
| 0                   | 1        | 0                   | 1                          |
| 1                   | 1        | VA Valid            | Scale[0]<br>PA[6]<br>VA[6] |
| 2                   | 1        | VMID Valid          | Scale[1]<br>PA[7]<br>VA[7] |
| 3                   | 1        | ASID Valid          | TTL[0]<br>PA[8]<br>VA[8]   |
| 4                   | 1        | Security[0]         | TTL[1]<br>PA[9]<br>VA[9]   |
| 5                   | 1        | Security [1]        | TG[0]<br>PA[10]<br>VA[10]  |
| 6                   | 1        | Exception Level [0] | TG[1]<br>PA[11]<br>VA[11]  |
| 7                   | 1        | Exception Level [1] | VA[12]<br>PA[12]           |
| 10:8                | 3        | DVMOp type[2:0]     | VA[15:13]<br>PA[15:13]     |

Table 8-8 DVMOp and SnpDVMOp request payloads (continued)

| X in<br>Req.Addr[x]<br>Dat.Data[x] | Num bits | DVMOp Request                |                         |
|------------------------------------|----------|------------------------------|-------------------------|
|                                    |          | Request                      | Data                    |
| 21:14                              | 8        | VMID[7:0]                    | VA[23:16]<br>PA[23:16]  |
| 37:22                              | 16       | ASID[15:0]                   | VA[39:24]<br>PA[39:24]  |
| 39:38                              | 2        | Staged Invalidation<br>[1:0] | VA[41:40]<br>PA[41:40]  |
| 40                                 | 1        | Leaf Entry Invalidation      | VA[42]<br>PA[42]        |
| 41                                 | 1        | Range <sup>b</sup>           | VA[43]<br>PA[43]        |
| 42                                 | 1        | Num[4] <sup>a</sup>          | VA[44]<br>PA[44]        |
| 43                                 | 1        | -                            | VA[45]<br>PA[45]        |
| 44                                 | 1        | -                            | VA[46]<br>PA[46]        |
| 45                                 | 1        | -                            | VA[47]<br>PA[47]        |
| 48:46                              | 3        | -                            | VA[50:48]<br>PA[50:48]  |
| 49                                 | 1        | -                            | VA[51]<br>PA[51]        |
| 50                                 | 1        | -                            | VA[52]                  |
| 55:51                              | 5        | -                            | -                       |
| 63:56                              | 8        | -                            | VMID[15:8] <sup>a</sup> |

| X in<br>Snp.Addr[x] | Num bits | SnpDVMOp Request             |                        |
|---------------------|----------|------------------------------|------------------------|
|                     |          | Part 1                       | Part 2                 |
| 18:11               | 8        | VMID[7:0]                    | VA[23:16]<br>PA[23:16] |
| 34:19               | 16       | ASID[15:0]                   | VA[39:24]<br>PA[39:24] |
| 36:35               | 2        | Staged Invalidation<br>[1:0] | VA[41:40]<br>PA[41:40] |
| 37                  | 1        | Leaf Entry<br>Invalidation   | VA[42]<br>PA[42]       |
| 38                  | 1        | VA[46]                       | VA[43]<br>PA[43]       |
| 39                  | 1        | VA[47]                       | VA[44]<br>PA[44]       |
| 40                  | 1        | VA[48]                       | VA[45]<br>PA[45]       |
| 41                  | 1        | VA[50]                       | VA[49]<br>PA[46]       |
| 42                  | 1        | VA[52]                       | VA[51]<br>PA[47]       |
| 45:43               | 3        | -                            | PA[50:48]              |
| 46                  | 1        | -                            | PA[51]                 |
| 47                  | 1        | -                            | -                      |
| 48                  | 1        | -                            | -                      |

1. For part two of a SnpDVMOp request, Num[4:0] from the corresponding DVMOp request is carried on the FwdNID field of the Snop flit alongside the Addr field. See Table 8-9 on page 8-320.
2. For part one of a SnpDVMOp request, Range from the corresponding DVMOp request is carried on the FwdNID field of the Snop flit alongside the Addr field. See Table 8-9 on page 8-320.
3. For part one of a SnpDVMOp request, VMID[15:8] from the corresponding DVMOp request is carried on the VMIDExt field of the Snop flit alongside the Addr field. See Table 13-8 on page 13-413.

#### Range-based TLBI payload

Range-based TLBI operations include range-specific payload in addition to the payload fields in non-range-based TLBI operation. These additional range-based payload fields are applicable in both TLBI operation by VA and IPA.

Note

Prior to CHI Issue E, range-based TLBI operations are not defined.

The range-based fields are Range, BaseAddr, TG, TTL, Scale, and Num. These definitions of the fields and how they are used to compute the address range to invalidate is given below.

#### Range payload packing

Address range to invalidate is calculated using the following formula:

$$\text{Base Addr} \leftarrow \text{Addr to invalidate} \leftarrow \text{Base Addr} + ((\text{Num}+1) * 2^{\text{Scale}+1}) * \text{TG}$$

Where:

**BaseAddr** Shifted Base address of the range - 37 bits.  
The base address in the message is shifted based on the Transaction granule.  
The lowest address bit carried in the message is Address[12], Address[14], and Address[16] for Transaction Granule size of 4K, 16K, and 64K, respectively.

**TG** Translation Granule Size - 2 bits, takes the following values:

| 0b00 | Reserved |
|------|----------|
| 0b01 | 4K       |
| 0b10 | 16K      |
| 0b11 | 64K      |

**TTL** Translation Table Level - 2 bits.

**Scale** 2 bits, constant used in the address range exponent calculation. All binary values are valid.

**Num** 5 bits, constant used as multiplication factor in the range calculation. All binary values are valid.

The total number of bits in the Address range calculation is 48.

The range parameters are placed in the request packets as shown in Table 8-8 on page 8-317. The Range and Num values are carried on the FwdNID field in the Snoop flit alongside the Addr field for the corresponding Snoop transaction. Unused bits of FwdNID in SnpDVMOp must be set to zero.

Base address of the range operation is placed in VA[MaxVA:12], with significant address bits adjusted TG value in the following manner.

| <b>TG = 4K</b>  | VA[MaxVA:12].                                |
|-----------------|----------------------------------------------|
| <b>TG = 16K</b> | VA[MaxVA:14]; VA[13:12] must be set to zero. |
| <b>TG = 64K</b> | VA[MaxVA:16]; VA[15:12] must be set to zero. |

Table 8-9 shows the placement of the Range and Num values in the SnpDVMOp payload.

Table 8-9 Num value placement in SnpDVMOp payload

| Bit | SnpDVMOp request |        |
|-----|------------------|--------|
|     | Part 1           | Part 2 |
| 0   | Range            | Num[0] |
| 1   | 0                | Num[1] |
| 2   | 0                | Num[2] |
| 3   | 0                | Num[3] |
| 4   | 0                | Num[4] |
| 5   | 0                | 0      |
| 6   | 0                | 0      |

#### Level Hint in TLBI Operations

Non-range based TLBI operations by VA or IPA are permitted to use TG and TTL. These operations use TG and TTL as an indication of the level of the page table walk that holds the leaf entry for the address that is being invalidated. For such operations:

- Range field must be set to zero.
- Num and Scale fields are inapplicable and must be set to zero.
- When TG[1:0] = 00, TTL information is not provided.

TG and TTL fields are inapplicable and must be set to zero in non-range based TLBI operations which are not by VA or IPA.

Range, Num, Scale, TG, and TTL fields are inapplicable and must be set to zero in all non-TLBI DVM operations.

### 8.2.3 DVM domain

The SnpAttr bit in a DVM request is used to differentiate between Inner and Outer domain. Table 8-10 shows the SnpAttr value encoding in DVM transactions.

Table 8-10 SnpAttr value encoding in DVM transactions

| SnpAttr | Domain value |
|---------|--------------|
| 0       | Inner domain |
| 1       | Outer domain |

Two additional optional interface broadcast pins **BROADCASTTLBIINNER** (BTI) and **BROADCASTTLBIOUTER** (BTO) are defined that determine broadcasting of TLBI operations in the interconnect. See *Optional interface broadcast signals* on page 16-474.

## 8.3 DVM Operations

This section describes the supported DVM Operations:

- [TLB Invalidate](#)
- [Branch Predictor Invalidate on page 8-328](#)
- [Instruction cache invalidations on page 8-329](#)
- [Synchronization on page 8-331](#)

### 8.3.1 TLB Invalidate

This section shows the supported TLB Invalidate operations.

- [TLB Invalidate, All Guest OS, Secure operations](#)
- [TLB Invalidate, All Guest OS, Non-secure IPA, Secure operations on page 8-323.](#)
- [TLB Invalidate, All Guest OS, Non-secure operations on page 8-324](#)
- [TLB Invalidate, Hypervisor, Secure operations on page 8-324](#)
- [TLB Invalidate, Hypervisor, Non-secure operations on page 8-326](#)
- [TLB Invalidate EL3, Secure operations on page 8-327](#)

#### TLB Invalidate, All Guest OS, Secure operations

Table 8-11 shows the fixed value fields for TLB Invalidate, All Guest OS, Secure operations.

Table 8-11 TLB Invalidate, All Guest OS, Secure operations fixed values

| Field           | Value | Status       |
|-----------------|-------|--------------|
| DVMOp Type      | 0b00  | TLBI         |
| Exception Level | 0b10  | All Guest OS |
| Security        | 0b10  | Secure       |

Table 8-12 shows the TLB Invalidate values for All Guest OS, Secure operations.

In Table 8-12, the VA field holds the IPA or PA as required.

Table 8-12 TLB Invalidate, All Guest OS, Secure operations

| Addr | ASID<br>valid | VMD<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid | Operation                                            |
|------|---------------|--------------|----------------------------|------------------------|-------------|------------------------------------------------------|
| 0b0  | 0b0           | 0b0          | 0b0                        | 0b00                   | 0b0         | Secure TLB Invalidate all                            |
| 0b0  | 0b0           | 0b0          | 0b0                        | 0b00                   | 0b1         | Secure TLB Invalidate by VA                          |
| 0b0  | 0b0           | 0b1          | 0b0                        | 0b00                   | 0b1         | Secure TLB Invalidate by VA Leaf Entry only          |
| 0b1  | 0b0           | 0b0          | 0b0                        | 0b00                   | 0b0         | Secure TLB Invalidate by ASID                        |
| 0b1  | 0b0           | 0b0          | 0b0                        | 0b00                   | 0b1         | Secure TLB Invalidate by ASID and VA                 |
| 0b1  | 0b0           | 0b1          | 0b0                        | 0b00                   | 0b1         | Secure TLB Invalidate by ASID and VA Leaf Entry only |
| 0b0  | 0b1           | 0b0          | 0b0                        | 0b01                   | 0b0         | Secure Guest OS, TLBI all, S1 invalidation only      |
| 0b1  | 0b1           | 0b0          | 0b0                        | 0b00                   | 0b0         | Secure Guest OS, TLBI by ASID                        |

Table 8-12 TLB Invalidate, All Guest OS, Secure operations (continued)

| Addr | ASID<br>valid | VMID<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid | Operation                                       |
|------|---------------|---------------|----------------------------|------------------------|-------------|-------------------------------------------------|
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b00                   | 0b1         | Secure Guest OS, TLBI by VA                     |
| 0b0  | 0b1           | 0b1           | 0b1                        | 0b00                   | 0b1         | Secure Guest OS, TLBI by VA, Leaf only          |
| 0b1  | 0b1           | 0b0           | 0b0                        | 0b00                   | 0b1         | Secure Guest OS, TLBI by ASID and VA            |
| 0b1  | 0b1           | 0b1           | 0b1                        | 0b00                   | 0b1         | Secure Guest OS, TLBI by ASID and VA, Leaf only |
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b10                   | 0b1         | Secure Guest OS, TLBI by Secure IPA             |
| 0b0  | 0b1           | 0b1           | 0b1                        | 0b10                   | 0b1         | Secure Guest OS, TLBI by Secure IPA, Leaf only  |
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b00                   | 0b0         | Secure Guest OS TLBI all                        |

a. All DVMv7 transactions must use 0b00.

#### TLB Invalidate, All Guest OS, Non-secure IPA, Secure operations

Table 8-13 shows the fixed value fields for TLB Invalidate, All Guest OS, Non-secure IPA, Secure operations.

Table 8-13 TLB Invalidate, All Guest OS, Non-secure IPA, Secure operations fixed values

| Field           | Value | Status                                   |
|-----------------|-------|------------------------------------------|
| DVMOp           | 0b000 | TLBI                                     |
| Exception Level | 0b10  | All Guest OS                             |
| Security        | 0b01  | Non-secure address from a Secure context |

Table 8-14 on page 8-323 shows the values for TLB Invalidate, All Guest OS, Non-Secure IPA, Secure operations.

In Table 8-14, the VA field holds the IPA.

Table 8-14 TLB Invalidate, All Guest OS, Non-secure IPA, Secure operations

| Addr | ASID<br>valid | VMID<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid | Operation                                         |
|------|---------------|---------------|----------------------------|------------------------|-------------|---------------------------------------------------|
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b10                   | 0b1         | Secure Guest OS, TLBI by Non-secure IPA           |
| 0b0  | 0b1           | 0b1           | 0b1                        | 0b10                   | 0b1         | Secure Guest OS, TLBI by Non-secure IPA Leaf only |

#### TLB Invalidate, All Guest OS, Non-secure operations

Table 8-15 shows the fixed value fields for TLB Invalidate, All Guest OS, Non-secure operations.

Table 8-15 TLB Invalidate, All Guest OS, Non-secure operations fixed values

| Field           | Value | Status       |
|-----------------|-------|--------------|
| DVMOp           | 0b000 | TLBI         |
| Exception Level | 0b10  | All Guest OS |
| Security        | 0b11  | Non-Secure   |

Table 8-16 shows the values for TLB Invalidate, Guest OS, Non-Secure operations.

Table 8-16 TLB Invalidate Guest OS, Non-secure operations

| Addr | ASID<br>valid | VMID<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid      | Operation                                                                             |
|------|---------------|---------------|----------------------------|------------------------|------------------|---------------------------------------------------------------------------------------|
| 0b0  | 0b0           | 0b0           | 0b0                        | 0b00 <sup>a</sup>      | 0b0              | All Guest OS TLB Invalidate all                                                       |
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b01                   | 0b0              | Guest OS TLB Invalidate all<br>Stage 1 invalidation only                              |
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b00 <sup>a</sup>      | 0b0              | Guest OS TLB Invalidate all<br>ARMv7 must carry out Stage 1 and Stage 2 invalidation. |
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b00 <sup>a</sup>      | 0b1              | Guest OS TLB Invalidate by VA                                                         |
| 0b0  | 0b1           | 0b1           | 0b1                        | 0b00 <sup>a</sup>      | 0b1              | Guest OS TLB Invalidate by VA Leaf Entry only                                         |
| 0b1  | 0b1           | 0b0           | 0b0                        | 0b00 <sup>a</sup>      | 0b0              | Guest OS TLB Invalidate by ASID                                                       |
| 0b1  | 0b1           | 0b0           | 0b0                        | 0b00 <sup>a</sup>      | 0b1              | Guest OS TLB Invalidate by ASID and VA                                                |
| 0b1  | 0b1           | 0b1           | 0b1                        | 0b00 <sup>a</sup>      | 0b1              | Guest OS TLB Invalidate by ASID and VA Leaf Entry only                                |
| 0b0  | 0b1           | 0b0           | 0b0                        | 0b10                   | 0b1 <sup>b</sup> | Guest OS TLB Invalidate by IPA                                                        |
| 0b0  | 0b1           | 0b1           | 0b1                        | 0b10                   | 0b1 <sup>b</sup> | Guest OS TLB Invalidate by IPA Leaf Entry only                                        |

a. All DVMv7 transactions must use 0b00.  
b. IPA is the Intermediate Physical Address. The IPA is sent using the same format as the Virtual Address (VA).

#### TLB Invalidate, Hypervisor, Secure operations

Table 8-17 shows the fixed value fields for TLB Invalidate Hypervisor, Secure operations.

Table 8-17 TLB Invalidate, Hypervisor, Secure operations fixed values

| Field           | Value | Status     |
|-----------------|-------|------------|
| DVMOp           | 0b000 | TLBI       |
| Exception Level | 0b11  | Hypervisor |
| Security        | 0b10  | Secure     |

Table 8-18 shows the values for TLB Invalidate, Hypervisor with Secure operations.

Table 8-18 TLB Invalidate, Hypervisor, Secure operations

| Addr | ASID<br>valid | VMID<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid | Operation                                        |
|------|---------------|---------------|----------------------------|------------------------|-------------|--------------------------------------------------|
| 0b0  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b0         | Secure Hypervisor, TLBI all                      |
| 0b1  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b1         | Secure Hypervisor, TLBI by ASID and VA           |
| 0b1  | 0b0           | 0b0           | 0b1                        | 0b00                   | 0b1         | Secure Hypervisor, TLBI by ASID and VA Leaf only |
| 0b0  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b1         | Secure Hypervisor, TLBI by VA                    |
| 0b0  | 0b0           | 0b0           | 0b1                        | 0b00                   | 0b1         | Secure Hypervisor, TLBI by VA, Leaf only         |
| 0b1  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b0         | Secure Hypervisor, TLBI by ASID                  |

#### TLB Invalidate, Hypervisor, Non-secure operations

Table 8-19 shows the fixed value fields for TLB Invalidate, Hypervisor, Non-secure operations.

Table 8-19 TLB Invalidate, Hypervisor, Non-secure operations fixed values

| Field           | Value | Status     |
|-----------------|-------|------------|
| DVMOp           | 0b000 | TLBI       |
| Exception Level | 0b11  | Hypervisor |
| Security        | 0b11  | Non-secure |

Table 8-20 on page 8-326 shows the values for TLB Invalidate, Hypervisor, Non-secure operations.

Table 8-20 TLB Invalidate Hypervisor, Non-secure operations

| Addr | ASID<br>valid | VMID<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid | Operation                                                |
|------|---------------|---------------|----------------------------|------------------------|-------------|----------------------------------------------------------|
| 0b0  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b0         | Hypervisor TLB Invalidate all                            |
| 0b0  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b1         | Hypervisor TLB Invalidate by VA                          |
| 0b0  | 0b0           | 0b1           | 0b1                        | 0b00                   | 0b1         | Hypervisor TLB Invalidate by VA Leaf Entry only          |
| 0b1  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b0         | Hypervisor TLB Invalidate by ASID                        |
| 0b1  | 0b0           | 0b0           | 0b0                        | 0b00                   | 0b1         | Hypervisor TLB Invalidate by ASID and VA                 |
| 0b1  | 0b0           | 0b1           | 0b1                        | 0b00                   | 0b1         | Hypervisor TLB Invalidate by ASID and VA Leaf Entry only |

#### TLB Invalidate EL3, Secure operations

Table 8-21 shows the fixed value fields for TLB Invalidate, EL3, Secure operations.

Table 8-21 TLB Invalidate, EL3, Secure operations fixed values

| Field           | Value | Status |
|-----------------|-------|--------|
| DVMOp           | 0b000 | TLBI   |
| Exception Level | 0b01  | EL3    |
| Security        | 0b10  | Secure |

Table 8-22 shows values for TLB Invalidate EL3 with Secure operations.

Table 8-22 TLB Invalidate EL3, Secure operations

| Addr          |               |                            |                        |             |                                          | Operation |
|---------------|---------------|----------------------------|------------------------|-------------|------------------------------------------|-----------|
| ASID<br>valid | VMID<br>valid | Leaf Entry<br>Invalidation | Staged<br>Invalidation | VA<br>valid |                                          |           |
| 0b0           | 0b0           | 0b0                        | 0b00                   | 0b1         | EL3 TLB Invalidate by VA                 |           |
| 0b0           | 0b0           | 0b1                        | 0b00                   | 0b1         | EL3 TLB Invalidate by VA Leaf Entry only |           |
| 0b0           | 0b0           | 0b0                        | 0b00                   | 0b0         | EL3 TLB Invalidate All                   |           |

### 8.3.2 Branch Predictor Invalidate

This section shows the Branch Predictor Invalidate operations.

Table 8-23 shows the fixed value fields in the Branch Predictor Invalidate operation.

Table 8-23 Branch Predictor Invalidate operation fixed values

| Field                   | Value  | Status                                 |
|-------------------------|--------|----------------------------------------|
| Part Num                | -      | See Table 8-8 on page 8-317            |
| VMID Valid              | 0b0    | VMID field not valid                   |
| ASID Valid              | 0b0    | ASID field not valid                   |
| Security                | 0b00   | Applies to both secure and Non-secure  |
| Exception Level         | 0b00   | Applies to all Guest OS and Hypervisor |
| VMID<br>VMIDEExt        | 0xXX   | VMID not specified                     |
| ASID                    | 0xXXXX | ASID not specified                     |
| Staged Invalidation     | 0b00   | Reserved, set to Zero                  |
| Leaf Entry Invalidation | 0b0    | Reserved, set to Zero                  |

###### — Note —

The use of Branch Predictor Invalidate with a 16-bit ASID is not supported.

Table 8-24 shows the operations supported by Branch Predictor Invalidate.

Table 8-24 Branch Predictor Invalidate operations

| Addr | DVMOp type                        | VA valid | Operation |
|------|-----------------------------------|----------|-----------|
|      |                                   |          | 0b001     |
| 0b1  | Branch Predictor Invalidate by VA |          |           |

### 8.3.3 Instruction cache invalidations

Instruction caches can use either a PA or a VA to tag the data they contain. A system might contain a mixture of both forms of cache.

The DVM protocol includes instruction cache invalidation operations that use physical addresses and operations that use virtual addresses. A component that receives DVM messages must support both forms of message, independent of the style of instruction cache implemented. It might be necessary to over-invalidate in the case where a message is received in a format that is not native to the cache type.

#### Physical Instruction Cache Invalidate

This section lists the *Physical Instruction Cache Invalidate* (PICI) operations that the DVM message supports. This message type is also used for Instruction Caches which are *Virtually Indexed Physically Tagged* (VIPT).

Table 8-25 shows the fixed value fields in the PICI operations.

Table 8-25 Physical Instruction Cache Invalidate operation fixed values

| Field                   | Value | Status                                 |
|-------------------------|-------|----------------------------------------|
| Part Num                | -     | See Table 8-8 on page 8-317            |
| Exception Level         | 0b00  | Applies to all Guest OS and Hypervisor |
| Staged Invalidation     | 0b00  | Reserved, set to zero                  |
| Leaf Entry Invalidation | 0b0   | Reserved, set to zero                  |

Table 8-26 shows the operations supported by PICI.

###### Note

When Virtual IndexVI is 0b11, then VA[19:12] and VA[27:20], at Addr[29:22] and Addr[21:14] respectively, are used as part of the Physical AddressPA. Addr[37:30] are not used, and can take any values.

Table 8-26 Physical Instruction Cache Invalidate operations

| DVMOp type | Security | Virtual Index | VA  | Operation                                                     |
|------------|----------|---------------|-----|---------------------------------------------------------------|
| 0b010      | 0b10     | 0b00          | 0b0 | Secure and Non-secure Physical Address Cache Invalidate all   |
|            |          | 0b00          | 0b1 | Secure Physical Address Cache Invalidate by PA without VI     |
|            |          | 0b11          | 0b1 | Secure Physical Address Cache Invalidate by PA with VI        |
| 0b11       | 0b11     | 0b00          | 0b0 | Non-secure Physical Address Cache Invalidate all              |
|            |          | 0b00          | 0b1 | Non-secure Physical Address Cache Invalidate by PA without VI |
|            |          | 0b11          | 0b1 | Non-secure Physical Address Cache Invalidate by PA with VI    |

#### Virtual Instruction Cache Invalidate

This section shows the *Virtual Instruction Cache Invalidate (VICI)* operations.

Table 8-27 shows the fixed value fields in the VICI operation.

Table 8-27 Virtual Instruction Cache Invalidate operation fixed values

| Field                      | Value | Status                      |
|----------------------------|-------|-----------------------------|
| Part Num                   | -     | See Table 8-8 on page 8-317 |
| Staged<br>Invalidation     | 0b00  | Reserved, set to zero       |
| Leaf Entry<br>Invalidation | 0b0   | Reserved, set to zero       |

Table 8-28 shows the operations supported by VICI.

Table 8-28 Virtual Instruction Cache Invalidate operations

| Addr  | DVMOp type | Exception Level | Security | ASID valid | VMID valid | VA valid                                                                       | Operation                                                                                 |
|-------|------------|-----------------|----------|------------|------------|--------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| 0b011 |            | 0b00            | 0b00     | 0b0        | 0b0        | 0b0                                                                            | Invalidate all. Applies to Secure and Non-secure. Applies to Hypervisor and all Guest OS. |
|       |            | 0b11            | 0b0      | 0b0        | 0b0        | Invalidate all. Applies to Non-secure. Applies to Hypervisor and all Guest OS. |                                                                                           |
| 0b10  |            | 0b10            | 0b0      | 0b1        | 0b0        | 0b1                                                                            | Secure Invalidate by ASID and VA.                                                         |
|       |            |                 | 0b0      | 0b1        | 0b0        | 0b0                                                                            | Secure Invalidate all per VMID.                                                           |
|       |            |                 | 0b1      | 0b1        | 0b1        | 0b1                                                                            | Secure Invalidate by ASID and VA per VMID.                                                |
|       |            |                 | 0b0      | 0b1        | 0b0        | 0b0                                                                            | Non-secure Guest OS, Invalidate all per VMID.                                             |
| 0b11  |            | 0b11            | 0b0      | 0b1        | 0b1        | 0b1                                                                            | Non-secure Guest OS, Invalidate by ASID and VA per VMID.                                  |
|       |            |                 | 0b1      | 0b0        | 0b0        | 0b1                                                                            | Hypervisor, Invalidate by ASID and VA.                                                    |
| 0b11  |            | 0b11            | 0b0      | 0b0        | 0b0        | 0b1                                                                            | Hypervisor, Invalidate by ASID and VA.                                                    |
|       |            |                 | 0b1      | 0b0        | 0b0        | 0b1                                                                            | Hypervisor, Invalidate by ASID and VA.                                                    |

### 8.3.4 Synchronization

This section shows the DVMSync Synchronization operation.

Table 8-29 shows the fixed value fields in the Sync operation.

Table 8-29 Sync operation fixed values

| Field                   | Value  | Status                                 |
|-------------------------|--------|----------------------------------------|
| Part Num                | -      | See Table 8-8 on page 8-317            |
| VA Valid                | 0b0    | Not applicable                         |
| VMID Valid              | 0b0    | Ignore VMID                            |
| ASID Valid              | 0b0    | Ignore ASID                            |
| Security                | 0b00   | Applies to both Secure and Non-secure  |
| Exception Level         | 0b00   | Applies to all Guest OS and Hypervisor |
| DVMOp type              | 0b100  | Synchronization message                |
| VMID                    | 0x0X   | VMID not specified                     |
| VMIDExt                 |        |                                        |
| ASID                    | 0x00XX | ASID not specified                     |
| Staged Invalidation     | 0b00   | Set to zero                            |
| Leaf Entry Invalidation | 0b0    | Set to zero                            |



# Chapter 9Error Handling

This chapter describes the error handling requirements. It contains the following sections:

- *Error types on page 9-334*
- *Error response fields on page 9-335*
- *Errors and transaction structure on page 9-336*
- *Error response use by transaction type on page 9-337*
- *Poison on page 9-347*
- *Data Check on page 9-348*
- *Use of interface parity on page 9-349*
- *Interoperability of Poison and DataCheck on page 9-352*
- *Hardware and software error categories on page 9-353*

## 9.1 Error types

This specification supports two types of error reporting at sub packet level, and two types of error reporting at packet level.

The packet level error reporting types are:

### Data Error, DERR

Used when the correct address location has been accessed, but an error is detected within the data. Typically, this is used when data corruption has been detected by ECC or a parity check.

Data Error reporting is supported by the RespErr, Poison, and DataCheck fields in the DAT packet.

When processing of a request received by Home that is required to be propagated to the Subordinate results in a DERR, the Home must not stop propagating the request to the Subordinate.

###### Note

An error in data being evicted from Home, or received in a Snoop response as a result of the request, are examples of the request resulting in a DERR.

### Non-data Error, NDERR

Used when an error is detected that is not related to data corruption. This specification does not define all cases when this error type is reported. Typically, this error type is reported for:

- An attempt to access a location that does not exist.
- An illegal access, such as a write to a read-only location.
- An attempt to use a transaction type that is not supported.

Non-data Error reporting is supported by the RespErr field in the RSP and DAT packets.

When processing of a request received by Home results in an NDERR then it is permitted, but not required, to propagate the request to the Subordinate. The Home is required to pass-back the NDERR in the response to the Requester.

## 9.2 Error response fields

The RespErr field is used to indicate error conditions. The RespErr field is included in both response and data packets.

Table 9-1 shows the encoding of the RespErr field. See *Responses to exclusive requests* on page 6-286 for more details on the Exclusive Okay response.

Table 9-1 Error response field encodings

| RespErr[1:0] | Name  | Description                                                                                                         |
|--------------|-------|---------------------------------------------------------------------------------------------------------------------|
| 0b00         | OK    | Okay. Indicates that a Non-exclusive access has been successful. Also used to indicate an Exclusive access failure. |
| 0b01         | EXOK  | Exclusive Okay. Indicates that either the read or write portion of an Exclusive access has been successful.         |
| 0b10         | DERR  | Data Error.                                                                                                         |
| 0b11         | NDERR | Non-data Error.                                                                                                     |

A single transaction is not permitted to mix OK and EXOK responses.

A transaction with a Data response is required to include NDERR either in none or in all Data packets.

The mixing of OK and DERR responses within a single transaction is permitted.

The mixing of EXOK and DERR responses within a single transaction is permitted.

The mixing of OK and NDERR responses within a single transaction is permitted, which can occur only in transactions with both Data and Non-data responses.

The mixing of EXOK and NDERR is not permitted.

## 9.3 Errors and transaction structure

All transactions must complete in a protocol-compliant manner, even if they include an error response.

Error handling for a transaction that utilizes DMT is the same as the error handling for the same request without DMT.

Because there is no mechanism to propagate errors on requests or snoops, a request must not use DMT or DCT if an error is detected at the interconnect.

If the transaction contains data packets then the source of the data packets is required to send the correct number of packets, but the data values are not required to be valid.

The Resp field gives the cache states associated with a transaction and can be influenced by an error condition. See [Response types on page 4-197](#) for more details on the legal Resp field values. If a response to a transaction does not have a legal cache state, then the RespErr field must indicate a Non-data Error for all data packets.

The Resp field in a response must have the same value for every packet of a Data message regardless of whether or not there is an error condition.

A Requester that receives a response with a Non-data Error for a Snoopable request must:

- For an Allocating transaction:
  - When the start state is I, the Requester must not allocate the received data.
  - If the request was sent from a Non-Invalid state, the Requester must leave the cached copy unchanged.In both cases, the cache state must not be changed.
  - The Allocating transactions are:
    - ReadClean
    - ReadNotSharedDirty
    - ReadShared
    - ReadUnique
    - ReadPreferUnique
    - MakeReadUnique
    - CleanUnique
    - MakeUnique
- For a deallocating transaction:
  - The Requester must continue as normal, in a protocol-compliant manner.
  - The deallocating transactions are:
    - WriteBack
    - WriteEvictFull
    - Evict
    - WriteEvictOrEvict
- For Other transactions that do not change allocation:
  - The Requester must not upgrade the cache state but is permitted to downgrade it.

The cache state in a SnpResp message with a Non-data Error must be I. The responder must invalidate local cached copies of the cache line. In addition, when the response to a Forwarding snoop results in a Non-data Error, the Snoopee must not forward data to the Requester. As a consequence, if the CompData message has already been sent to the Requester then the Snoop response to the Home must not include the Non-data Error.

## 9.4 Error response use by transaction type

This section defines the permitted use of the error fields for each transaction type.

The tables that follow show the Data and Response packets associated with the following transaction types:

- *Read transactions*
- *Dataless transactions* on page 9-339
- *Write transactions* on page 9-340
- *Atomic transactions* on page 9-342
- *Other transactions* on page 9-344
- *Cache Stashing transactions* on page 9-344
- *Snoop transactions* on page 9-345

The following keys are used by the tables:

**OK** The RespErr field must contain the OK RespErr value of 0b00.  
**Y** This value of RespErr is permitted.  
**N** This value of RespErr is not permitted.  
- Data or Response packet is not used for this transaction type.

### 9.4.1 Read transactions

Read transactions can contain multiple CompData data packets.

Read data which is known to be corrupt must have an appropriate Error indication where the error can be Poison, DERR, or NDERR.

When RespSepData includes a Non-data Error, all corresponding DataSepResp packets must be marked with Non-data Error.

In a Data response to a Read request, a Non-data Error response is only permitted either in none or in all data response packets.

###### — **Note** —

Prior to CHI Issue E, a Read transaction was permitted to include a Non-data Error response in some of the data responses.

Table 9-2 shows the legal RespErr field values associated with Data and Response packets for Read transactions.

Table 9-2 Legal RespErr field values associated with Data and Response packets for Read transactions

| Read transaction | Associated Data and Response packets |          |         |       |   |    |
|------------------|--------------------------------------|----------|---------|-------|---|----|
|                  | Read Receipt                         | CompData | CompAck |       |   |    |
|                  | OK                                   | EXOK     | DERR    | NDERR |   |    |
| ReadNoSnp        | OK                                   | Y        | Y       | Y     | Y | OK |
| ReadNoSnpSep     | OK                                   | -        | -       | -     | - | -  |

Table 9-2 Legal RespErr field values associated with Data and Response packets for Read transactions (continued)

| Read transaction              | Associated Data and Response packets |          |      |      |       | CompAck |
|-------------------------------|--------------------------------------|----------|------|------|-------|---------|
|                               | Read Receipt                         | CompData |      |      |       |         |
|                               |                                      | OK       | EXOK | DERR | NDERR |         |
| ReadOnce                      | OK                                   | Y        | N    | Y    | Y     | OK      |
| ReadOnceCleanInvalid          |                                      |          |      |      |       |         |
| ReadOnceMakeInvalid           |                                      |          |      |      |       |         |
| ReadClean                     | -                                    | Y        | Y    | Y    | Y     | OK      |
| ReadNotSharedDirty            |                                      |          |      |      |       |         |
| ReadShared                    |                                      |          |      |      |       |         |
| ReadUnique                    | -                                    | Y        | N    | Y    | Y     | OK      |
| ReadPreferUnique <sup>a</sup> |                                      |          |      |      |       |         |
| MakeReadUnique <sup>b</sup>   |                                      |          |      |      |       |         |

a. EXOK response is not permitted even when Excl bit in the request is set to 1. A response of OK in the returned data response is not to be taken as a failure of ReadPreferUnique. Failure of the exclusive sequence is only determined from the corresponding MakeReadUnique (Excl) or CleanUnique (Excl) transaction completion.

b. Applicable only when data is returned to the Requester. See Table 9-4 on page 9-339 for permitted errors when data is not returned to the Requester.

Table 9-3 shows the legal RespErr field values associated with Data-only and Non-data packets for Read transactions.

Table 9-3 Legal RespErr field values associated with Data-only and Non-data packets for Read transactions

| Read transaction              | Associated Data-only and Non-data packets |      |      |       |             |      |      |       |
|-------------------------------|-------------------------------------------|------|------|-------|-------------|------|------|-------|
|                               | DataSepResp                               |      |      |       | RespSepData |      |      |       |
|                               | OK                                        | EXOK | DERR | NDERR | OK          | EXOK | DERR | NDERR |
| ReadNoSnp                     | Y                                         | N    | Y    | Y     | Y           | N    | N    | Y     |
| ReadNoSnpSep                  | Y                                         | N    | Y    | Y     | -           | -    | -    | -     |
| ReadOnce                      | Y                                         | N    | Y    | Y     | Y           | N    | N    | Y     |
| ReadOnceCleanInvalid          |                                           |      |      |       |             |      |      |       |
| ReadOnceMakeInvalid           |                                           |      |      |       |             |      |      |       |
| ReadClean                     | Y                                         | N    | Y    | Y     | Y           | N    | N    | Y     |
| ReadNotSharedDirty            |                                           |      |      |       |             |      |      |       |
| ReadShared                    |                                           |      |      |       |             |      |      |       |
| ReadUnique                    | Y                                         | N    | Y    | Y     | Y           | N    | N    | Y     |
| ReadPreferUnique <sup>a</sup> |                                           |      |      |       |             |      |      |       |
| MakeReadUnique <sup>b</sup>   |                                           |      |      |       |             |      |      |       |

a. A response of OK in the returned data response is not to be taken as a failure of ReadPreferUnique. Failure of the exclusive sequence is only determined from the corresponding MakeReadUnique (Excl) or CleanUnique (Excl) transaction completion.

b. Applicable only when data is returned to the Requester. See Table 9-4 on page 9-339 for permitted errors when data is not returned to the Requester.

### 9.4.2 Dataless transactions

A Data Error can be reported for a Dataless transaction when the processing of the transaction by another component encounters a data corruption error. This data error can be indicated back to the originating component, even though a transfer of data does not occur.

Table 9-4 shows the Dataless transaction packets legal RespErr field values.

Table 9-4 Dataless transaction packets legal RespErr field values

| Dataless transaction        | Associated Response packets |      |      |         |    |      |             |       |    |         |      |      |       |
|-----------------------------|-----------------------------|------|------|---------|----|------|-------------|-------|----|---------|------|------|-------|
|                             | Comp                        |      |      | Persist |    |      | CompPersist |       |    | CompAck |      |      |       |
|                             | OK                          | EXOK | DERR | NDERR   | OK | EXOK | DERR        | NDERR | OK |         | EXOK | DERR | NDERR |
| CleanUnique                 | Y                           | Y    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | OK    |
| MakeReadUnique <sup>a</sup> | Y                           | N    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | OK    |
| MakeUnique                  | Y                           | N    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | OK    |
| CleanShared                 | Y                           | N    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | -     |
| CleanSharedPersist          | Y                           | N    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | -     |
| CleanSharedPersistSep       | Y                           | N    | Y    | Y       | Y  | N    | Y           | Y     | Y  | N       | Y    | Y    | -     |
| CleanInvalid                | Y                           | N    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | -     |
| MakeInvalid                 | Y                           | N    | Y    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | -     |
| Evict                       | Y                           | N    | N    | Y       | -  | -    | -           | -     | -  | -       | -    | -    | -     |

a. Applicable only when data is not returned to the Requester. See Table 9-2 on page 9-337 and Table 9-3 on page 9-338 for permitted errors when data is returned to the Requester.

Table 9-5 shows the permitted RespErr values in responses to StashOnce transactions.

Table 9-5 Dataless Stash transaction packets legal RespErr field values

| Dataless Stash transaction | Associated Response packets |      |      |           |    |      |               |       |    |      |      |       |
|----------------------------|-----------------------------|------|------|-----------|----|------|---------------|-------|----|------|------|-------|
|                            | Comp                        |      |      | StashDone |    |      | CompStashDone |       |    |      |      |       |
|                            | OK                          | EXOK | DERR | NDERR     | OK | EXOK | DERR          | NDERR | OK | EXOK | DERR | NDERR |
| StashOnceUnique            | Y                           | N    | Y    | Y         | -  | -    | -             | -     | -  | -    | -    | -     |
| StashOnceShared            | Y                           | N    | Y    | Y         | -  | -    | -             | -     | -  | -    | -    | -     |
| StashOnceSepUnique         | Y                           | N    | Y    | Y         | Y  | N    | Y             | Y     | Y  | N    | Y    | Y     |
| StashOnceSepShared         | Y                           | N    | Y    | Y         | Y  | N    | Y             | Y     | Y  | N    | Y    | Y     |

### **9.4.3 Write transactions**

A Write transaction can include either a Non-data Error or a Data Error. Errors can be signaled in both directions, from the Requester to the Completer, and from the Completer back to the Requester.

Write data which is known to be corrupt must have an appropriate Error indication where the error can be Poison or DERR.

For a Write transaction an error can be signaled from the Completer back to the Requester using either the combined CompDBIDResp or using the Comp response. It is permitted for the Completer to signal an error even before it has observed the WriteData for the transaction and this can occur when the processing of the transaction, such as the cache lookup, encounters a data corruption error.

[Table 9-6](#page-339-0) shows the Write transaction response packets legal RespErr field values.

**Table 9-6 Write transaction Response packets legal RespErr field values**

| Write                                     | Associated Response packets |      |      |      |       |    |              |      |       |         |
|-------------------------------------------|-----------------------------|------|------|------|-------|----|--------------|------|-------|---------|
| transaction                               |                             | Comp |      |      |       |    | CompDBIDResp |      |       |         |
|                                           | DBIDResp                   | OK   | EXOK | DERR | NDERR | OK | EXOK         | DERR | NDERR | CompAck |
| WriteNoSnp                                | OK                          | Y    | Y    | Y    | Y     | Y  | Y            | Y    | Y     | OK      |
| WriteUnique                               | OK                          | Y    | N    | Y    | Y     | Y  | N            | Y    | Y     | OK      |
| WriteNoSnpZero<br>WriteUniqueZero         | OK                          | Y    | N    | Y    | Y     | Y  | N            | Y    | Y     | -       |
| WriteBack<br>WriteClean<br>WriteEvictFull | -                           | -    | -    | -    | -     | Y  | N            | Y    | Y     | -       |
| WriteEvictOrEvict                         | -                           | Y    | N    | N    | Y     | Y  | N            | Y    | Y     | OK      |

A Requester that detects an error in the write data to be sent can include an Error indication with the write data packet. This indicates that the data value is known to be corrupt.

[Table 9-7](#page-339-1) shows the Write transaction Data packets legal RespErr field values.

**Table 9-7 Write transaction Data packets legal RespErr field values**

|                                                                | Associated Data packets |           |      |       |    |                 |      |       |    |                  |      |       |  |  |  |
|----------------------------------------------------------------|-------------------------|-----------|------|-------|----|-----------------|------|-------|----|------------------|------|-------|--|--|--|
| Write<br>transaction                                           |                         | WriteData |      |       |    | WriteDataCancel |      |       |    | NCBWrDataCompAck |      |       |  |  |  |
|                                                                | OK                      | EXOK      | DERR | NDERR | OK | EXOK            | DERR | NDERR | OK | EXOK             | DERR | NDERR |  |  |  |
| WriteNoSnp                                                     | Y                       | N         | Y    | N     | Y  | N               | Y    | N     | Y  | N                | Y    | N     |  |  |  |
| WriteUnique                                                    | Y                       | N         | Y    | N     | Y  | N               | Y    | N     | Y  | N                | Y    | N     |  |  |  |
| WriteBack<br>WriteClean<br>WriteEvictFull<br>WriteEvictOrEvict | Y                       | N         | Y    | N     | -  | -               | -    | -     | -  | -                | -    | -     |  |  |  |

Table 9-8 shows the Write transaction TagMatch packet legal RespErr field values when MTE is supported on the Requester's interface.

Table 9-8 Write transaction TagMatch packet legal RespErr field values

| Write transaction | Associated response packets |      |      |       |
|-------------------|-----------------------------|------|------|-------|
|                   | TagMatch                    |      |      |       |
|                   | OK                          | EXOK | DERR | NDERR |
| WriteNoSnp        | Y                           | N    | Y    | Y     |
| WriteUnique       |                             |      |      |       |
| WriteBack         | -                           | -    | -    | -     |
| WriteClean        |                             |      |      |       |
| WriteEvictFull    |                             |      |      |       |
| WriteEvictOrEvict |                             |      |      |       |

For permitted RespErr field values in a Combined Write transaction response:

- See Table 9-6 on page 9-340 for the corresponding responses for the Write request.
- See Table 9-4 on page 9-339 for the corresponding responses for the CMO request.  
  The permitted error responses in the CompCMO are the same as those in the Comp in Table 9-4 on page 9-339.

## **9.4.4 Atomic transactions**

It is permitted for a Completer to give a Comp response before it has received all the write data associated with a transaction and has performed the required operation. This behavior is not compatible with a component that wants to signal a data error associated with the write data, and such components must use a delayed form of Comp or CompData response.

In Atomic transactions, Read data or Write data which is known to be corrupt must have an appropriate Error indication. When the error is on Read data, it can be Poison, DERR, or NDERR. When the error is on Write data, it can be Poison or DERR.

A Data Error or Non-data Error can be signaled at the following points within a transaction:

- With the CompDBIDResp response.
- For an AtomicStore transaction, with the Comp response.
- For an AtomicLoad, AtomicSwap, and AtomicCompare transaction, with the CompData response.

![](a8567e04ebef29a67f966fb018639410_img.jpg)

If a read data at Home due to a non-store Atomic request results in a Data Error or Non-data Error, then such an error can be propagated onto the DBIDResp or CompDBIDResp response for that request.

For Atomic transactions that are not able to complete, a Non-data Error must be used. The transaction structure, including all write data transfers, read data transfers, and other responses must still take place.

There is no need to specify an error associated with the execution of an atomic operation, such as overflow. All atomic operations are fully specified for all input combinations.

A transaction includes both outbound and inbound data, but only has a single Error field. For Atomic transactions it is permitted for the Error field to indicate an error on either write data or read data. There is no mechanism supported within the transaction to differentiate between the potential different causes of an error. A fault log, or a similar structure, might be able to provide such information, but this is not a requirement of this specification.

The permitted RespErr values in Atomic transactions are an amalgamation of those permitted in Read and Write transactions.

A Data Error can vary between data packets.

[Table 9-9](#page-341-0) shows the Atomic transaction Response packets legal RespErr field values

**Table 9-9 Atomic transaction Response packets legal RespErr field values**

|                                           | Associated Response packets |      |      |      |       |    |              |      |       |
|-------------------------------------------|-----------------------------|------|------|------|-------|----|--------------|------|-------|
| Atomic transaction                        | DBIDResp                    | Comp |      |      |       |    | CompDBIDResp |      |       |
|                                           |                             | OK   | EXOK | DERR | NDERR | OK | EXOK         | DERR | NDERR |
| AtomicStore                               | OK                          | Y    | N    | Y    | Y     | Y  | N            | Y    | Y     |
| AtomicLoad<br>AtomicSwap<br>AtomicCompare | OK                          | Y    | N    | Y    | Y     | -  | -            | -    | -     |

Table 9-10 shows the Atomic transaction Data packets legal RespErr field values.

Table 9-10 Atomic transaction Data packets legal RespErr field values

| Atomic transaction | Associated response packets |      |      |       |          |      |      |       |
|--------------------|-----------------------------|------|------|-------|----------|------|------|-------|
|                    | WriteData                   |      |      |       | CompData |      |      |       |
|                    | OK                          | EXOK | DERR | NDERR | OK       | EXOK | DERR | NDERR |
| AtomicStore        | Y                           | N    | Y    | N     | -        | -    | -    | -     |
| AtomicLoad         | Y                           | N    | Y    | N     | Y        | N    | Y    | Y     |
| AtomicSwap         |                             |      |      |       |          |      |      |       |
| AtomicCompare      |                             |      |      |       |          |      |      |       |

Table 9-11 shows the Atomic transaction TagMatch packet legal RespErr field values when MTE is supported.

Table 9-11 Atomic transaction TagMatch packet legal RespErr field values

| Atomic transaction | Associated response packets |      |      |       |
|--------------------|-----------------------------|------|------|-------|
|                    | TagMatch                    |      |      |       |
|                    | OK                          | EXOK | DERR | NDERR |
| AtomicStore        | Y                           | N    | Y    | Y     |
| AtomicLoad         |                             |      |      |       |
| AtomicSwap         |                             |      |      |       |
| AtomicCompare      |                             |      |      |       |

### 9.4.5 Other transactions

This section describes the error handling requirements for the DVMOp and PrefetchTgt transactions.

#### DVMOp

A DVMOp transaction can include a Non-data Error in the Comp response. The interconnect can consolidate error responses from all the snoop responses for a DVMOp and include a single error response in the final Comp message to the Requester. The DBIDResp packet must only use the OK response. Even though the Sender of a WriteData response might not use DERR, the packet can be marked as DERR if it encounters errors during transmission. See *Interoperability of Poison and DataCheck* on page 9-352.

Table 9-12 shows the DVM transaction Response packets legal RespErr field values.

Table 9-12 DVM transaction Response packets legal RespErr field values

| Associated Response packets |          |      |      |       |    |              |      |       |   |  |
|-----------------------------|----------|------|------|-------|----|--------------|------|-------|---|--|
| DVM transaction             | DBIDResp |      |      |       |    | CompDBIDResp |      |       |   |  |
|                             | OK       | EXOK | DERR | NDERR | OK | EXOK         | DERR | NDERR |   |  |
| DVMOp                       | OK       | Y    | N    | Y     | Y  | Y            | N    | Y     | Y |  |

Table 9-13 shows the DVM transaction Data packets legal RespErr field values.

Table 9-13 DVM transaction Data packets legal RespErr field values

| Associated Data packets |           |      |      |       |
|-------------------------|-----------|------|------|-------|
| DVM transaction         | NCBWrData |      |      |       |
|                         | OK        | EXOK | DERR | NDERR |
| DVMOp                   | Y         | N    | Y    | N     |

#### PrefetchTgt

A PrefetchTgt transaction request to a non-supporting address must be discarded.

— Note —

A component is permitted to record and report such an error.

### 9.4.6 Cache Stashing transactions

If the specified Stash target does not support receiving Stash snoop, then Home must disregard the Stash hint and complete the transaction without Stashing. Examples of such Stash targets are RN-I, RN-D, legacy RN-F, or a Non-request node. In these circumstances, Home must not signal an error to the Requester. Such a wrongly specified Stash target can be attributed to a software based error.

If the Home does not support Stash requests, it must complete the transaction in a protocol-compliant manner without signaling an error.

### 9.4.7 Snoop transactions

A Snoop transaction response that includes data can indicate a Data Error. A Snoop transaction response that includes data can mix OK and DERR responses for different packets within the transaction.

Data, in response to a Snoop request that is known to be corrupt, must have an appropriate Error indication where the error can be Poison or DERR.

A Snoop transaction response that does not include data can indicate an NDERR.

A Snoopee that responds with an NDERR:

- Must not include data with the response.
- Must invalidate any locally cached copies.
- Must set the cache state in the response to Invalid.
- Must not forward a CompData response to the Requester in response to a Forwarding snoop. As a consequence, if the CompData message is already sent to the Requester then the Snoop response to the Home must not include a Non-data Error.

Table 9-14 on page 9-345 shows the Snoop request Response packets legal RespErr field values.

Table 9-14 Snoop request Response packets legal RespErr field values

| Snoop Transaction   | Associated Data and Response packets |      |      |       |             |      |      |       |
|---------------------|--------------------------------------|------|------|-------|-------------|------|------|-------|
|                     | SnpResp                              |      |      |       | SnpRespData |      |      |       |
|                     | OK                                   | EXOK | DERR | NDERR | OK          | EXOK | DERR | NDERR |
| SnpOnce             | Y                                    | N    | N    | Y     | Y           | N    | Y    | N     |
| SnpClean            |                                      |      |      |       |             |      |      |       |
| SnpNotSharedDirty   |                                      |      |      |       |             |      |      |       |
| SnpShared           |                                      |      |      |       |             |      |      |       |
| SnpUnique           |                                      |      |      |       |             |      |      |       |
| SnpPreferUnique     |                                      |      |      |       |             |      |      |       |
| SnpUniqueStash      |                                      |      |      |       |             |      |      |       |
| SnpCleanShared      |                                      |      |      |       |             |      |      |       |
| SnpCleanInvalid     |                                      |      |      |       |             |      |      |       |
| SnpStashUnique      | Y                                    | N    | N    | Y     | -           | -    | -    | -     |
| SnpStashShared      |                                      |      |      |       |             |      |      |       |
| SnpMakeInvalid      |                                      |      |      |       |             |      |      |       |
| SnpMakeInvalidStash |                                      |      |      |       |             |      |      |       |
| SnpQuery            |                                      |      |      |       |             |      |      |       |
| SnpDVMOp            |                                      |      |      |       |             |      |      |       |

It is recommended, but not required, that a DERR on a Clean cache line is dropped, and the error is not propagated to the memory, nor included in the response to the Requester.

A DERR on a Dirty cache line must be propagated to the memory, and in the response to the Requester.

A DERR in response to the Data Pull request is not expected to be transferred to the Comp response to the Stash request.

For a Forwarding snoop transaction, when simultaneously forwarding data to the Requester and returning Data to Home, it is permitted for only one response to include an indication of a Data Error if the other response does not encounter the error.

Table 9-15 shows the Forwarding Snoop response packets legal RespErr field values.

Table 9-15 Forwarding Snoop response packets legal RespErr field values

| Snoop transaction    | Associated Response packets |      |      |       |             |      |      |       |    |      |      |       |
|----------------------|-----------------------------|------|------|-------|-------------|------|------|-------|----|------|------|-------|
|                      | SnResp                      |      |      |       | SnRespFwded |      |      |       |    |      |      |       |
|                      | OK                          | EXOK | DERR | NDERR | OK          | EXOK | DERR | NDERR | OK | EXOK | DERR | NDERR |
| SnpOnceFwd           | Y                           | N    | N    | Y     | Y           | N    | Y    | N     | Y  | N    | Y    | N     |
| SnpCleanFwd          | Y                           | N    | N    | Y     | Y           | N    | Y    | N     | Y  | N    | Y    | N     |
| SnpNotSharedDirtyFwd | Y                           | N    | N    | Y     | Y           | N    | Y    | N     | Y  | N    | Y    | N     |
| SnpSharedFwd         | Y                           | N    | N    | Y     | Y           | N    | Y    | N     | Y  | N    | Y    | N     |
| SnpUniqueFwd         | Y                           | N    | N    | Y     | Y           | N    | Y    | N     | Y  | N    | Y    | N     |
| SnpPreferUniqueFwd   | Y                           | N    | N    | Y     | Y           | N    | Y    | N     | Y  | N    | Y    | N     |

Table 9-16 on page 9-346 shows the Forwarding Snoop Data response packets legal RespErr field values.

Table 9-16 Forwarding Snoop Data response packets legal RespErr field values

| Snoop transaction    | Associated Data packets |      |      |       |          |      |      |       |
|----------------------|-------------------------|------|------|-------|----------|------|------|-------|
|                      | SnRespData              |      |      |       | CompData |      |      |       |
|                      | OK                      | EXOK | DERR | NDERR | OK       | EXOK | DERR | NDERR |
| SnpOnceFwd           | Y                       | N    | Y    | N     | Y        | N    | Y    | N     |
| SnpCleanFwd          | Y                       | N    | Y    | N     | Y        | N    | Y    | N     |
| SnpNotSharedDirtyFwd | Y                       | N    | Y    | N     | Y        | N    | Y    | N     |
| SnpSharedFwd         | Y                       | N    | Y    | N     | Y        | N    | Y    | N     |
| SnpUniqueFwd         | Y                       | N    | Y    | N     | Y        | N    | Y    | N     |
| SnpPreferUniqueFwd   | Y                       | N    | Y    | N     | Y        | N    | Y    | N     |

## 9.5 Poison

The Poison bit is used to indicate that a set of data bytes have previously been corrupted. Passing the Poison bit alongside the data in the DAT packet permits any future user of the data to be notified that the data is corrupt.

When Poison is supported:

- The DAT packet includes one Poison bit per 64 bits of data.
- Data marked as poisoned:
  - Must not be utilized by any Requester.
  - Is permitted to be stored in caches and memory if marked as poisoned.
- The Poison value, once set, must be propagated along with the data.
- When a Poison error is detected, it is permitted to over poison the data.
- Poison on MTE tags is not supported.

Poison must be accurate if there are any valid bytes in the 64-bit chunk, which is Poison granularity. When all 8 bytes in the 64-bit chunk are invalid, the Poison bit can take any value.

A Data\_Poison property is used to indicate if a component supports Poison.

— **Note** —

Although Poison on tags is not supported, implementations might choose to do one of the following:

- Poison associated with the data results in the tag being poisoned. Depending on the granularity of the poison associated with the tag, it might not be possible to clear the poison using the same techniques that would be used to clear poison associated with data.
- Poison associated with the data does not result in the tag being poisoned. This means that a corrupted tag might subsequently be used in an MTE Match operation, which could incorrectly fail. The rate at which this occurs should be significantly lower than the rate at which data corruption occurs.
- A mixture of approaches can be used, depending on the caching or storage structures that are used.

Other implementations are possible.

## 9.6 Data Check

The DataCheck field is used to detect data errors in the DAT packet.

When Data Check is supported:

- The DAT packet carries eight Data Check bits per 64 bits of data.
- The Data Check bit is a parity bit that generates Odd Byte parity.

The Data\_Check property is used to indicate if Data Check is supported.

— Note —

Interface parity optionally extends the error detection provided on the DAT channel by the DataCheck field.

The protection scheme employed on an interface is defined by the property Check\_Type. See *Interface properties and parameters on page 16-470*.

## 9.7 Use of interface parity

For safety-critical applications it is necessary to detect and possibly correct, transient and functional errors on individual wires within an SoC.

An error in a system component can propagate and cause multiple errors within connected components. *Error Detection and Correction* (EDC) is required to operate end-to-end, covering all logic and wires from source to destination.

One way to implement end-to-end protection, is to employ customized EDC schemes in components and implement a simple error detection scheme between components. Between these components there is no logic and connections are relatively short. This section describes a parity scheme for detecting single-bit errors on the interface between components. Multi-bit errors may be detected if they occur in different parity signal groups. Figure 9-1 shows locations where parity can be used.

![Diagram illustrating the use of parity in AMBA. A Source component connects to an Interconnect via AMBA and Parity generation. The Interconnect contains Parity check and EDC generation logic. The Interconnect connects to a Destination component via AMBA and Parity check. The diagram shows the flow of AMBA and Parity signals, and the internal EDC code path.](c981dcaa19a0460476337c637faa263d_img.jpg)

Diagram illustrating the use of parity in AMBA. A Source component connects to an Interconnect via AMBA and Parity generation. The Interconnect contains Parity check and EDC generation logic. The Interconnect connects to a Destination component via AMBA and Parity check. The diagram shows the flow of AMBA and Parity signals, and the internal EDC code path.

Figure 9-1 Parity use in AMBA

AMBA parity optionally extends the error detection provided on the DAT channel by the DataCheck field to cover the complete flit and control signals on all channels.

The protection scheme employed on an interface is defined by the property Check\_Type. See *Interface properties and parameters* on page 16-470.

### 9.7.1 Byte parity check signals

The following attributes are common to all the check signals added for byte parity interface protection:

- Odd parity is used.  
  Odd parity means that check signals are added to groups of signals on the interface and driven such that there is always an odd number of asserted bits in that group.
- Parity signals covering data and payload are defined such that there are no more than 8 bits per group.  
  This limitation assumes that there is a maximum of 3 logic levels available in the timing budget for generating each parity bit.
- Parity signals covering critical control signals, which are likely to have a smaller timing budget available, are defined with a single odd parity bit.
- The least significant check bit of the check signal covers the least significant byte of payload.
- If the bits in a payload do not fill the most significant byte, the most significant bit of the check signal covers fewer than 8 bits.

- Check signals must be driven correctly in every cycle that the Check Enable term is True, see [Table 9-17 on page 9-351](#).
- Parity signals must be driven appropriate to all the bits in the associated payload, irrespective of whether those bits are applicable.

### 9.7.2 Error detection behavior

This specification is not prescriptive regarding component or system behavior when a parity error is detected. Depending on the system and affected signals, a flipped bit can have a wide range of effects. It might be harmless, cause performance issues, cause data corruption, cause security violations or deadlock. Also, an error on one signal can also cause parity failure on other signals.

When an error is detected, the receiver has options to:

- Terminate or propagate the transaction. It is permitted, but not required, to be protocol-compliant when the transaction is terminated.
- Correct the parity check signal or propagate the error.
- Update its memory or leave untouched. It is permitted, but not required, to mark the location as poisoned.
- Signal an error response through other means, for example, with an interrupt.

### 9.7.3 Interface parity check signals

Table 9-17 shows the parity check signals and their properties on each of the channels.

Table 9-17 Interface parity check signals

| Channel | Check signal       | Signals covered | Check signal width    | Check granularity | Check enable  |
|---------|--------------------|-----------------|-----------------------|-------------------|---------------|
| Common  | SYSCOREQCHK        | SYSCOREQ        | 1                     | 1                 | RESETn == 1   |
|         | SYSCOACKCHK        | SYSCOACK        | 1                     | 1                 | RESETn == 1   |
| Common  | TXSACTIVECHK       | TXSACTIVE       | 1                     | 1                 | RESETn == 1   |
|         | RXSACTIVECHK       | RXSACTIVE       | 1                     | 1                 | RESETn == 1   |
|         |                    |                 |                       |                   |               |
| Common  | TXLINKACTIVEEQCHK  | TXLINKACTIVEEQ  | 1                     | 1                 | RESETn == 1   |
|         | TXLINKACTIVEACKCHK | TXLINKACTIVEACK | 1                     | 1                 | RESETn == 1   |
|         | RXLINKACTIVEEQCHK  | RXLINKACTIVEEQ  | 1                     | 1                 | RESETn == 1   |
|         | RXLINKACTIVEACKCHK | RXLINKACTIVEACK | 1                     | 1                 | RESETn == 1   |
|         |                    |                 |                       |                   |               |
| REQ     | REQFLITPENDCHK     | REQFLITPEND     | 1                     | 1                 | RESETn == 1   |
|         | REQFLITVCHK        | REQFLITV        | 1                     | 1                 | RESETn == 1   |
|         | REQFLITCHK         | REQFLIT         | ce1(8/8) <sup>a</sup> | 1 to 8            | REQFLITV == 1 |
|         | REQLCRDBVCHK       | REQLCRDBV       | 1                     | 1                 | RESETn == 1   |
|         |                    |                 |                       |                   |               |
| RSP     | RSPFLITPENDCHK     | RSPFLITPEND     | 1                     | 1                 | RESETn == 1   |
|         | RSPFLITVCHK        | RSPFLITV        | 1                     | 1                 | RESETn == 1   |
|         | RSPFLITCHK         | RSPFLIT         | ce1(7/8) <sup>b</sup> | 1 to 8            | RSPFLITV == 1 |
|         | RSPLCRDBVCHK       | RSPLCRDBV       | 1                     | 1                 | RESETn == 1   |
|         |                    |                 |                       |                   |               |
| SNP     | SNPFLITPENDCHK     | SNPFLITPEND     | 1                     | 1                 | RESETn == 1   |
|         | SNPFLITVCHK        | SNPFLITV        | 1                     | 1                 | RESETn == 1   |
|         | SNPFLITCHK         | SNPFLIT         | ce1(5/8) <sup>c</sup> | 1 to 8            | SNPFLITV == 1 |
|         | SNPLCRDBVCHK       | SNPLCRDBV       | 1                     | 1                 | RESETn == 1   |
|         |                    |                 |                       |                   |               |
| DAT     | DATFLITPENDCHK     | DATFLITPEND     | 1                     | 1                 | RESETn == 1   |
|         | DATFLITVCHK        | DATFLITV        | 1                     | 1                 | RESETn == 1   |
|         | DATFLITCHK         | DATFLIT         | ce1(0/8) <sup>d</sup> | 1 to 8            | DATFLITV == 1 |
|         | DATLCRDBVCHK       | DATLCRDBV       | 1                     | 1                 | RESETn == 1   |
|         |                    |                 |                       |                   |               |

a. R = Request flit width. See *Request flit* on page 13-410.b. T = Response flit width. See *Response flit* on page 13-412.c. S = Snoop flit width. See *Snoop flit* on page 13-413.d. D = Data flit width. See *Data flit* on page 13-414.

## 9.8 Interoperability of Poison and DataCheck

If the recipient of a Data packet does not support the Poison and DataCheck features then the interconnect must enumerate and convert, as necessary, the Poison and Data Check error responses to a Data Error in the DAT packet.

If support for the Poison and DataCheck features is not similar across an interface, then the following rules apply:

- Poison must be mapped to DataCheck or DERR if Poison is not supported across the interface. At such an interface, Poison is expected but not required to be mapped to DataCheck instead of DERR, if DataCheck is supported.

When converting from Poison to DataCheck, when an 8-byte chunk is marked as Poisoned, all 8 bits of DataCheck corresponding to that chunk must be manipulated to generate a parity error.

- DataCheck must be mapped to Poison or DERR if DataCheck is not supported across the interface. At such an interface, DataCheck is expected but not required to be mapped to Poison instead of DERR, if Poison is supported.

When converting from DataCheck to Poison, if one or more DataCheck bits in a given 8-byte chunk generates a parity error, then the Poison bit corresponding to that chunk must be set.

###### Note

The difference between the handling of Poison and DERR is that a Poison error in a received Data packet is typically deferred by the receiver, but a DERR error is typically not deferred by the receiver.

It is sufficient for the Sender of a Data packet that detects a Poison error to indicate this in the Poison bits. It is not a requirement that the Sender sets the RespErr field value to DERR.

It is sufficient for the Sender of a Data packet that detects a DataCheck error to indicate this in the DataCheck field and is not required to set RespErr field value to DERR.

As Poison and DataCheck fields are independently set, one type of error does not require setting of the other.

In a Data packet that has the RespErr field value set to DERR or NDERR the value of the Poison and DataCheck fields are inapplicable and can take any value.

## 9.9 Hardware and software error categories

This specification defines two error categories: a software-based error and a hardware-based error.

### 9.9.1 Software-based error

A software-based error occurs when multiple accesses to the same location are made with incorrect or mismatched Snoopable or Memory attributes.

A software-based error can cause a loss of coherency and the corruption of data values. It is required that the system does not deadlock for a software-based error, and that transactions always progress through a system in a timely manner.

A software-based error, for an access within one 4KB memory region, must not cause data corruption within a different 4KB memory region.

For locations held in Normal memory, the use of appropriate stores and software cache maintenance can be used to return memory locations to a defined state.

When accessing a peripheral device the correct operation of the peripheral cannot be guaranteed. The only requirement is that the peripheral continues to respond to transactions in a protocol-compliant manner. The sequence of events that might be required to return a peripheral device that has been accessed incorrectly to a known working state is **IMPLEMENTATION DEFINED**.

### 9.9.2 Hardware-based error

A hardware-based error is defined as any protocol error that is not a software-based error.

— **Caution** —

If a hardware-based error occurs, recovery from the error is not guaranteed. The system might crash, lock-up, or suffer some other non-recoverable failure.



# Chapter 10Quality of Service

This chapter describes the mechanisms in the CHI protocol to support *Quality of Service* (QoS). It contains the following sections:

- [Overview on page 10-356](#)
- [QoS priority value on page 10-357](#)
- [Repeating a transaction with higher QoS value on page 10-358](#)

## 10.1 Overview

A system might utilize a QoS scheme to achieve:

- A guaranteed maximum latency for transactions in a particular stream.
- Minimum bandwidth guarantees for a stream of requests.
- Best effort value of bandwidth and latency provided to requests of a particular stream.

The low latency, or guaranteed throughput requirements, required to meet system QoS demands are primarily the responsibility of the transaction end points with support from the intermediate interconnect. The protocol supports this by defining a QoS priority value for packets and controlling request flow using a defined credit mechanism.

## 10.2 QoS priority value

A 4-bit value is used to prioritize the processing of the packets at protocol nodes and within the interconnect. The QoS *Priority Value* (PV) for packets is assigned by the source of the transaction. In typical usage models, this value depends on the source type and the class of traffic, with ascending values of QoS indicating a higher priority level. The source might also dynamically vary this value, depending on some accumulated latency and required throughput metric.

## 10.3 Repeating a transaction with higher QoS value

When a transaction has been sent with a particular QoS value, it is permitted to send the same transaction again with a different QoS value, typically higher. The Completer is required to handle this situation as multiple different requests.

In this instance, if one of the transactions receives a RetryAck response, it is permitted to cancel the transaction and return the credit. See [Credit Return on page 2-146](#).

# Chapter 11System Debug, Trace, and Monitoring

This chapter describes mechanisms that provide extra support for the debugging and tracing of systems, and the monitoring of systems to enhance performance. It contains the following sections:

- *Data Source indication* on page 11-360
- *SLC replacement hint* on page 11-363
- *MPAM* on page 11-365
- *Completer Busy* on page 11-367
- *Trace Tag* on page 11-368

## 11.1 Data Source indication

It is permitted that the Completer of a Read request to specify the source of the data. The source is specified in the DataSource field of the CompData, DataSepResp, SnpRespData, and SnpRespDataPtl responses. DataSource field value is valid even in data responses with error.

The DataSource field can also be used to transport information to bias SLC replacement policy. See [SLC replacement hint on page 11-363](#).

### 11.1.1 DataSource value assignment

The DataSource values must be assigned as follows:

- Fixed values are used for DataSource when data comes from memory and are used to indicate the following:
  - 0b0110 PrefetchTgt memory prefetch was useful.  
    Read data was obtained from the Subordinate with lower latency as the PrefetchTgt request already read or initiated a read of data from memory.
  - 0b0111 PrefetchTgt memory prefetch was not useful.  
    Read request went through a complete memory access and therefore did not have any latency reduction due to the PrefetchTgt request sent earlier.  
    The precise reason for signaling that a prefetch was not useful is IMPLEMENTATION DEFINED.

###### — Note —

There are several reasons why the PrefetchTgt request might not be useful. Examples are that the prefetch was dropped by the Subordinate, the data obtained by the prefetch was replaced in the buffer, or the Read request arrived at the Subordinate before the prefetch.

- For a response from a cache, not memory, the DataSource value is IMPLEMENTATION DEFINED.

It is recommended, but not required, to have settings for DataSource in these cases.

A component is permitted to have software programmability to override the DataSource value to:

- Change the groupings to more suitable specific configuration settings.
- Change the values where the values are not correct.
- A responder is permitted to not support sending a useful DataSource value:
  - The responder, except for a memory SN-F, must return a 0b0000 value.
  - A memory SN-F component must return 0b0111 as a default value.

Such exceptions must be understood by the system.

### 11.1.2 Crossing a chip-to-chip interface

It is the responsibility of the chip interface module, if one exists, to map DataSource values in the incoming data packets to different values to identify that the response came from the remote chip caches.

Example approaches that the chip interface module might take are:

- Group the remote caches into a single encoding, as Figure 11-1 on page 11-361 shows.
- Have a maximum size of an eight entry table, to remap the implementation values of the DataSource field in the incoming data packet to new values.

#### Suggested DataSource values

Figure 11-1 shows an example multichip configuration and the suggested mapping of DataSource values to different components in the system:

- Each chip in the system has two processors per cluster, with a three-level cache hierarchy.
- The cache in the chip-to-chip interface module is identified as part of the interconnect caches.
- All the caches in the remote peer chip are grouped.
- A non-memory component that is not programmed to identify itself as the source of data can return the default value of 0b0000.

Table 11-1 lists the suggested DataSource encodings.

Table 11-1 Suggested DataSource value encodings

| DataSource | Suggested mapping                                                              |
|------------|--------------------------------------------------------------------------------|
| 0b0000     | Non-memory default. Source does not support sending a useful DataSource value. |
| 0b0001     | Peer processor cache within local cluster                                      |
| 0b0010     | Local cluster cache                                                            |
| 0b0011     | Interconnect cache                                                             |
| 0b0100     | Peer cluster caches                                                            |
| 0b0101     | Remote chip caches                                                             |
| 0b1010     | Local cluster cache, unused prefetch <sup>a</sup>                              |
| 0b1011     | Interconnect cache, unused prefetch <sup>a</sup>                               |

a. New in CHI Issue E. See *SLC replacement hint* on page 11-363.

![](423576d71327c6d492c672419aab7cfa_img.jpg)

Diagram illustrating the suggested DataSource values mapping for a multichip configuration.

The diagram shows two chips, Chip and Peer Chip, connected via an Interconnect. Each chip contains Clusters (with Processors and Caches) and caches connected to the Interconnect.

Legend for Cache Colors:

- 0001 (Orange): Local cluster cache
- 0010 (Green): Local cluster cache
- 0011 (Blue): Interconnect cache
- 0100 (Red): Remote chip caches
- 0101 (Yellow): Interconnect cache

Legend for Prefetch Status:

- 0000 (White): Prefetch useful = 110
- 1111 (White): Prefetch not useful = 111

Figure 11-1 Suggested DataSource values

### 11.1.3 Example use cases

Two examples of how DataSource information can be used by a Requester are:

- To determine the usefulness of a PrefetchTgt transaction in initiating a memory controller prefetch.
  - By monitoring the DataSource value in the data returned from the memory SN-F, the Requester can determine the usefulness of sending PrefetchTgt requests and can modulate the rate, and the sending, of PrefetchTgt requests.
- Can be used by performance profiling and debug software to evaluate and optimize the data sharing pattern.

## 11.2 SLC replacement hint

The purpose of this feature is to forward cache replacement hints from the Requesters to the caches in the interconnect, the *System Level Caches* (SLC). Typically, a Request Node has the best knowledge of the utility of a cache line. An SLC that is informed of this knowledge can use it to bias its own replacement algorithms and manage cache line replacement in a more efficient manner.

### 11.2.1 Characteristics

Although the replacement information is most useful in CopyBack requests, this feature is not restricted to CopyBack transactions alone, it is extended to all requests from the Request Node to HN-F, except for the following:

- Atoms
- Stash transactions when StashNIDValid is 1
- PrefetchTgt
- PCrdReturn
- DVMOp

This feature is supported by a 7-bit field called SLCRepHint that is included in the REQ channel. SLCRepHint includes two subfields, a 3-bit Replacement field and a 1-bit UnusedPrefetch field.

Figure 11-2 shows the placement of the SLCRepHint subfields.

![Diagram showing the 7-bit SLCRepHint field structure. Bits 6, 5, and 4 are labeled as Replacement[2:0]. Bits 1, 0, and the remaining 2 bits (bits 3 and 2) are labeled as UnusedPrefetch.](1334f1c81004a34c43406c31092bf6bb_img.jpg)

Diagram showing the 7-bit SLCRepHint field structure. Bits 6, 5, and 4 are labeled as Replacement[2:0]. Bits 1, 0, and the remaining 2 bits (bits 3 and 2) are labeled as UnusedPrefetch.

Figure 11-2 SLCRepHint subfield placement

The SLCRepHint field shares the same REQ packet location as ReturnNID and StashNID. When the node ID widths are greater than 7-bit and the field is used as SLCRepHint then the unused bits of the shared field must be set to zero.

Table 11-2 shows the encoding of the UnusedPrefetch subfield.

Table 11-2 UnusedPrefetch subfield encoding

| UnusedPrefetch | Description                                              |
|----------------|----------------------------------------------------------|
| 0              | The cache line might have been used since being fetched. |
| 1              | The cache line was not used since being fetched.         |

###### Note

A Request Node that does not track the usage of the cache line can set the UnusedPrefetch bit value to zero.

The SLCRepHint field is only applicable in requests from a Request Node to HN-F.

The field is inapplicable in requests from the Request Node to HN-I and the Home Node to the Subordinate Node. The field can take any value.

Table 11-3 shows the suggested Replacement subfield encodings and their meaning.

**Table 11-3 Suggested Replacement subfield encodings**

| Replacement[2:0] | Description                      |
|------------------|----------------------------------|
| 0b000            | No recommendation (default)      |
| 0b100            | Most likely to be used again     |
| 0b101            | More likely to be used again     |
| 0b110            | Somewhat likely to be used again |
| 0b111            | Least likely to be used again    |
| 0b011 - 0b001    | Unused                           |

## 11.3 MPAM

*Memory System Performance Resource Partitioning and Monitoring (MPAM)* is a mechanism to efficiently utilize the memory resources among users and to monitor the utilization of those resources. The resources are partitioned among users by *Partition ID (PartID)* and *Performance Monitoring Group (PerfMonGroup)*. A Requester that supports MPAM includes in each request it sends a label, identifying the partition to which it belongs, together with the performance monitoring group within that partition. The Home or the Subordinate use this information to allocate their resources to this request.

The MPAM field is applicable only in the REQ and SNP channels:

- On the REQ channel, when a sender does not want to use MPAM for a request, the MPAM values must be set to default settings. See *Default values for MPAM subfields* on page 11-366.

- On the SNP channel, MPAM values are only applicable in Stash snoops.

In Non-stash type snoops, MPAM values are inapplicable and must be set to default values.

Field width is either 0 bits or 11 bits:

- The width is zero on interfaces that do not support MPAM.
- The width is 11 bits on interfaces that support MPAM. The field is further divided into the subfields:
  - PartID = 9 bits
  - PerfMonGroup = 1 bit
  - MPAMNS = 1 bit

Figure 11-3 shows the allocation of the MPAM field bits.

![Figure 11-3 MPAM subfields bit allocation diagram. The MPAM field is 11 bits wide. Bit 10:9 is labeled PerfMonGroup. Bit 1:0 is labeled MPAMNS. The central 9 bits are labeled PartID.](a4355ebbaadc763d5af946eee64e79f4_img.jpg)

Figure 11-3 MPAM subfields bit allocation diagram. The MPAM field is 11 bits wide. Bit 10:9 is labeled PerfMonGroup. Bit 1:0 is labeled MPAMNS. The central 9 bits are labeled PartID.

Figure 11-3 MPAM subfields bit allocation

How the MPAM field values are used by the Receiver is IMPLEMENTATION DEFINED.

### 11.3.1 MPAMNS

A Non-secure bit in the MPAM field, this is in addition to and different from the NS bit of the request.

The polarity of the MPAMNS bit encoding is the same as that of the NS bit.

Table 11-4 shows the MPAMNS encodings.

Table 11-4 MPAMNS encodings

| MPAMNS | Description          |
|--------|----------------------|
| 0      | Secure partition     |
| 1      | Non-secure partition |

All four combinations of values of MPAMNS and NS are permitted.

— Note —

This change is applied retrospectively to the CHI Issue D and Issue E.a specification.

### 11.3.2 MPAM value propagation

The Receiver is permitted, but not required, to support the full range of partitions and performance monitor groups received in the request. It is expected that during the system discovery and configuration process the capabilities of the system are discovered and the range of partitions and performance monitor groups that are used will match the capabilities of the system.

MPAM field values must be propagated onto an interface that supports MPAM.

It is permitted, but not required, to propagate MPAM field values onto an interface that does not support MPAM.

Table 11-5 shows the default values for MPAM fields when not supported or not propagated.

Table 11-5 Default values for MPAM subfields

| MPAM field   | Value                                                                                                   |
|--------------|---------------------------------------------------------------------------------------------------------|
| PerfMonGroup | 0                                                                                                       |
| PartID       | 0                                                                                                       |
| MPAMNS       | <ul><li>Same as NS value in the request message</li><li>Same as NS value in the snoop message</li></ul> |

### 11.3.3 Stash transaction rules

MPAM values in Stash snoops must be the same as in the request that generated the snoops.

For responses to Stash snoops, when the response includes a Data Pull request, the Home must assume the MPAM values in the Data Pull request are the same as in the original Stash request.

### 11.3.4 Request to Subordinate rules

MPAM values in a request to the Subordinate, where the request is generated by a request to the Home, must be the same as the MPAM values in that request to the Home.

## 11.4 Completer Busy

The Completer Busy indication is a mechanism for the Completer of a transaction to indicate its current level of activity. This signaling provides additional information to a Requester on how aggressive it can be in generating speculative activity to improve performance.

**CBusy** Completer Busy. A 3-bit field that is applicable in the appropriate DAT and RSP packets.  
When separate Data and Comp responses are used for a single Read request, the Busy indication in each response can be independently set.

The CBusy field is not applicable in:

- NonCopyBackWrData
- NonCopyBackWrDataAck
- CopyBackWriteData
- WriteDataCancel
- CompAck

— Note —

DataSource can be used as a qualifier to the Completer Busy indication such that some data sources, for example a Forwarding snoop, do not influence the busy indication.

### 11.4.1 Use case

This specification does not define how a CBusy indication is set by the Completer nor how it should be interpreted by a Requester. This is IMPLEMENTATION DEFINED. However, this specification recommends that implementations consider mechanisms to avoid a few busy Completers among many skewing the results.

#### Example use case

The following is an example encoding of the CBusy field.

**CBusy[2]** When asserted indicates multiple cores are actively making requests.

**CBusy[1:0]** Indicates the degree of fullness of the tracker at the Completer as:

- 00 = Less than 50% full.
- 01 = Greater than 50% full.
- 10 = Greater than 75% full.
- 11 = Greater than 90% full.

The prefetcher at the Requester can use the CBusy field values and fine-tune the prefetcher.

Table 11-6 shows the prefetcher mode that is determined by the value of CBusy.

Table 11-6 Prefetcher mode that is determined by CBusy

| CBusy[2]           | CBusy[1:0] | Prefetcher mode                                       |
|--------------------|------------|-------------------------------------------------------|
| 1                  | 11         | Disable inaccurate prefetchers.                       |
| Can take any value | 10         | Very conservative mode on inaccurate prefetchers.     |
| 1                  | 01         | Moderately aggressive mode on inaccurate prefetchers. |
| Can take any value | 00         | Fully aggressive mode on inaccurate prefetchers.      |

## 11.5 Trace Tag

This specification includes a TraceTag bit per channel that provides enhanced support for debugging, tracing, and performance measurement of systems.

### 11.5.1 TraceTag usage and rules

The rules for when to set and how to propagate TraceTag bit values are:

- The TraceTag bit can be set by the transaction initiator or an interconnect component.
- A component that receives a packet with a TraceTag bit set in every received packet must preserve and reflect the value back in any response packet or spawned packet generated in response to the received packet, else the TraceTag bit in the response or spawned packet can take any value. This requirement is true only when the TraceTag bit in the response packet is applicable. Examples of pairs of such response and received packets are CompAck in response to multiple CompData packets and Snoop response to the pair of two DVMOp packets.
- If a received packet spawns multiple responses, such as a Write request resulting in separate Comp and DBIDResp responses, or a Read request generating separate DataSepResp and RespSepData responses, all such spawned responses are required to have the TraceTag bit set if the spawning packet has the TraceTag bit set. If the spawning packet does not have the TraceTag bit set, then the value of the TraceTag bit in a spawned packet is independent of the value of the bit in other related spawned packets.
- If a component can receive multiple packets that are associated with a single transaction, then for each packet that it, in turn, generates, the TraceTag value is only required to be set if it is set in the associated received packet. For example:
  - A Write transaction flow at the Request Node might have write data and CompAck as two responses for received packets DBIDResp and Comp respectively. As CompAck is in response to the received Comp only, its TraceTag bit value is only required to depend on the TraceTag bit value in the Comp packet and similarly for the write data and DBIDResp Response-Received Packet pair.
    - A request that receives separate DataSepResp and RespSepData responses and generates a CompAck, is only required to have the TraceTag bit set in CompAck if RespSepData has the TraceTag bit set.
  - The TraceTag bit in the NCBWrDataCompAck response from RN must be set if either one of Comp or DBIDResp that caused the WriteData response have the TraceTag bit set.
- When an interconnect receives a packet with the TraceTag bit set, it must preserve the value and not reset the value.

###### Note

- Propagating the value of the TraceTag bit on a resulting cache eviction is IMPLEMENTATION DEFINED.
- The precise mechanism to trigger and utilize the TraceTag bit is IMPLEMENTATION DEFINED.
- It is expected that the TraceTag bit will be limited to single system-wide use at any time. Some of the ways the trace tag mechanism can be used are:
  - Debug, by tracing transaction flows through the system.
  - Performance counting
  - Latency measurement

###### Note

Examples, not an exhaustive list, of Request-Response pairs are:

- A Snoop response, with or without data, in response to a Snoop request.
- A Snoop response in response to a SnpDVMOp request.
- Data response from the Subordinate Node in response to a Read request.
- Spawned requests from HN-F:
  - Snoops generated in response to a request from the Request Node.
  - Request to SN-F generated in response to a request from the Request Node.

- Spawned request from HN-I:
  - Read or Write request to SN-I generated in response to a request from the Request Node.
- A CompAck from the Request Node in response to CompData, Comp, or RespSepData.
- A RetryAck response from the Home Node or the Subordinate Node to any request.
- A ReadReceipt response from the Home Node or the Subordinate Node to a Read request or from SN to a ReadNoSnpSep request.
- A DBIDResp response to a Write request.



# Chapter 12Memory Tagging

This chapter describes the Memory Tagging mechanism and contains the following sections:

- *Introduction* on page 12-372
- *Message extensions* on page 12-373
- *Tag coherency* on page 12-374
- *Read transaction rules* on page 12-375
- *Write transactions* on page 12-378
- *Dataless transactions* on page 12-380
- *Atomic transactions* on page 12-381
- *Stash transactions* on page 12-382
- *Snoop requests* on page 12-383
- *Home to Subordinate transactions* on page 12-385
- *Error response* on page 12-386
- *Requests and permitted tag operations* on page 12-388
- *TagOp field use summary* on page 12-390

## 12.1 Introduction

The *Memory Tagging Extension* (MTE) is a mechanism that is used to check the correct usage of data held in memory. When a memory location is allocated for a particular use, it can be also assigned a memory tag. This memory tag is held alongside that data in memory and is referred to as the Allocation Tag. When the memory location is later accessed, the Requester uses both the address of the location and the tag value that it believes is associated with the location. This tag is referred to as the Physical Address Tag or Physical Tag.

For any access where tag checking is enabled, the Physical Tag is checked against the Allocation Tag. The access always progresses as normal, and the result of the tag check determines whether or not an error condition is signaled.

This mechanism ensures that a memory access is for its expected purpose, rather than an erroneous or malicious access. It can be used at runtime to identify many common programming memory errors, such as buffer-overflow and use-after-free.

The memory tag consists of a 4-bit tag associated with each aligned 16 bytes of data in memory.

The following behavior is supported:

- Memory tagging is permitted only in requests to Normal WriteBack memory.
- Read transactions have an indication in the transaction request that determines whether the Allocation Tag value must be returned alongside the data.

Checking of the returned Physical Tag against the Allocation Tag is performed by the Requester.

In the case where a cache holds the data value, but does not hold the Allocation Tag value, then a Read transaction that returns both data and tag must be performed. The data returned is not required to be valid.

- Read requests that require tags to be fetched must not use Forwarding snoop.

StashOnce transactions that request Allocation Tags.  
The Allocation Tags are expected to be stashed along with the stashing of data.

- Write transactions that have a Physical Tag supplied alongside the write data that must be checked against the Allocation Tag.

Checking of the Physical Tag against the Allocation Tag is performed by the Completer. In the case of a mismatch a notification of the failure is required.

- Write transactions that update the Allocation Tag to a new value.

These Write transactions typically update the data at the same time. However, it is permitted to have no *Byte Enables* (BE) asserted so that only the tag is updated.

- Write transactions which pass a Dirty or Clean cache line to a downstream cache or memory controller without either updating or checking the tags.

These Write transactions always include data and provide an indication whether the Allocation Tag value is also being passed with the data.

- Snoop transactions that return data can also return the associated Allocation Tag.

If the tags are Dirty, they must be returned. If the tags are Clean, then returning them is optional.

- Cache Maintenance Operations must operate on both the data and the corresponding memory tags.

## 12.2 Message extensions

The following extensions to the CHI message definitions are used to support Memory Tagging:

**Tag** Provides sets of 4-bit tags, each associated with an aligned 16 bytes of data.

- Applicable on the DAT channel only.
- Size is  $\text{Data\_Width}/32$  bits.

See [Tag on page 13-435](#).

**TU** Tag Update. Indicates which of the Allocation Tags must be updated.

- Applicable on the DAT channel only.
- Size is  $\text{Data\_Width}/128$  bits.

See [Tag Update, TU on page 13-435](#).

**TagOp** Tag Operation. Indicates the operation to be performed on the tags present in the corresponding DAT channel.

- Applicable on the REQ, DAT, and RSP channels.
- Size is 2 bits.
- Value encodings are:

| TagOp[1:0] | Tag operation  |
|------------|----------------|
| 0b00       | Invalid        |
| 0b01       | Transfer       |
| 0b10       | Update         |
| 0b11       | Match or Fetch |

See [Tag Operation, TagOp on page 13-435](#).

###### — **Note** —

For clarity, in the following sections TagOp values are italicized to differentiate them from data and cache line values.

## 12.3 Tag coherency

This section summarizes the tag coherency features.

Allocation Tags that are cached are kept hardware coherent. The coherence mechanism is the same as data coherence.

Applicable tag cached states are: Invalid, Clean, and Dirty. A cache line that is either Clean or Dirty is Valid.

Constraints on the combination of data cache state and tag cache state are:

- Tags can be Valid only when data is Valid.
- Tags can be Invalid when data is Valid.
- When a cache line is in a Unique state, it applies to both data and tags.
- When a cache line is in a Shared state, it applies to both data and tags.
- When a cache line with Dirty tags is evicted then:
  - Both data and tags must be treated as Dirty.
  - The tags must be either written back to memory or passed Dirty [PD] by Home to another cache.
- When Clean tags are evicted from a cache, they can be sent to other caches or dropped silently.
- When Clean tags are evicted with Dirty data, Clean tags can be transferred downstream of PoC along with Dirty data.

## 12.4 Read transaction rules

A read can optionally fetch tags along with the data. The need to return tags along with read data is determined from the value of TagOp in the request.

### 12.4.1 TagOp values

When TagOp value in the request is *Transfer*:

- Tags are required to be returned along with the data.
- The state of the returned tags must be the appropriate permitted cache state for the request being used.
- The number of tags to be returned is determined by the size of Data that is returned. For all Snoopable requests four tags per access must be returned.
- When required by the access, matching of Physical Tags against the Allocation Tags that are received along with read data is done at the Requester.

When TagOp value in the Request is *Fetch*:

- Tags are required to be returned along with data.
- Returned data is not required to be valid. The Requester must ignore the received data irrespective of the tag match result.
- All tags corresponding to a cache line must be returned.
- The state of the returned tags must be Clean or Dirty.
- If Dirty tags are returned, they must be preserved, unless updated, and written back to memory.

When TagOp value in the request is *Invalid*:

- It is permitted, but not required, that tags are returned along with the data.
- If tags are returned along with the data, then they must be Clean.

#### Converting tags from Shared to Unique

When both the data and the tags are present at the Requester in Shared state, and the Requester requires to move the cache line to a Unique state, to update either the data or the tags or both, then the MakeReadUnique transaction with a TagOp value of *Transfer* is expected to be used. The Requester is permitted to use ReadUnique with a TagOp value of *Transfer*.

#### Fetching tags when Data is present

If a Requester has a cached copy of a cache line, with data Valid but Allocation tags are not Valid, and the Requester requires a Tag Match to be performed then the Requester must use a Read request to fetch the required tags. The type of the Read request and TagOp value in the request depends on:

- The operation being performed by the Requester, that is, a Load or a Store operation.
- The size of the Store operation.
- The target memory location.

A Requester in the above scenario must use:

- ReadClean with *Transfer* if the operation is a Load operation. The request can be sent from any initial data state. The initial MTE tag state is expected to be invalid but is permitted to be any state. See Table 4-33 on page 4-210 for Requester cache state transitions.
- ReadUnique with *Transfer* if the operation is a Store operation. The request can be sent from any initial data state. The initial MTE tag state is expected to be invalid but is permitted to be any state. ReadUnique, irrespective of the existence of MTE can be sent from any initial data state.

- ReadNoSnp with *Fetch* if the target memory location is Non-snoopable and the Requester guarantees to write a full cache line irrespective of the Tag Match result. The returned data must be dropped. The returned data is not required to be valid. Clean tags must be returned. All tags within the cache line must be Valid.
- ReadUnique with *Fetch*, if the target memory location is Snoopable and the Requester guarantees to write a full cache line irrespective of result of the Tag Match result. The returned data must be dropped. The returned data is not required to be valid. Clean or Dirty tags must be returned. All tags within the cache line must be Valid.

When responding to a ReadClean, a Home that uses a Snoop Filter to track the cached state at the Requester, must not downgrade the state of the cache line in the Snoop Filter based on the state in the response to the Requester.

###### Note

In prior issues of this specification, I and UCE were the only permitted initial cache line states for the ReadClean transaction. The Home that uses a Snoop Filter to track the cached states was permitted to set the state of the cached line based on the state in the response.

#### Permitted responses and tag state

The data and state of the cache line received with the Allocation Tags must be appropriately handled to not break coherency.

When the request TagOp value is *Transfer*, the permitted response field values are:

- *Transfer*. Indicates the returned tags are Clean.
- *Update*. Indicates the returned tags are Dirty. Data response must pass Dirty [PD].

When the request TagOp value is *Fetch*, the permitted response field values are:

- *Transfer*. Indicates the returned tags are Clean.
- *Update*. Indicates the returned tags are Dirty. Data response must pass Dirty [PD].

When the request TagOp value is *Invalid*, the permitted response field values are:

- *Invalid*. Indicates the returned tags are Invalid.
- *Transfer*. Indicates the returned tags are Clean.

When the TagOp value in Read data is invalid, TU must be all zeros. Tag is inapplicable and can take any value.

When data and response are separately sent in a Read transaction, the TagOp field is only applicable in the Data-only message. It is inapplicable in the Non-data response message and must be set to zero.

The cache state that the tags must be held in is consistent with the type of the Read request:

- For all Read requests with a TagOp value of *Invalid*, *Invalid* or *Clean* tags must be returned.
- For ReadNoSnp with a TagOp value of *Transfer* or *Fetch*, *Clean* tags must be returned.
- For ReadOnce and ReadClean with a TagOp value of *Transfer*, *Clean* tags must be returned.
- For ReadNotSharedDirty with a TagOp value of *Transfer*, *Clean* or *Dirty* tags must be returned. *Dirty* tags are permitted to be returned only if the cache line state is Unique.
- For ReadShared with a TagOp value of *Transfer*, *Clean* or *Dirty* tags must be returned.
- For ReadUnique with a TagOp value of *Transfer* or *Fetch*, *Clean* or *Dirty* tags must be returned. The returned cache line state must be Unique.
- For MakeReadUnique with a TagOp value of *Transfer*, if data is included in the response then *Clean* or *Dirty* tags must be returned.
- In the case where *Dirty* tags are returned, the cache line returned must include pass Dirty [PD].

When MTE is not supported for the targeted address, the response must use *TagOp* of *Invalid*.

For an Exclusive access sequence, it is important that the fetching of tags must avoid any form of request that will Invalidate other copies of the cache line before the Exclusive Store transaction is performed. This is typically achieved by fetching tags at the same time the Exclusive Load transaction is performed.

### 12.4.2 Permitted initial MTE tag states

Table 12-1 shows the permitted initial data state along with tag state for different Read transactions and permitted TagOp value in the corresponding request. The combination of tag and data states must obey the coherency rules described in *Tag coherency* on page 12-374.

Table 12-1 Permitted initial Tag states and request TagOp values in Read transactions

| Request            | TagOp                    | Data state | Tag state             |
|--------------------|--------------------------|------------|-----------------------|
| ReadNoSnp          | Invalid, Transfer, Fetch | I          | Invalid               |
| ReadOnce           | Invalid, Transfer        | I, UCE     | Invalid               |
| ReadNotSharedDirty |                          |            |                       |
| ReadShared         |                          |            |                       |
| ReadClean          | Invalid                  | I, UCE     | Invalid               |
|                    | Transfer                 | I, UCE     | Invalid               |
|                    |                          | SC, UC     | Invalid, Clean        |
|                    |                          | SD, UD     | Invalid, Clean, Dirty |
| ReadPreferUnique   | Invalid, Transfer        | I, UCE     | Invalid               |
|                    |                          | SC         | Invalid, Clean        |
|                    |                          | SD         | Invalid, Clean, Dirty |
| ReadUnique         | Invalid, Transfer, Fetch | I, UCE     | Invalid               |
|                    |                          | SC, UC     | Invalid, Clean        |
|                    |                          | SD, UD     | Invalid, Clean, Dirty |
| MakeReadUnique     | Invalid                  | SC         | Invalid, Clean        |
|                    |                          | SD         | Invalid, Clean, Dirty |
|                    |                          | Transfer   | SC                    |
|                    |                          | SD         | Clean, Dirty          |

## 12.5 Write transactions

Different fields to support MTE are distributed between the Request and Data message of a Write transaction. The TagOp field, which indicates the operation to be performed on the tags in the WriteData message, is included in both the Request and WriteData message. The Request also includes the TagGroupID field to provide an identifier for the pass/fail response for a request that requires a Tag Match operation.

###### Note

The use of the TagGroupID field is IMPLEMENTATION DEFINED, typically it can be used to identify the Exception level and TTBR which a response relates to.

The TagOp value in the WriteData message is typically the same as the value in the Request message, except when either the write data is snooped out or the write is canceled. When the TagOp values in the WriteData and Write request are different, whether or not to perform a Tag Match must be decided based on the TagOp value in the WriteData request.

The WriteData message also includes a Tag Update (TU) bit per tag, which is applicable when TagOp is *Update*.

### 12.5.1 Permitted TagOp values

This section describes the permitted WriteData TagOp values for each of the permitted TagOp values in the Write request message.

When the TagOp field in the Request is *Invalid*, the Memory Tagging fields in the WriteData must be set to zero and ignored by the Completer.

When the TagOp field in the Request is *Transfer*, the TagOp field in the WriteData can be:

- *Transfer*: The Tags are Clean and must be handled appropriately by the Completer.
- *Invalid*: This is possible only if either the cached copy is invalidated, or the Write transaction is canceled.

In a WriteClean transaction where the Request TagOp is *Transfer*, the TagOp in the Write data is not permitted to be changed to *Update*.

When the TagOp field in the request is *Update*, the TagOp field in the WriteData can be:

- *Update*: The Dirty tags must be cached or written to memory.
- *Transfer*: The Tags are Clean. This is possible if the Dirty tags have been snooped out.
- *Invalid*: This is possible only if either the cached copy is invalidated or the Write transaction is canceled.

When the TagOp field in the Request is *Match* the TagOp field in the WriteData can be:

- *Match*: The appropriate Tag Match must be performed at the Completer.
- *Invalid*: This is possible only if the Write transaction is canceled.

### 12.5.2 TagOp, TU, and tags relationship

This section describes the relationship between TagOp, TU, and tags in different Write transactions:

- For all Write requests with TagOp *Invalid*, the Memory Tagging fields must be set to zero and ignored by the Completer.
- For WriteBackFull and WriteCleanFull with TagOp:
  - *Transfer*: Clean tags must be returned. TU bits are inapplicable and must be set to zero.
  - *Update*: All TU bits must be asserted.
  - *Match*: Is not permitted.
- For WriteBackPtl with TagOp:
  - *Transfer*: Is not permitted.
  - *Update*: Is not permitted.
  - *Match*: Is not permitted.

- For WriteNoSnpFull with TagOp:
  - *Transfer*: TU bits are inapplicable and must be set to zero. Clean tag transfer is permitted from the Request Node to the Home Node as well as the Home Node to the Subordinate Node.
  - *Update*: All TU bits must be asserted.
  - *Match*: TU bits are inapplicable and must be set to zero.
- For WriteUniqueFull and WriteUniqueFullStash with TagOp:
  - *Transfer*: Is not permitted.
  - *Update*: All TU bits must be asserted.
  - *Match*: TU bits are inapplicable and must be set to zero.
- For WriteNoSnpPtl, WriteUniquePtl and WriteUniquePtlStash with TagOp:
  - *Transfer*: Is not permitted.
  - *Update*: Any combination of TU and BE bits, including none or all, can be asserted.
  - *Match*: TU bits are inapplicable and must be set to zero. Tag Match must be performed for only those tags that have at least one corresponding BE bit asserted.  
    A Tag Match must not be performed when all BE bits are set to zero.
- For WriteEvictFull, WriteEvictOrEvict and with TagOp:
  - *Transfer*: Clean tags must be returned. TU bits are inapplicable and must be set to zero.
  - *Update*: Is not permitted.
  - *Match*: Is not permitted.
- For WriteNoSnpZero and WriteUniqueZero only TagOp *Invalid* is permitted.

For a Write request with a TagOp of *Match* the tags within the size wrap boundary can take any value, and the tags outside of size are inapplicable and can also take any value.

In the WriteDataCancel Write data response, irrespective of the TagOp value in the Write request, the MTE fields are inapplicable and must be set to zero.

In Write data, with TagOp *Invalid*, all the TU bits and all the Tag bits must be set to zero.

## 12.6 Dataless transactions

MakeReadUnique and MakeUnique are the only Dataless transactions that support the use of the TagOp field. In all other Dataless transactions, the TagOp field is inapplicable and must be set to all zeros.

The permitted TagOp value in responses to MakeReadUnique with TagOp value of *Invalid* are *Invalid* and *Transfer* only. *Transfer* is permitted only in responses with data.

When a Requester uses MakeReadUnique with Transfer, it is required that it has copies of both the data and the tags.

The permitted TagOp value in responses to MakeReadUnique with TagOp value of *Transfer* are *Invalid*, *Transfer*, and *Update*. *Transfer* is permitted only in responses with data. *Update* is permitted only when the response is transferring the responsibility of updating Dirty data, that is, the response includes [UD\_PD].

TagOp value in MakeUnique request can be *Invalid* or *Update* only. A Request TagOp value of *Update* is an indication that the Requester will update the tags along with data. Home, in response to MakeUnique, is permitted to use SnpMakeInvalid only when either the Request TagOp value is *Update* or the Home knows that the Snoopee does not have Dirty tags.

The only permitted TagOp value in response to MakeUnique is *Invalid*.

Cache Maintenance Operations must operate on both the data and the corresponding memory tags. A MakeInvalid that permits dropping of Dirty data without writing to memory must write Dirty tags to memory.

## 12.7 Atomic transactions

TagOp is applicable in Atomic transactions. The permitted values for the field are *Invalid* and *Match*.

The Physical Tags to be matched are provided in the write data and correspond to the valid data bytes in AtomicLoad, AtomicStore, and AtomicSwap. Only one set of tag bits are applicable in these Atomic transactions because the maximum data size is 8-byte. The remaining tag bits in the set are not applicable and must be set to zero.

In AtomicCompare with a data size of up to 16 byte the valid data still corresponds to only one set of tag bits.

In AtomicCompare with data size of 32-byte the individual compare and swap data is only 16-byte. Only one set of Physical Tag bits is required to be matched when TagOp is set to *Match*. Physical Tags must be duplicated to cover both Compare and Swap data. The Compiler is permitted to use either set of Physical Tags to perform Tag Match.

The permitted TagOp values in the CompData response to Non-store Atomic transactions are *Invalid* and *Transfer*.

The Write data for Atomic transactions where TagOp is *Invalid* must have all TU bits and all the Tag bits set to zero.

## 12.8 Stash transactions

In StashOnce and StashOnceSep transactions, TagOp values of *Invalid* and *Transfer* are permitted.

For Stash snoop interaction with Memory Tagging see *Stash snoops* on page 12-384.

## 12.9 Snoop requests

This section describes the permitted use by Home of the following snoop types:

- *Non-forwarding snoops*
- *Forwarding snoops*
- *Stash snoops on page 12-384*

### 12.9.1 Non-forwarding snoops

Home can use any applicable Non-forwarding snoop when tags are needed by the request. If the Snoop response returns data to Home but not tags, the Home is responsible for obtaining tags before returning the Data response to the Requester.

A Home in response to WriteUniqueFull, WriteUniqueFullStash, MakeUnique, and MakeInvalid must not use the SnpMakeInvalid snoop request unless either:

- The transaction is WriteUniqueFull, WriteUniqueFullStash, or MakeUnique with a TagOp value of *Update*.
- The Home can determine that the Snoopee does not hold Dirty tags.

— Note —

A Requester, by sending a ReadUnique with TagOp *Fetch*, is indicating its willingness to update the full cache line but not the tags. Home must not use SnpMakeInvalid in response to such a request, to avoid losing modified tags at the Snoopee.

—

### 12.9.2 Forwarding snoops

The use by Home of the Forwarding snoop is permitted only if the request does not need to fetch tags. A Forwarding snoop is permitted to be sent even when the Snoopee has Valid tags. When responding to a Forwarding snoop, if the Snoopee has Dirty tags then it must not forward Dirty tags to the Requester nor split dirtiness or uniqueness of tags and data.

A Snoopee is always permitted to forward Clean tags to the Requester.

When tags are Clean, the Snoopee must follow the same data transfer rules as in the Non-MTE case.

When tags are Dirty the Snoopee must follow the rules:

- For the invalidating Forwarding snoop SnpUniqueFwd and SnpPreferUniqueFwd handled as an invalidating snoop:

- Must not forward data to the Requester.
- Must return data and tags to the Home.

- For the Non-invalidating Forwarding snoops SnpCleanFwd, SnpSharedFwd, SnpNotSharedDirtyFwd SnpPreferUniqueFwd handled as a non-invalidating snoop:

- Must treat the snoop as SnpCleanFwd.

— Note —

Same as SnpNotSharedDirtyFwd.

—

- For SnpOnceFwd:

- Permitted to return Dirty tags to the Home.
- Dirty tags must be kept at the Snoopee if the data transfer to Home is not performed.
- Dirty tags must be written back to Home if the cache line is being invalidated or Dirty data is being written back to Home.

A Snoopee is permitted to convert any Forwarding snoop to its corresponding Non-forwarding snoop.

###### Note

This property is similar to that in the Non-MTE case.

See *Permitted TagOp values in Snoop responses* for more details.

### 12.9.3 Stash snoops

Because the SNP channel does not include a TagOp field, the Home cannot forward the Requester's TagOp intentions to the Stash target.

The permitted TagOp values in Snoop responses are:

- *Invalid* in response to SnpStash.
- *Invalid*, *Transfer*, and *Update* in response to SnpUniqueStash.
- *Invalid* in response to SnpMakeInvalidStash.

See *Permitted TagOp values in Snoop responses* for more details.

The requirements for determining the TagOp value in the Read request implied from the Data Pull request in the Snoop response are as follows:

For a Data Pull request in response to SnpStash:

- If the TagOp value in the original request is *Transfer*, then it is recommended that Clean tags are returned in response to the Data Pull request.
- If the TagOp value in the original request is *Invalid*, then it is recommended that Clean tags are returned in response to the Data Pull request if tags are available.

For a Data Pull request in response to SnpUniqueStash:

- Irrespective of the presence or absence of data in the Snoop response and for any cache state, it is recommended that, if tags are available when data is returned, Clean tags are returned in response to a Data Pull request.

### 12.9.4 Permitted TagOp values in Snoop responses

The permitted tag field values in Snoop responses are:

- For SnpResp, the TagOp field is inapplicable and must be set to zero.
- For SnpRespDataPt, the permitted TagOp value is Invalid. Both the TU and the Tag field must be set to zero and ignored by the receiver.
- For SnpRespData:
  - Invalid. All Tag fields must be set to zero.
  - Transfer. Clean tags must be returned. TU bits are inapplicable and must be set to zero.
  - Update. All TU bits must be asserted. The data state must include Pass Dirty.
  - Match. Not permitted.

## 12.10 Home to Subordinate transactions

For a Read request to the Subordinate:

- The permitted TagOp values are *Invalid*, *Transfer*, and *Fetch*.

For a Write request to the Subordinate:

- The permitted TagOp values are *Invalid*, *Transfer*, *Update*, and *Match*.

For an Atomic request to the Subordinate:

- The permitted TagOp values are *Invalid*, and *Match*.

A ReadNoSnp or ReadNoSnpSep with TagOp *Transfer* or *Fetch* can be used to fetch tags from the Subordinate. Tags can be returned from a Subordinate to the Home directly or sent to the Requester using DMT. When TagOp *Fetch* is used then the Subordinate is not required to return valid data. TagOp *Fetch* is permitted only with a data size of 64 bytes.

When memory needs to be updated with tags, WriteNoSnp with TagOp *Update* must be used. When only tags need to be updated the data byte enables can be set to all zero.

When TagOp is *Match*, the TagGroupID in WriteNoSnp and Atomic transactions to the Subordinate are applicable, and these values must be returned in the TagMatch response.

When Atomic operations are performed at the Subordinate Node, the Home is permitted to include TagOp *Match* in Atomic requests to the Subordinate. In both non-Store Atomic and Store Atomic transactions where the tag match is performed at the Subordinate, the TagMatch response TgtID must be obtained from the ReturnNID value in the request. To support this feature, it is required that the ReturnNID in the Atomic Store from a Home Node to a Subordinate Node is applicable and must be set to the same value as the SrcID in the request.

###### — Note —

Applicability of the ReturnNID in non-Store Atomic transactions is already a requirement in the previous version of this specification.

## 12.11 Error response

The following sub-sections describe Error response handling for:

- [Tag Match](#)
- [Non-Tag Match errors](#)
- [MTE not supported on page 12-387](#)

### 12.11.1 Tag Match

Write and Atomic transactions that have TagOp value of *Match* must return the results of the Tag Match operation. The results are returned using the TagMatch message. The transaction must proceed as normal irrespective of the Tag Match result. The TagMatch response must be sent even if the WriteData is canceled or a Tag Match is not performed.

###### Note

Using a separate TagMatch message adds complexity and extra messages to the Write and Atomic transactions but has the advantage that it provides a sufficiently accurate response mechanism. Using a separate response does not delay the sending of the Comp response.

The TagMatch message characteristics are:

- It is sent by the Completer performing the Tag Match operation. This can be a Home Node or a Subordinate Node.
- The TgtID value in the message is copied from:
  - SrcID in the request if the responder is a Home Node.
  - ReturnNID in the request if the responder is a Subordinate Node. The ReturnNID can point to the Requester or the Home. When the Subordinate returns the TagMatch response to the Home then, if required by the transaction, the Home is responsible for forwarding the response to the Requester.
- The response must return the TagGroupID value from the request.
- The TraceTag field is inapplicable and can take any value.
- The Resp field value in the response indicates the Tag Match state as either pass or fail. See [Response status, Resp on page 13-436](#).
- The TagMatch response can be sent as soon as the Completer can determine the result. TagMatch is permitted to be sent without waiting for data. This can occur when the Completer does not support MTE.
- The Resp value in the TagMatch response must be:
  - A Fail when MTE is not supported.
  - A Pass when MTE is supported but the Tag Match is not performed. For example, when an Exclusive write fails and the Tag Match is not performed.
  - Accurate, if the match is performed.

### 12.11.2 Non-Tag Match errors

Permitted Data and Non-data error responses to requests are independent of the presence or absence of Memory Tagging.

Permitted RespErr field values in the TagMatch response are OK, DERR, and NDERR. See [Error response use by transaction type on page 9-337](#).

When the RespErr field in a response is NDERR then:

- The TagOp in the response to the Requester is inapplicable and can take any value.
- The Snoop response must be Invalid.

Poison on tags is not supported. See [Poison on page 9-347](#).

### 12.11.3 MTE not supported

When a Completer does not support MTE for the address in the request, then the Completer is permitted to send a TagOp value of *Invalid* in response to a Read transaction with a TagOp value of *Transfer* or *Fetch*. The returned tags must be set to zero. The returned tags can be cached as Clean by the Requester.

A Completer in response to a Read request to a Non-cacheable or Device memory location must set the TagOp value in the response to *Invalid*.

When a Completer does not support MTE for the address in the request, but receives a Write request with TagOp *Match*, then the Completer is still required to send a TagMatch response. The Resp field value must indicate that the Tag Match failed. The Completer is permitted, but not required, to wait for the write data before sending the TagMatch response.

## 12.12 Requests and permitted tag operations

Table 12-2 shows a summary of the permitted TagOp field values in the different requests. The following key is used:

| Y | Yes, permitted    |
|---|-------------------|
| N | No, not permitted |

Table 12-2 Permitted TagOp values for each request type

| Requests              | Tag operation |          |        |       |       |
|-----------------------|---------------|----------|--------|-------|-------|
|                       | Invalid       | Transfer | Update | Match | Fetch |
| ReadOnce              | Y             | Y        | N      | N     | N     |
| ReadClean             |               |          |        |       |       |
| ReadShared            |               |          |        |       |       |
| ReadNotSharedDirty    |               |          |        |       |       |
| ReadPreferUnique      |               |          |        |       |       |
| ReadUnique            | Y             | Y        | N      | N     | Y     |
| ReadNoSnp             | Y             | Y        | N      | N     | Y     |
| ReadNoSnpSep          |               |          |        |       |       |
| ReadOnce*Invalid      | Y             | N        | N      | N     | N     |
| MakeReadUnique        | Y             | Y        | N      | N     | N     |
| CleanShared           | Y             | N        | N      | N     | N     |
| CleanSharedPersist    |               |          |        |       |       |
| CleanSharedPersistSep |               |          |        |       |       |
| CleanUnique           | Y             | N        | N      | N     | N     |
| CleanInvalid          |               |          |        |       |       |
| MakeInvalid           |               |          |        |       |       |
| MakeUnique            | Y             | N        | Y      | N     | N     |
| Evict                 | Y             | N        | N      | N     | N     |
| StashOnceUnique       | Y             | Y        | N      | N     | N     |
| StashOnceSepUnique    |               |          |        |       |       |
| StashOnceShared       |               |          |        |       |       |
| StashOnceSepShared    |               |          |        |       |       |
| WriteNoSnpFull        | Y             | Y        | Y      | Y     | N     |
| WriteUniqueFull       | Y             | N        | Y      | Y     | N     |
| WriteUniqueFullStash  |               |          |        |       |       |
| WriteNoSnpPtl         | Y             | N        | Y      | Y     | N     |
| WriteUniquePtl        |               |          |        |       |       |
| WriteUniquePtlStash   |               |          |        |       |       |
| WriteBackFull         | Y             | Y        | Y      | N     | N     |
| WriteCleanFull        |               |          |        |       |       |
| WriteBackPtl          | Y             | N        | N      | N     | N     |

Table 12-2 Permitted TagOp values for each request type (continued)

| Requests               | Tag operation |          |        |       |       |
|------------------------|---------------|----------|--------|-------|-------|
|                        | Invalid       | Transfer | Update | Match | Fetch |
| WriteEvictFull         | Y             | Y        | N      | N     | N     |
| WriteEvictOrEvict      |               |          |        |       |       |
| WriteNoSnapFull+(P)CMO | Y             | Y        | Y      | N     | N     |
| WriteNoSnapPtl+(P)CMO  | Y             | N        | Y      | N     | N     |
| WriteUniqueFull+(P)CMO | Y             | N        | N      | N     | N     |
| WriteUniquePtl+(P)CMO  | Y             | N        | N      | N     | N     |
| WriteBackFull+(P)CMO   | Y             | Y        | Y      | N     | N     |
| WriteCleanFull+(P)CMO  | Y             | Y        | Y      | N     | N     |
| WriteNoSnapZero        | Y             | N        | N      | N     | N     |
| WriteUniqueZero        | Y             | N        | N      | N     | N     |
| Atomic*                | Y             | N        | N      | Y     | N     |
| PrefetchTgt            | Y             | Y        | N      | N     | N     |
| PCrdReturn             | Y             | N        | N      | N     | N     |
| DVMOp                  |               |          |        |       |       |

The TagOp field in ReqLCrdReturn, DtlLCrdReturn, and RspLCrdReturn is inapplicable and can take any value.

The Tag and TU fields in DtlLCrdReturn are inapplicable and can take any value.

## 12.13 TagOp field use summary

The following sections give a summary of the use of the TagOp field in messages in different channels:

REQ channel message:

- Read\* and MakeReadUnique transaction:
  - TagOp field can be *Invalid*, *Transfer*, or *Fetch*.
  - TagOp *Fetch* is permitted only in ReadUnique, ReadNoSnp, and ReadNoSnpSep transactions.
  - TagOp field *Transfer* indicates whether Allocation Tags must be returned alongside read data.
  - TagOp field *Fetch* indicates only valid tags are required to be returned. Returned data is not required to be valid.
- Write transaction:
  - TagOp field can be *Invalid*, *Transfer*, *Match* or *Update*.
  - TagOp field *Transfer* indicates Clean tags are being transferred and tags can be cached alongside the data.
  - TagOp field *Match* indicates a Match check is required between the Physical Tags in the message and the Allocation Tags at the memory location.
  - TagOp field *Update* indicates Dirty tags are being passed, which must update the Allocation Tag values.
- MakeUnique transaction:
  - TagOp field can be *Invalid* or *Update*.
  - TagOp field *Update* indicates all tags will be written to.
- Atomic transaction:
  - TagOp field can be *Invalid* or *Match*.
  - TagOp field *Match* indicates whether a Tag Match is required.
- StashOnce transaction:
  - TagOp field can be: *Invalid* or *Transfer*.
  - TagOp field *Transfer* indicates whether Allocation Tags should be stashed alongside Stash data.
- PrefetchTgt transaction:
  - TagOp value can be *Invalid* or *Transfer*.
- For all the other REQ channel messages, the TagOp field is inapplicable and must be zero.

DAT channel message:

- For Read data, the TagOp field indicates whether the Allocation Tags sent along with the data are Invalid, Clean, or Dirty.
- For Snoop data, the TagOp field indicates whether the Allocation Tags sent in the Snoop response are Invalid, Clean, or Dirty.
- For write data, the TagOp field indicates whether the Allocation Tags sent in the write data are Invalid, Clean, Dirty, or a Match check is required. The TagOp value must be the same as in the Request message except when a snoop has downgraded the state of the tags or the write has been canceled.

RSP channel message:

- For a Comp response, the TagOp field is only used in response to a MakeReadUnique transaction and is used to indicate if responsibility for Dirty tags is being passed to the Requester.
- For all other RSP channel messages, the TagOp field is inapplicable and must be zero.

SNP message:

- The TagOp field is not present in the SNP channel.



# Chapter 13Link Layer

This chapter describes the Link layer that provides a streamlined mechanism for packet-based communication between nodes and the interconnect across links. It contains the following sections:

- [Introduction on page 13-394](#)
- [Link on page 13-395](#)
- [Flit on page 13-396](#)
- [Channel on page 13-397](#)
- [Port on page 13-399](#)
- [Node interface definitions on page 13-400](#)
- [Increasing inter-port bandwidth on page 13-402](#)
- [Channel interface signals on page 13-406](#)
- [Flit packet definitions on page 13-410](#)
- [Protocol flit fields on page 13-416](#)
- [Link flit on page 13-442](#)

## 13.1 Introduction

The Link layer provides a streamlined mechanism for packet-based communication between nodes and the interconnect.

The Link layer defines:

- Packet and flit formats
- Flow control across a link

Figure 13-1 shows a typical system using link based communication.

![Diagram showing a system using link based communication. Six nodes (Node 1 through Node 6) are connected to a central Interconnect block. Each node has Tx (Transmit) and Rx (Receive) interfaces. The Interconnect block also has Tx and Rx interfaces. Arrows indicate communication links between the nodes and the Interconnect, and between the Interconnect and the nodes. The overall structure is labeled 'Links'.](36e00b0e7300ebad1f55e782b2f37182_img.jpg)

Diagram showing a system using link based communication. Six nodes (Node 1 through Node 6) are connected to a central Interconnect block. Each node has Tx (Transmit) and Rx (Receive) interfaces. The Interconnect block also has Tx and Rx interfaces. Arrows indicate communication links between the nodes and the Interconnect, and between the Interconnect and the nodes. The overall structure is labeled 'Links'.

Figure 13-1 System using link based communication

Interface parity signals, which are discussed in *Use of interface parity* on page 9-349 are not included in this chapter.

## 13.2 Link

Flit communication occurs between a Transmitter and a Receiver pair.

The connection between a Transmitter and a Receiver is referred to as a link.

Two-way communication between a node and the interconnect requires a pair of links. Figure 13-2 shows the link requirements.

![](a213364acbef8a60eeaa304731ff3eb8_img.jpg)

Diagram illustrating two-way link communication between a Node and an Interconnect.

The Node contains a Transmitter (TX) and a Receiver (RX). The Interconnect contains a Receiver (RX) and a Transmitter (TX).

Link 1 connects the Node's Transmitter (TX) to the Interconnect's Receiver (RX). Link 2 connects the Node's Receiver (RX) to the Interconnect's Transmitter (TX).

Figure 13-2 Two-way link communication

### 13.2.1 Outbound and inbound links

The link used by a Transmitter to send packets is defined as the outbound link.

The link used by a Receiver to receive packets is defined as the inbound link.

Figure 13-3 shows the outbound and inbound links at a node. The interface at the interconnect has a complementary pair of links.

![](89d09abb08521a0b37a49c6deffd71b8_img.jpg)

Diagram illustrating outbound and inbound links at a Node.

The Node contains a Transmitter (TX) and a Receiver (RX).

The Outbound Link connects the Node's Transmitter (TX) to the Interconnect.

The Inbound Link connects the Node's Receiver (RX) to the Interconnect.

Figure 13-3 Outbound and inbound links

## 13.3 Flit

A flit is the basic unit of transfer in the Link layer.

Packets are formatted into flits and transmitted across a link. There are two types of flits:

**Protocol flit** A Protocol flit carries a protocol packet in its payload. In this specification, every protocol packet is mapped into exactly one protocol flit.

**Link flit** A Link flit carries messages associated with link maintenance. For example, a Transmitter uses a Link flit to return a Link layer Credit, also referred to as an L-Credit, to the Receiver during a link deactivation sequence.

Link flits originate at a link Transmitter and terminate at the link Receiver connected at the other side of the link.

## 13.4 Channel

In this specification, the Link layer provides a set of channels for flit communication.

Each channel has a defined flit format that has multiple fields and some of the field widths have multiple possible values. In some cases, the defined flit format can be used on both an inbound and an outbound channel.

Table 13-1 shows the channels, and the mapping onto the Request Node and Subordinate Node component channels.

Table 13-1 Channels' mapping onto the RN and SN component channels

| Channel         | Description                                                                                                                                                                                           | Usage                                            | RN Channel | SN Channel |
|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|------------|------------|
| REQ<br>Request  | The request channel transfers flits associated with request messages such as Read requests and Write requests. See <a href="#">Request, REQ, channel on page 13-406</a> .                             | All Requests                                     | TXREQ      | RXREQ      |
| RSP<br>Response | The response channel transfers flits associated with response messages that do not have a data payload such as write completion messages. See <a href="#">Response, RSP, channel on page 13-407</a> . | Responses from the Completer                     | RXRSP      | TXRSP      |
|                 |                                                                                                                                                                                                       | Snoop Response and Completion<br>Acknowledge     | TXRSP      | -          |
| SNP<br>Snoop    | The snoop channel transfers flits associated with Snoop and SnpdVMOp Request messages. See <a href="#">Snoop, SNP, channel on page 13-408</a> .                                                       | All Snoop requests                               | RXSNP      | -          |
| DAT<br>Data     | The data channel transfers flits associated with protocol messages that have a data payload such as read completion and WriteData messages. See <a href="#">Data, DAT, channel on page 13-409</a> .   | WriteData, and Snoop response data<br>from an RN | TXDAT      | RXDAT      |
|                 |                                                                                                                                                                                                       | Read data                                        | RXDAT      | TXDAT      |

### 13.4.1 Channel dependencies

The following dependencies are permitted between the channels in the protocol.

For a Request Node:

- A Request Node must make forward progress on the inbound SNP channel without requiring forward progress on outbound REQ channel.
- A Request Node is permitted to wait for forward progress on the outbound RSP channel before making forward progress on the inbound SNP channel.
- A Request Node is permitted to wait for forward progress on the outbound DAT channel before making forward progress on the inbound SNP channel.
- A Request Node must make forward progress on the inbound RSP channel without requiring forward progress on any other channel.
- A Request Node must make forward progress on the inbound DAT channel without requiring forward progress on any other channel.

###### **Note**

The requirement that a Request Node must make forward progress on the inbound RSP and DAT channel, without requiring forward progress on any other channel, means that a Request Node must be able to accept all Comp and CompData responses for outstanding transactions without sending any CompAck responses.

For a Subordinate Node:

- A Subordinate Node is permitted to wait for forward progress on the outbound RSP channel before making forward progress on the inbound REQ channel.
- A Subordinate Node must make forward progress on the inbound REQ channel without requiring forward progress on the outbound DAT channel.
- A Subordinate Node must make forward progress on the inbound DAT channel without requiring forward progress on any other channel.

## 13.5 Port

A Port is defined as the set of all links at the interface of a node.

Figure 13-4 shows the relationship between links, channels, and port. See *Node interface definitions* on page 13-400 for the specific node requirements, See *Channel interface signals* on page 13-406, and Chapter 14 *Link Handshake* for signal details.

![](aa986f27d9f557502de5bfc7e29b1399_img.jpg)

Diagram illustrating the relationship between links, channels, and port. The diagram shows a vertical structure divided into two main sections: the Outbound Link (top) and the Inbound Link (bottom), connected by a central Port structure.

**Outbound Link (Top):**

- Port signals: TXACTIVE, RXACTIVE.
- Outbound Link signals: TXLINKACTIVEREQ, TXLINKACTIVEACK.
- REQ channel signals: TXREQFLITPEND, TXREQFLITV, TXREQFLT, TXREQLCRDV.
- RSP channel signals: TXRSPFLITPEND, TXRSPFLITV, TXRSPFLIT, TXRSPLCRDV.
- DAT channel signals: TXDATFLITPEND, TXDATFLITV, TXDATFLT, TXDATLCRDV.

**Inbound Link (Bottom):**

- Port signals: RXLINKACTIVEREQ, RXLINKACTIVEACK.
- Inbound Link signals: RXRSPFLITPEND, RXRSPFLITV, RXRSPFLT, RXRSPLCRDV.
- DAT channel signals: RXDATFLITPEND, RXDATFLITV, RXDATFLT, RXDATLCRDV.
- SNP channel signals: RXSNPFLITPEND, RXSNPFLITV, RXSNPFLT, RXSNPLCRDV.

Figure 13-4 Relationship between links, channels, and port

## 13.6 Node interface definitions

The nodes exchange messages by sending flits across the node interface. This section describes two node types of node interfaces supported in this specification:

- *Request Nodes*
- *Subordinate Nodes on page 13-401*

— Note —

The LINKACTIVE interface pins and signals used by each node for link management are described in [Chapter 14 Link Handshake](#).

### 13.6.1 Request Nodes

This section describes the Request Node interfaces:

- *RN-F*
- *RN-D*
- *RN-I on page 13-401*

#### RN-F

The RN-F interface uses all channels and is used by a fully coherent Requester such as a core or cluster. Figure 13-5 shows the RN-F interface.

![Figure 13-5 RN-F interface diagram. The diagram shows two blocks: RN-F (Request Node) and ICN (Interface Coherent Node). The RN-F block has inputs TXREQ, RXRSP, RXDAT, RXSNP, TXRSP, and TXDAT. The ICN block has inputs RXREQ, TXRSP, TXDAT, TXSNP, RXRSP, and RXDAT. The connections are: RN-F TXREQ connects to ICN RXREQ (REQ). RN-F RXRSP connects to ICN TXRSP (RSP). RN-F RXDAT connects to ICN TXDAT (DAT). RN-F RXSNP connects to ICN TXSNP (SNP). RN-F TXRSP connects to ICN RXRSP (RSP). RN-F TXDAT connects to ICN RXDAT (DAT).](30fffbbd50d940cf816cb516b3e9acb9_img.jpg)

Figure 13-5 RN-F interface diagram. The diagram shows two blocks: RN-F (Request Node) and ICN (Interface Coherent Node). The RN-F block has inputs TXREQ, RXRSP, RXDAT, RXSNP, TXRSP, and TXDAT. The ICN block has inputs RXREQ, TXRSP, TXDAT, TXSNP, RXRSP, and RXDAT. The connections are: RN-F TXREQ connects to ICN RXREQ (REQ). RN-F RXRSP connects to ICN TXRSP (RSP). RN-F RXDAT connects to ICN TXDAT (DAT). RN-F RXSNP connects to ICN TXSNP (SNP). RN-F TXRSP connects to ICN RXRSP (RSP). RN-F TXDAT connects to ICN RXDAT (DAT).

Figure 13-5 RN-F interface

#### RN-D

The RN-D interface uses all channels and is used by an IO coherent node that processes DVM messages. Use of the SNP channel is limited to DVM transactions. See *DVM transaction flow on page 8-304* for details. Figure 13-6 shows the RN-D interface.

![Figure 13-6 RN-D interface diagram. The diagram shows two blocks: RN-D (Request Node) and ICN (Interface Coherent Node). The RN-D block has inputs TXREQ, RXRSP, RXDAT, RXSNP, TXRSP, and TXDAT. The ICN block has inputs RXREQ, TXRSP, TXDAT, TXSNP, RXRSP, and RXDAT. The connections are: RN-D TXREQ connects to ICN RXREQ (REQ). RN-D RXRSP connects to ICN TXRSP (RSP). RN-D RXDAT connects to ICN TXDAT (DAT). RN-D RXSNP connects to ICN TXSNP (SNP(DVM)). RN-D TXRSP connects to ICN RXRSP (RSP). RN-D TXDAT connects to ICN RXDAT (DAT).](e0b88c9df72be0703415c24e0229e808_img.jpg)

Figure 13-6 RN-D interface diagram. The diagram shows two blocks: RN-D (Request Node) and ICN (Interface Coherent Node). The RN-D block has inputs TXREQ, RXRSP, RXDAT, RXSNP, TXRSP, and TXDAT. The ICN block has inputs RXREQ, TXRSP, TXDAT, TXSNP, RXRSP, and RXDAT. The connections are: RN-D TXREQ connects to ICN RXREQ (REQ). RN-D RXRSP connects to ICN TXRSP (RSP). RN-D RXDAT connects to ICN TXDAT (DAT). RN-D RXSNP connects to ICN TXSNP (SNP(DVM)). RN-D TXRSP connects to ICN RXRSP (RSP). RN-D TXDAT connects to ICN RXDAT (DAT).

Figure 13-6 RN-D interface

#### RN-I

The RN-I interface uses all channels, with the exception of the SNP channel, and is used by an IO coherent Request Node such as a GPU or IO bridge. A SNP channel is not required because an RN-I node does not include a hardware-coherent cache or TLB. Figure 13-7 shows the RN-I interface.

![](87cccf2f89ff92684bb91f25b9502f6d_img.jpg)

Figure 13-7 illustrates the RN-I interface, showing communication between the RN-I node and the ICN (Interconnect Node).

The RN-I node has five interfaces: TXREQ, RXRSP, RXDAT, TXRSP, and TXDAT.

The ICN node has five interfaces: RXREQ, TXRSP, TXDAT, RXRSP, and RXDAT.

Communication channels are defined as follows:

- TXREQ (RN-I) → REQ (ICN) → RXREQ (ICN)
- RXRSP (ICN) → RSP (RN-I) ← TXRSP (RN-I)
- RXDAT (ICN) → DAT (RN-I) ← TXDAT (RN-I)
- TXRSP (RN-I) → RSP (ICN) ← RXRSP (ICN)
- TXDAT (RN-I) → DAT (ICN) ← RXDAT (ICN)

Figure 13-7 RN-I interface

### 13.6.2 Subordinate Nodes

This section describes the Subordinate Node interfaces:

- SN-F and SN-I

#### SN-F and SN-I

The SN-F and SN-I interfaces are identical and use a RX request channel, a TX response channel, a TX data channel, and an RX data channel. The SN-F and SN-I receive request messages from the interconnect, and return response messages to the interconnect. However, the SN-F and SN-I receive different types of transactions. Figure 13-8 shows the SN-F and SN-I interface.

![](7230e3140be75a9ae37ab590b33f2b86_img.jpg)

Figure 13-8 illustrates the SN-F and SN-I interface, showing communication between the ICN (Interconnect Node) and the SN-F/SN-I node.

The ICN node has four interfaces: TXREQ, RXRSP, RXDAT, and TXDAT.

The SN-F/SN-I node has four interfaces: RXREQ, TXRSP, TXDAT, and RXDAT.

Communication channels are defined as follows:

- TXREQ (ICN) → REQ (SN-F/SN-I) ← RXREQ (SN-F/SN-I)
- RXRSP (SN-F/SN-I) → RSP (ICN) ← TXRSP (ICN)
- RXDAT (SN-F/SN-I) → DAT (ICN) ← TXDAT (ICN)
- TXDAT (ICN) → DAT (SN-F/SN-I) ← RXDAT (SN-F/SN-I)

Figure 13-8 SN-F and SN-I interface

## 13.7 Increasing inter-port bandwidth

The available bandwidth at a node interface can be increased in several ways. Two architectural methods permitted are detailed in the following sections:

- *Multiple interfaces*
- *Replicated channels on a single interface* on page 13-404

### 13.7.1 Multiple interfaces

The simplest method for a component to increase the available bandwidth is to have multiple interfaces. A complete interface can be duplicated. The number of times an interface on a node is duplicated is IMPLEMENTATION DEFINED.

Figure 13-9 shows an example of duplicated interfaces.

![Diagram showing two duplicated interfaces (Interface 1 and Interface 2) connected to a component labeled RN-F. Each interface has four pairs of bidirectional arrows representing communication channels: TXREQ/REQ, RXRSP/RSP, RXDAT/DAT, and RXSNP/SNP. The TXRSP/RSP and TXDAT/DAT pairs are also shown.](5f5f22f621ef476a230a175c793be37b_img.jpg)

Diagram showing two duplicated interfaces (Interface 1 and Interface 2) connected to a component labeled RN-F. Each interface has four pairs of bidirectional arrows representing communication channels: TXREQ/REQ, RXRSP/RSP, RXDAT/DAT, and RXSNP/SNP. The TXRSP/RSP and TXDAT/DAT pairs are also shown.

Figure 13-9 Multiple interface example

The main features of this method of increasing bandwidth across two interfaces are:

- Each interface has its own:
  - Node ID
  - TxnID pool
  - Set of **SACTIVE** signals
  - Set of **LINKACTIVE** signals
  - Set of **SYSCOREQ/SYSCOACK** signals
  - Set of optional broadcast control pins
- Each duplicate interface must be treated as an independent interface:
  - If one interface allocates the cache line, then another duplicate interface cannot deallocate that cache line.
  - When responding to a request, the Responder must send the response on the same interface as the one used by the request.
  - A snoop must be sent to the same interface that was used for the transaction that caused the allocation of a cache line.
- All channels must be replicated even when only a subset of the channels needs increased bandwidth.

#### Address stripping

This specification permits an optional optimization where a Request Node can specify the address stripping that it will use to select between multiple interfaces. This can be specified for any number of interfaces.

A Request Node is permitted to use address stripping to guide its requests to the appropriate interface without declaring the stripping algorithm being used.

A Home Node typically can filter snoopers based on a snoop filter. If the snoop filter is precise, it can track the Node ID of the Requester that cached the cache line and send a snoop for a subsequent request to the same cache line on a single interface. But a snoop filter that does not track precisely, or is sized to the number of components in the system instead of the number of Request Node interfaces, will not be able to isolate the single interface it needs to send the snoop on, unless it knows and uses the same address stripping algorithm as the Requester.

When a Request Node does not declare the stripping algorithm it is using, the snoop filters either need to be larger or the Home will have to send redundant snoopers. It is recommended that a Request Node that uses address stripping advertises the stripping algorithm so that the Home Nodes can make use of it.

The address stripping used by a Request Node can be specified by a hash function.

#### Hash function example

This section describes a suggested hash function to be used to distribute requests across multiple REQ interfaces. The same hash function can be used to distribute snoopers across multiple available SNP interfaces. The steps in generating the interface number are:

1. The cache line aligned input address is first filtered through a predefined Hash Mask. The most significant address bits that are not used must be set to all zero before filtering the address. In this example, the result of the filtering is Mask\_Result.
2. The individual bits of Mask\_Result are XORed to obtain the target interface.

Where the number of interfaces is a power of two:

- For 2 interfaces:  
   $\text{Interfaces}[0] = \text{Mask\_Result}[n-1] \wedge \text{Mask\_Result}[n-2] \dots \text{Mask\_Result}[7] \wedge \text{Mask\_Result}[6]$
- For 4 interfaces:  
   $\text{Interfaces}[1:0] = \text{Mask\_Result}[n-1:n-2] \wedge \text{Mask\_Result}[n-3:n-4] \dots \text{Mask\_Result}[9:8] \wedge \text{Mask\_Result}[7:6]$
- For 8 interfaces:  
   $\text{Interfaces}[2:0] = \text{Mask\_Result}[n-1:n-3] \wedge \text{Mask\_Result}[n-4:n-6] \dots \text{Mask\_Result}[11:9] \wedge \text{Mask\_Result}[8:6]$

This example does not cover the situation where the number of interfaces is not a power-of-two.

### 13.7.2 Replicated channels on a single interface

A more efficient method to increase the available interface bandwidth, rather than replicating a complete interface through more complex methods, is to selectively replicate the channels that require greater bandwidth.

Figure 13-10 shows an example of replicated channels.

![Diagram illustrating replicated channels on a single interface. The interface is labeled 'Single interface' and connects to 'RN-F'. The channels are grouped into Request (TXREQ0, TXREQ1, RXRSP0, RXRSP1) and Response (RXDAT0, RXDAT1, RXSNP0, RXSNP1, TXDAT0, TXDAT1) subchannels. The Request channels map to REQ0 and REQ1, and the Response channels map to RSP0, RSP1, DAT0, DAT1, and SNP0, SNP1.](994f97c824fb88904feeaff77f5fe98a_img.jpg)

Diagram illustrating replicated channels on a single interface. The interface is labeled 'Single interface' and connects to 'RN-F'. The channels are grouped into Request (TXREQ0, TXREQ1, RXRSP0, RXRSP1) and Response (RXDAT0, RXDAT1, RXSNP0, RXSNP1, TXDAT0, TXDAT1) subchannels. The Request channels map to REQ0 and REQ1, and the Response channels map to RSP0, RSP1, DAT0, DAT1, and SNP0, SNP1.

Figure 13-10 Replicated channels example

#### Features

The main features of this method of increasing available bandwidth are described in this section.

Each channel can be selectively replicated. There are no restrictions on which channels are replicated. Typically, replication of a channel is based on the expected bandwidth required on that channel. For example, in Figure 13-10, TXREQ is duplicated as TXREQ0, TXREQ1, whereas RXSNP is not duplicated and has only RXSNP0. The characteristics of the replicated channel interface are:

- All replicated DAT subchannels corresponding to a single DAT channel must be of the same width.
- The complete interface must use:
  - The same Node ID
  - A single TxnID pool
- Messages within a transaction can use any subchannel:
  - A response message does not need to use the same subchannel as the request. For example, Request on TXREQ0 can give a response on either RXRSP0 or RXRSP1.
  - Multiple response messages for a single request can come on any subchannel. For example, DBIDResp for a write transaction is received on RXRSP0 whereas the corresponding Comp can be received on RXRSP1.
- Like non-replicated channels, replicated channels do not provide any in-channel ordering guarantees.
- All link crediting is done on a subchannel basis.
  - Cannot use the credit for TXREQ0 to send the flit on TXREQ1.
  - Credits are required to be provided by the Receiver on all subchannels.
- Protocol credits are for the combined TXREQ channel.
- There is no support for powering down a subchannel individually.
- The two parts of a DVM snoop can come on either subchannel. Each part can be on a different subchannels.
- The number of subchannels on two connected interfaces must match.

- There must be only one set of **SACTIVE**, **LINKACTIVE** and **SYSCOREQ/SYSCOACK** signals, and optional broadcast control pins.
- Interface property **CCF\_Wrap\_Order** is not permitted to be set to True when the interface includes replicated DAT channels.

###### **Note**

When a channel has been replicated on an interface, it is implementation defined which of the subchannels is used for a transfer.

## 13.8 Channel interface signals

This section describes the channel interfaces. It contains the following sections:

- *Request, REQ, channel*
- *Response, RSP, channel on page 13-407*
- *Snoop, SNP, channel on page 13-408*
- *Data, DAT, channel on page 13-409*

### 13.8.1 Request, REQ, channel

Figure 13-11 shows the REQ channel interface pins, where R is the width of REQFLIT.

![Figure 13-11 REQ channel interface pins diagram. The diagram shows a Transmitter side with pins TXREQFLITPEND, TXREQFLITV, TXREQFLIT, and TXREQLCRDV, connected to a Receiver side with pins RXREQFLITPEND, RXREQFLITV, RXREQFLIT, and RXREQLCRDV. The connections are: TXREQFLITPEND to RXREQFLITPEND, TXREQFLITV to RXREQFLITV, TXREQFLIT to RXREQFLIT, and TXREQLCRDV to RXREQLCRDV.](269929141431809d957ba415c298d3a9_img.jpg)

Figure 13-11 REQ channel interface pins diagram. The diagram shows a Transmitter side with pins TXREQFLITPEND, TXREQFLITV, TXREQFLIT, and TXREQLCRDV, connected to a Receiver side with pins RXREQFLITPEND, RXREQFLITV, RXREQFLIT, and RXREQLCRDV. The connections are: TXREQFLITPEND to RXREQFLITPEND, TXREQFLITV to RXREQFLITV, TXREQFLIT to RXREQFLIT, and TXREQLCRDV to RXREQLCRDV.

Figure 13-11 REQ channel interface pins

Table 13-2 on page 13-406 shows the REQ channel interface signals.

Table 13-2 REQ channel interface signals

| Signal           | Description                                                                                                                                                         |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| REQFLITPEND      | Request Flit Pending. Early indication that a request flit might be transmitted in the following cycle. See <i>Flit level clock gating on page 14-447</i> .         |
| REQFLITV         | Request Flit Valid. The transmitter sets this signal HIGH to indicate when REQFLIT[(R-1):0] is valid.                                                               |
| REQFLIT[(R-1):0] | Request Flit. See <i>Request flit on page 13-410</i> for a description of the request flit format.                                                                  |
| REQLCRDV         | Request L-Credit Valid. The receiver sets this signal HIGH to return a request channel L-Credit to a transmitter. See <i>L-Credit flow control on page 14-445</i> . |

### 13.8.2 Response, RSP, channel

Figure 13-12 shows the RSP channel interface pins, where T is the width of **RSPFLIT**. The same interface is used for both inbound and outbound RSP channels.

![Figure 13-12 RSP channel interface pins diagram. The diagram shows a Transmitter block connected to a Receiver block. The Transmitter has pins: TXRSPFLITPEND, TXRSPFLITV, TXRSPFLIT, and TXRSPLCRDV. The Receiver has pins: RXRSPFLITPEND, RXRSPFLITV, RXRSPFLIT, and RXRSPLCRDV. The connections are: TXRSPFLITPEND to RXRSPFLITPEND; TXRSPFLITV to RXRSPFLITV; TXRSPFLIT to RXRSPFLIT; and TXRSPLCRDV to RXRSPLCRDV.](24766593465edcc91d2d6b3503cfe7ef_img.jpg)

Figure 13-12 RSP channel interface pins diagram. The diagram shows a Transmitter block connected to a Receiver block. The Transmitter has pins: TXRSPFLITPEND, TXRSPFLITV, TXRSPFLIT, and TXRSPLCRDV. The Receiver has pins: RXRSPFLITPEND, RXRSPFLITV, RXRSPFLIT, and RXRSPLCRDV. The connections are: TXRSPFLITPEND to RXRSPFLITPEND; TXRSPFLITV to RXRSPFLITV; TXRSPFLIT to RXRSPFLIT; and TXRSPLCRDV to RXRSPLCRDV.

Figure 13-12 RSP channel interface pins

Table 13-3 shows the RSP channel interface signals.

Table 13-3 RSP channel interface signals

| Signal                   | Description                                                                                                                                                          |
|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>RSPFLITPEND</b>       | Response Flit Pending. Early indication that a response flit might be transmitted in the following cycle. See <i>Flit level clock gating</i> on page 14-447.         |
| <b>RSPFLITV</b>          | Response Flit Valid. The transmitter sets this signal HIGH to indicate when <b>RSPFLIT</b> [(T-1):0] is valid.                                                       |
| <b>RSPFLIT</b> [(T-1):0] | Response Flit. See <i>Response flit</i> on page 13-412 for a description of the response flit format.                                                                |
| <b>RSPLCRDV</b>          | Response L-Credit Valid. The receiver sets this signal HIGH to return a response channel L-Credit to a transmitter. See <i>L-Credit flow control</i> on page 14-445. |

### 13.8.3 Snoop, SNP, channel

Figure 13-13 shows the SNP channel interface pins, where S is the width of SNPFILT.

![Figure 13-13: Diagram showing the SNP channel interface pins between a Transmitter and a Receiver. The Transmitter pins are TXSNPFLTPEND, TXSNPFLTIV, TXSNPFLT, and TXSNPLCRDV. The Receiver pins are RXSNPFLTPEND, RXSNPFLTIV, RXSNPFLT, and RXSNPLCRDV. Connections are shown between corresponding pins: TXSNPFLTPEND to RXSNPFLTPEND, TXSNPFLTIV to RXSNPFLTIV, TXSNPFLT to RXSNPFLT, and TXSNPLCRDV to RXSNPLCRDV.](8a2d93edfb1d006ad7909d6e55433cc4_img.jpg)

Figure 13-13: Diagram showing the SNP channel interface pins between a Transmitter and a Receiver. The Transmitter pins are TXSNPFLTPEND, TXSNPFLTIV, TXSNPFLT, and TXSNPLCRDV. The Receiver pins are RXSNPFLTPEND, RXSNPFLTIV, RXSNPFLT, and RXSNPLCRDV. Connections are shown between corresponding pins: TXSNPFLTPEND to RXSNPFLTPEND, TXSNPFLTIV to RXSNPFLTIV, TXSNPFLT to RXSNPFLT, and TXSNPLCRDV to RXSNPLCRDV.

Figure 13-13 SNP channel interface pins

Table 13-4 shows the SNP channel interface signals.

Table 13-4 SNP channel interface signals

| Signal          | Description                                                                                                                                                    |
|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SNPFLTPEND      | Snoop Flit Pending. Early indication that a snoop flit might be transmitted in the following cycle. See <i>Flit level clock gating</i> on page 14-447.         |
| SNPFLTIV        | Snoop Flit Valid. The transmitter sets this signal HIGH to indicate when SNPFLT[(S-1):0] is valid.                                                             |
| SNPFLT[(S-1):0] | Snoop Flit. See <i>Snoop flit</i> on page 13-413 for a description of the snoop flit format.                                                                   |
| SNPLCRDV        | Snoop L-Credit Valid. The receiver sets this signal HIGH to return a snoop channel L-Credit to a transmitter. See <i>L-Credit flow control</i> on page 14-445. |

### 13.8.4 Data, DAT, channel

Figure 13-14 shows the DAT channel interface pins, where D is the width of **DATFLIT**. The same interface is used for both inbound and outbound DAT channels.

![Figure 13-14 DAT channel interface pins diagram. The diagram shows a Transmitter block connected to a Receiver block. The Transmitter has pins: TXDATFLITPEND, TXDATFLITV, TXDATFLIT, and TXDATLCRDV. The Receiver has pins: RXDATFLITPEND, RXDATFLITV, RXDATFLIT, and RXDATLCRDV. The connections are: TXDATFLITPEND connects to DATFLITPEND, which connects to RXDATFLITPEND. TXDATFLITV connects to DATFLITV, which connects to RXDATFLITV. TXDATFLIT connects to DATFLIT[(D-1):0], which connects to RXDATFLIT. TXDATLCRDV connects to DATLCRDV, which connects to RXDATLCRDV.](8cba48e6e50174d5d039418a5fc7ef77_img.jpg)

Figure 13-14 DAT channel interface pins diagram. The diagram shows a Transmitter block connected to a Receiver block. The Transmitter has pins: TXDATFLITPEND, TXDATFLITV, TXDATFLIT, and TXDATLCRDV. The Receiver has pins: RXDATFLITPEND, RXDATFLITV, RXDATFLIT, and RXDATLCRDV. The connections are: TXDATFLITPEND connects to DATFLITPEND, which connects to RXDATFLITPEND. TXDATFLITV connects to DATFLITV, which connects to RXDATFLITV. TXDATFLIT connects to DATFLIT[(D-1):0], which connects to RXDATFLIT. TXDATLCRDV connects to DATLCRDV, which connects to RXDATLCRDV.

Figure 13-14 DAT channel interface pins

Table 13-5 shows the DAT channel interface signals.

Table 13-5 DAT channel interface signals

| Signal                  | Description                                                                                                                                                  |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>DATFLITPEND</b>      | Data Flit Pending. Early indication that a data flit might be transmitted in the following cycle. See <i>Flit level clock gating</i> on page 14-447.         |
| <b>DATFLITV</b>         | Data Flit Valid. The transmitter sets this signal HIGH to indicate when <b>DATFLIT[(D-1):0]</b> is valid.                                                    |
| <b>DATFLIT[(D-1):0]</b> | Data Flit. See <i>Data flit</i> on page 13-414 for a description of the data flit format.                                                                    |
| <b>DATLCRDV</b>         | Data L-Credit Valid. The receiver sets this signal HIGH to return a data channel L-Credit to a transmitter. See <i>L-Credit flow control</i> on page 14-445. |

## 13.9 Flit packet definitions

This section defines the flit format. See:

- [Request\\_flit](#)
- [Response\\_flit on page 13-412](#)
- [Snoop\\_flit on page 13-413](#)
- [Data\\_flit on page 13-414](#)

### 13.9.1 Request flit

Table 13-6 shows the Request flit format in a REQ channel packet starting at bit zero. The following key is used:

SBZ Should Be Zero

Table 13-6 Request flit format

| REQFLIT[(R-1):0] format                      |                |                                                  |
|----------------------------------------------|----------------|--------------------------------------------------|
| Field                                        | Field width    | Comments                                         |
| QoS                                          | 4              | -                                                |
| TgtID                                        | 7 to 11        | Width determined by NodeID_Width                 |
| SrcID                                        | 7 to 11        | Width determined by NodeID_Width                 |
| TxnID                                        | 12             | -                                                |
| ReturnNID                                    | 7 to 11        | Used for DMT                                     |
| StashNID                                     |                | Used in Stash transactions                       |
| {(NodeID_Width - 7)*b0,<br>SLCRepHint[6:0]}  |                | SBZ<br>Used in cache line replacement algorithms |
| StashNIDValid                                | 1              | Used in Stash transactions                       |
| Endian                                       |                | Used in Atomic transactions                      |
| Deep                                         |                | Used in CleanSharedPersist* transactions         |
| ReturnTxnID[11:0]                            | 12             | Used for DMT                                     |
| {6*b0,<br>StashLPIDValid,<br>StashLPID[4:0]} |                | SBZ<br>Used in Stash transactions                |
| Opcode                                       | 7              | -                                                |
| Size                                         | 3              | -                                                |
| Addr                                         | RAW = 44 to 52 | Width determined by Req_Addr_Width (RAW)         |
| NS                                           | 1              | -                                                |
| LikelyShared                                 | 1              | -                                                |
| AllowRetry                                   | 1              | -                                                |
| Order                                        | 2              | -                                                |
| PCrdType                                     | 4              | -                                                |
| MemAttr                                      | 4              | -                                                |

Table 13-6 Request flit format (continued)

| REQFLIT[R-1:0] format              |                                                     |                                      |
|------------------------------------|-----------------------------------------------------|--------------------------------------|
| Field                              | Field width                                         | Comments                             |
| SnpAttr                            | 1                                                   | -                                    |
| DoDWT                              |                                                     | Used for DWT                         |
| {3'b0, LPID[4:0]}<br>PGroupID[7:0] | 8                                                   | SBZ                                  |
| StashGroupID[7:0]                  |                                                     | Used in Persistent CMO transactions  |
| TagGroupID[7:0]                    |                                                     | Used in the StashOnceSep transaction |
| TagGroupID[7:0]                    |                                                     | Used for Memory Tagging              |
| Excl                               | 1                                                   | Used in Exclusive transactions       |
| SnoopMe                            |                                                     | Used in Atomic transactions          |
| ExpCompAck                         | 1                                                   | -                                    |
| TagOp                              | 2                                                   | -                                    |
| TraceTag                           | 1                                                   | -                                    |
| MPAM                               | M = 0                                               | No MPAM bus                          |
|                                    | M = 11                                              | -                                    |
| RSVDC                              | Y = 0                                               | No RSVDC bus                         |
|                                    | Y = 4, 8, 12, 16,<br>24, 32                         | -                                    |
| Total                              | R=(87 + RAW +<br>M + Y) to<br>(99 + RAW + M +<br>Y) |                                      |

### 13.9.2 Response flit

Table 13-7 shows the Response flit format in a RSP channel packet starting at bit zero,

Table 13-7 Response flit format

| RSPFLIT[(T-1):0] format   |              |                                  |
|---------------------------|--------------|----------------------------------|
| Field                     | Field width  | Comments                         |
| QoS                       | 4            | -                                |
| TgtID                     | 7 to 11      | Width determined by NodeID_Width |
| SrcID                     | 7 to 11      | Width determined by NodeID_Width |
| TxnID                     | 12           | -                                |
| Opcode                    | 5            | -                                |
| RespErr                   | 2            | -                                |
| Resp                      | 3            | -                                |
| FwdState[2:0]             | 3            | Used for DCT                     |
| DataPull[2:0]             |              | Used in Stash transactions       |
| CBusy                     | 3            | -                                |
| DBID[11:0]                | 12           | -                                |
| {4'b0, PGroupID[7:0]}     |              | SBZ                              |
| {4'b0, StashGroupID[7:0]} |              | SBZ                              |
| {4'b0, TagGroupID[7:0]}   |              | SBZ                              |
| PCrdType                  | 4            | -                                |
| TagOp                     | 2            | -                                |
| TraceTag                  | 1            | -                                |
| Total                     | T = 65 to 73 | -                                |

### 13.9.3 Snoop flit

Table 13-8 shows the Snoop flit format in a SNP channel packet starting at bit zero.

Table 13-8 Snoop flit format

| SNPFLIT[(S-1):0] format                                                                   |                                     |                                                                                                                    |
|-------------------------------------------------------------------------------------------|-------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| Field                                                                                     | Field width                         | Comments                                                                                                           |
| QoS                                                                                       | 4                                   | -                                                                                                                  |
| SrcID                                                                                     | 7 to 11                             | Width determined by NodeID_Width                                                                                   |
| TxnID                                                                                     | 12                                  | -                                                                                                                  |
| FwdNID                                                                                    | 7 to 11                             | Width determined by NodeID_Width                                                                                   |
| FwdTxnID[11:0]<br>{6'b0,<br>StashLPIDValid,<br>StashLPID[4:0]}<br>{4'b0,<br>VMIDExt[7:0]} | 12                                  | Used for DCT<br>SBZ<br>Used in Stash transactions<br>Used in Stash transactions<br>SBZ<br>Used in DVM transactions |
| Opcode                                                                                    | 5                                   | -                                                                                                                  |
| Addr                                                                                      | SAW = 41 to 49                      | Req_Addr_Width - 3                                                                                                 |
| NS                                                                                        | 1                                   | -                                                                                                                  |
| DoNotGoToSD                                                                               | 1                                   | -                                                                                                                  |
| RetToSrc                                                                                  | 1                                   | -                                                                                                                  |
| TraceTag                                                                                  | 1                                   | -                                                                                                                  |
| MPAM                                                                                      | M = 0<br>M = 11                     | No MPAM bus<br>-                                                                                                   |
| Total                                                                                     | S = 51 + SAW + M to<br>59 + SAW + M | -                                                                                                                  |

### 13.9.4 Data flit

Table 13-9 shows the Data flit format in a DAT channel packet starting at bit zero.

The number of data flits required is dependent on the number of data bytes, and the data bus width. See *Data packetization* on page 2-136.

The data channel interface supports a 128-bit, 256-bit, and 512-bit data bus width. There are three data flit formats defined, one for each of the three data bus widths supported at the data channel interface.

*DataCheck* (DC) field width is either zero or equal to the width of the Data field divided by 8.

*Poisson* (P) field width is either zero or equal to the width of the Data field divided by 64.

Table 13-9 Data flit fields

| DATFLIT[D-1:0] format                                                   |                                   |                                                                                                 |
|-------------------------------------------------------------------------|-----------------------------------|-------------------------------------------------------------------------------------------------|
| Field                                                                   | Field Width                       | Comments                                                                                        |
| QoS                                                                     | 4                                 | -                                                                                               |
| TgtID                                                                   | 7 to 11                           | Width determined by NodeID Width                                                                |
| SrcID                                                                   | 7 to 11                           | Width determined by NodeID Width                                                                |
| TxnID                                                                   | 12                                | -                                                                                               |
| HomeNID                                                                 | 7 to 11                           | Width determined by NodeID Width                                                                |
| Opcode                                                                  | 4                                 | -                                                                                               |
| RespErr                                                                 | 2                                 | -                                                                                               |
| Resp                                                                    | 3                                 | -                                                                                               |
| {1'b0,<br>FwdState[2:0]}<br>{1'b0,<br>DataPull[2:0]}<br>DataSource[3:0] | 4                                 | SBZ<br>Used for DCT<br>SBZ<br>Used in Stash transactions<br>Indicates Data source in a response |
| CBusy                                                                   | 3                                 | -                                                                                               |
| DBID[11:0]                                                              | 12                                | -                                                                                               |
| CCID                                                                    | 2                                 | -                                                                                               |
| DataID                                                                  | 2                                 | -                                                                                               |
| TagOp                                                                   | 2                                 | -                                                                                               |
| Tag                                                                     | DW/32 = 4, 8, 16                  | -                                                                                               |
| TU                                                                      | DW/128 = 1, 2, 4                  | -                                                                                               |
| TraceTag                                                                | 1                                 | -                                                                                               |
| RSVDC                                                                   | Y = 0<br>Y = 4, 8, 12, 16, 24, 32 | No RSVDC bus                                                                                    |
| BE                                                                      | DW/8 = 16, 32, 64                 | -                                                                                               |
| Data                                                                    | DW = 128, 256, 512                | DW = Data bus width                                                                             |

Table 13-9 Data filt fields (continued)

| DATFLIT[D-1:0] format |                               |                   |
|-----------------------|-------------------------------|-------------------|
| Field                 | Field Width                   | Comments          |
| DataCheck (DC)        | 0 or DW/8 = 16, 32, 64        | -                 |
| Poison (P)            | 0 or DW/64 = 2, 4, 8          | -                 |
| Total                 | D = (221 to 233) + Y + DC + P | DW = 128 bit Data |
|                       | D = (370 to 382) + Y + DC + P | DW = 256 bit Data |
|                       | D = (668 to 680) + Y + DC + P | DW = 512 bit Data |

## 13.10 Protocol flit fields

A Protocol flit is identified by a non-zero value in the opcode field. All the flit fields defined in this section are applicable for a Protocol flit. The following sections describe the encoding of the Protocol flit fields:

- *Target Identifier, TgtID* on page 13-417
- *Source Identifier, SrcID* on page 13-417
- *Home Node Identifier, HomeNID* on page 13-417
- *Return Node Identifier, ReturnNID* on page 13-417
- *Forward Node Identifier, FwdNID* on page 13-417
- *Logical Processor Identifier, LPID* on page 13-418
- *Persistence Group Identifier, PGroupID* on page 13-418
- *Stash Node Identifier, StashNID* on page 13-418
- *Stash Node Identifier Valid, StashNIDValid* on page 13-419
- *Stash Logical Processor Identifier, StashLPID* on page 13-419
- *Stash Logical Processor Identifier Valid, StashLPIDValid* on page 13-419
- *Stash Group Identifier, StashGroupID* on page 13-419
- *Transaction Identifier, TxnID* on page 13-420
- *Return Transaction Identifier, ReturnTxnID* on page 13-420
- *Forwarding Transaction Identifier, FwdTxnID* on page 13-420
- *Data Buffer Identifier, DBID* on page 13-420
- *Channel opcodes, Opcode* on page 13-421
- *Deep persistence, Deep* on page 13-426
- *Address, Addr* on page 13-427
- *Non-secure, NS* on page 13-427
- *Size of transaction data, Size* on page 13-427
- *Memory Attribute, MemAttr* on page 13-429
- *Snoop Attribute, SnpAttr* on page 13-429
- *Do Direct Write Transfer, DoDWT* on page 13-430
- *Likely Shared, LikelyShared* on page 13-430
- *Ordering requirements, Order* on page 13-430
- *Exclusive, Excl* on page 13-432
- *Endian* on page 13-432
- *Allow Retry, AllowRetry* on page 13-432
- *Expect Completion Acknowledge, ExpCompAck* on page 13-433
- *SnoopMe* on page 13-433
- *Return to Source, RetToSrc* on page 13-433
- *Data Pull, DataPull* on page 13-433
- *Do not transition to SD state, DoNotGoToSD* on page 13-434
- *Quality of Service priority level, QoS* on page 13-434
- *Protocol Credit Type, PCrdType* on page 13-434
- *Tag Operation, TagOp* on page 13-435
- *Tag* on page 13-435
- *Tag Update, TU* on page 13-435
- *Tag Group Identifier, TagGroupID* on page 13-435
- *Trace Tag, TraceTag* on page 13-436
- *Memory System Performance Resource Partitioning and Monitoring, MPAM* on page 13-436
- *Virtual Machine Identifier Extension, VMIDExt* on page 13-436
- *Response status, Resp* on page 13-436
- *Forward State, FwdState* on page 13-438
- *Completer Busy, CBusy* on page 13-438
- *Response Error, RespErr* on page 13-439

- *Data payload, Data on page 13-439*
- *Critical Chunk Identifier, CCID on page 13-439*
- *Data Identifier, DataID on page 13-440*
- *Byte Enable, BE on page 13-440*
- *Data check, DataCheck on page 13-440*
- *Poison on page 13-440*
- *Data source, DataSource on page 13-441*
- *System Level Caches Replacement Hint, SLCRepHint on page 13-441*
- *Reserved for Customer Use, RSVDC on page 13-441*

### 13.10.1 Target Identifier, TgtID

This field is the Node ID of the component to which the message is targeted. This is used by the interconnect to determine the port to which the message is sent. See *Details of transaction identifier fields* on page 2-87.

### 13.10.2 Source Identifier, SrcID

This field is the Node ID of the component from which the message is sent. This is used by the interconnect to determine the port from which the message has been sent. See *Details of transaction identifier fields* on page 2-87.

### 13.10.3 Home Node Identifier, HomeNID

This field is associated with the original request. The Requester uses the value in this field to determine the TgtID of the CompAck to be sent in response to CompData. See *Details of transaction identifier fields* on page 2-87.

Applicable in CompData and DataSepResp.

Inapplicable and must be zero in all other Data messages.

### 13.10.4 Return Node Identifier, ReturnNID

This field identifies the node to which the Subordinate sends a CompData response, or a DataSepResp response, or a Persist response. The value can be either the NID of Home or the Requester that originated the transaction. See *Details of transaction identifier fields* on page 2-87.

Applicable from Home to Subordinate in ReadNoSnp, ReadNoSnpSep, CleanSharedPersistSep, WriteNoSnp, Combined Write, and Atomic requests.

Inapplicable and must be zero for all other requests. For Stash requests, the same bits in the packet are used for StashNID.

### 13.10.5 Forward Node Identifier, FwdNID

This field identifies the Requester to which the CompData response can be forwarded. The value must be the NID of the Requester that initiated the transaction. See *Details of transaction identifier fields* on page 2-87.

Applicable in Forward-type snoops.

Inapplicable and must be zero in all other Snoop requests, except range-based TLBI DVM operations.

In range-based TLBI DVM operations, the bits in the field are used for DVM payload.

###### 13.10.6 Logical Processor Identifier, LPID

This field is used in conjunction with the SrcID to uniquely identify the logical processor that generated the request. See *Logical Processor Identifier* on page 2-113.

Applicable in the following requests:

- ReadNoSnp for Exclusive, Non-snoopable, Non-cacheable, or Device access.
- WriteNoSnp for Exclusive, Non-snoopable, Non-cacheable, or Device access.
- ReadClean, ReadNotSharedDirty, ReadShared, and ReadPreferUnique for Exclusive Access.
- CleanUnique and MakeReadUnique for Exclusive Access.

In requests, when applicable, the same bits in the packet are used for TagGroupID, PGroupID and StashGroupID.

#### 13.10.7 Persistence Group Identifier, PGroupID

This field is used by a Requester to process different sets of CleanSharedPersistSep transactions by grouping them together and identifying each using PGroupID.

Applicable in the CleanSharedPersistSep and Write\*CleanShPerSep requests and the Persist and CompPersist responses.

Inapplicable and must be set to zero in all other requests and responses.

In requests, when applicable, the same bits in the packet are used for LPID, TagGroupID, and StashGroupID.

In responses, when applicable, the same bits in the packet are used for DBID, TagGroupID, and StashGroupID.

#### 13.10.8 Stash Node Identifier, StashNID

This field identifies the target of the Stash request. Provides a valid stash target value when the corresponding StashNIDValid bit is asserted. See *Stash target identifiers* on page 7-299.

Applicable in Stash requests.

Inapplicable and must be zero for all other requests. For ReadNoSnp and ReadNoSnpSep requests, the same bits in the packet are used for ReturnNID.

#### 13.10.9 Stash Node Identifier Valid, StashNIDValid

This field indicates if StashNID field has a valid value. See *Stash target identifiers* on page 7-299.

Applicable in Stash requests, inapplicable and must be set to zero in all other requests.

Table 13-10 shows the StashNIDValid value encoding.

Table 13-10 StashNIDValid value encoding

| StashNIDValid | Description                                                   |
|---------------|---------------------------------------------------------------|
| 0             | StashNID field value is inapplicable and must be set to zero. |
| 1             | The StashNID field in the Request has a valid Stash target.   |

For permitted combinations of StashNIDValid and StashLPIDValid see Table 7-3 on page 7-300.

#### 13.10.10 Stash Logical Processor Identifier, StashLPID

This field provides a valid Logical Processor target value within the Request Node specified by StashNID. See *Stash target identifiers* on page 7-299.

Applicable in Stash requests and Stash type Snoop requests.

Inapplicable and must be zero for all other requests. For ReadNoSnp requests the same bits in the packet are used for ReturnTxnID.

Inapplicable and must be zero for all other snoop requests. For Forwarding snoop requests the same bits in the packet are used for FwdTxnID and for SnpDVMOp snoop requests the same bits in the packet are used for VMIDExt.

#### 13.10.11 Stash Logical Processor Identifier Valid, StashLPIDValid

This field indicates if the StashLPID field has a valid value. See *Stash target identifiers* on page 7-299.

Applicable in Stash requests and Stash snoop requests, inapplicable and must be set to zero in all other requests.

Table 13-11 shows the StashLPIDValid value encoding.

Table 13-11 StashLPIDValid value encoding

| StashLPIDValid | Description                                                    |
|----------------|----------------------------------------------------------------|
| 0              | StashLPID field value is inapplicable and must be set to zero. |
| 1              | The StashLPID field in the Request has a valid Stash target.   |

For permitted combinations of StashLPIDValid and StashNIDValid see Table 7-3 on page 7-300.

#### 13.10.12 Stash Group Identifier, StashGroupID

This field is used by a Requester to process different sets of StashOnceSep transactions by grouping them together and identifying each using StashGroupID.

Applicable only in the StashOnceSep request and StashDone response.

Inapplicable and must be set to zero in all other requests and responses.

In requests, when applicable, the same bits in the packet are used for LPID, TagGroupID, and PGroupID.

In responses, when applicable, the same bits in the packet are used for DBID, TagGroupID and PGroupID.

#### 13.10.13 Transaction Identifier, TxnID

This field provides the transaction identifier of the message. When there are multiple outstanding transactions from a given source node they will each use a unique transaction ID. See [Details of transaction identifier fields on page 2-87.](#)

The TxnID in a link flit must be zero.

#### 13.10.14 Return Transaction Identifier, ReturnTxnID

This field identifies the value the Subordinate must use in the TxnID field of the CompData, and DataSepResp response. It can be either the TxnID generated by Home for this transaction or the TxnID in the Request packet from the Requester that originated the transaction. See [Details of transaction identifier fields on page 2-87.](#)

Applicable only in ReadNoSnp, ReadNoSnpSep, WriteNoSnp, Combined Write, and Atomic requests from Home to Subordinate.

Inapplicable and must be set to zero for all other requests. For Stash requests, the same bits in the packet are used for StashLPID.

#### 13.10.15 Forwarding Transaction Identifier, FwdTxnID

This field identifies the TxnID field of the original Request associated with the Snoop transaction. See [Details of transaction identifier fields on page 2-87.](#)

Applicable in Forward-type snoops.

Inapplicable and must be set to zero in all other Snoop requests. For Stash snoops, the same bits in the packet are used for StashLPID and for SnpDVMOp snoops the same bits in the packet are used for VMIDExt.

#### 13.10.16 Data Buffer Identifier, DBID

The value in this field in the response packet from a Completer is used in the TxnID field for CompAck or WriteData sent from the Requester.

In Snoop responses with Data Pull, the DBID value indicates the value to be used in the TxnID field of Data Pull response messages. See [Details of transaction identifier fields on page 2-87.](#)

In responses, when applicable, the same bits in the packet are used for PGroupID, StashGroupID, and TagGroupID.

### 13.10.17 Channel opcodes, Opcode

This field specifies the operation to be carried out. The Opcode encodings are specific to each channel. See:

- *REQ channel opcodes*
- *RSP channel opcodes* on page 13-424
- *SNP channel opcodes* on page 13-425
- *DAT channel opcodes* on page 13-426

#### REQ channel opcodes

Table 13-12 shows the opcodes for the Request channel.

Table 13-12 REQ channel opcodes

| Request command |                       |                              |
|-----------------|-----------------------|------------------------------|
| Opcode[5:0]     | Opcode[6] = 0         | Opcode[6] = 1                |
| 0x00            | ReqLCrdReturn         | Reserved                     |
| 0x01            | ReadShared            | MakeReadUnique               |
| 0x02            | ReadClean             | WriteEvictOrEvict            |
| 0x03            | ReadOnce              | WriteUniqueZero              |
| 0x04            | ReadNoSnp             | WriteNoSnpZero               |
| 0x05            | PCrdReturn            | Reserved                     |
| 0x06            | Reserved              | Reserved                     |
| 0x07            | ReadUnique            | StashOnceSepShared           |
| 0x08            | CleanShared           | StashOnceSepUnique           |
| 0x09            | CleanInvalid          | Reserved                     |
| 0x0A            | MakeInvalid           | Reserved                     |
| 0x0B            | CleanUnique           | Reserved                     |
| 0x0C            | MakeUnique            | ReadPreferUnique             |
| 0x0D            | Evict                 | Reserved                     |
| 0x0E            | Reserved              | Reserved                     |
| 0x0F            | Reserved              | Reserved                     |
| 0x10            | Reserved              | WriteNoSnpFullCleanSh        |
| 0x11            | ReadNoSnpSep          | WriteNoSnpFullCleanInv       |
| 0x12            | Reserved              | WriteNoSnpFullCleanShPerSep  |
| 0x13            | CleanSharedPersistSep | Reserved                     |
| 0x14            | DVMOp                 | WriteUniqueFullCleanSh       |
| 0x15            | WriteEvictFull        | Reserved                     |
| 0x16            | Reserved              | WriteUniqueFullCleanShPerSep |
| 0x17            | WriteCleanFull        | Reserved                     |

Table 13-12 REQ channel opcodes (continued)

| Request command |                      |                             |
|-----------------|----------------------|-----------------------------|
| Opcode[5:0]     | Opcode[6] = 0        | Opcode[6] = 1               |
| 0x18            | WriteUniquePtl       | WriteBackFullCleanSh        |
| 0x19            | WriteUniqueFull      | WriteBackFullCleanInv       |
| 0x1A            | WriteBackPtl         | WriteBackFullCleanShPerSep  |
| 0x1B            | WriteBackFull        | Reserved                    |
| 0x1C            | WriteNoSnpPtl        | WriteCleanFullCleanSh       |
| 0x1D            | WriteNoSnpFull       | Reserved                    |
| 0x1E            | Reserved             | WriteCleanFullCleanShPerSep |
| 0x1F            | Reserved             | Reserved                    |
| 0x20            | WriteUniqueFullStash | WriteNoSnpPtlCleanSh        |
| 0x21            | WriteUniquePtlStash  | WriteNoSnpPtlCleanInv       |
| 0x22            | StashOnceShared      | WriteNoSnpPtlCleanShPerSep  |
| 0x23            | StashOnceUnique      | Reserved                    |
| 0x24            | ReadOnceCleanInvalid | WriteUniquePtlCleanSh       |
| 0x25            | ReadOnceMakeInvalid  | Reserved                    |
| 0x26            | ReadNotSharedDirty   | WriteUniquePtlCleanShPerSep |
| 0x27            | CleanSharedPersist   | Reserved                    |
| 0x28 - 0x2F     | AtomicStore          | Reserved                    |
| 0x30 - 0x37     | AtomicLoad           | Reserved                    |
| 0x38            | AtomicSwap           | Reserved                    |
| 0x39            | AtomicCompare        | Reserved                    |
| 0x3A            | PrefetchTgt          | Reserved                    |
| 0x3B - 0x3F     | Reserved             | Reserved                    |

Note

Prior to CHI Issue E, the following requests were not supported:

- ReadPreferUnique
- MakeReadUnique
- StashOnceSep
- WriteEvictOrEvict
- WriteNoSnpZero
- WriteUniqueZero
- Combined Write

Table 13-13 shows the sub-opcodes for AtomicStore and AtomicLoad.

Table 13-13 Sub-codes for AtomicStore and AtomicLoad

| Opcode[5:3] |            | Opcode[2:0] | Operation |
|-------------|------------|-------------|-----------|
| AtomicStore | AtomicLoad |             |           |
| 101         | 110        | 000         | ADD       |
|             |            | 001         | CLR       |
|             |            | 010         | EOR       |
|             |            | 011         | SET       |
|             |            | 100         | SMAX      |
|             |            | 101         | SMIN      |
|             |            | 110         | UMAX      |
|             |            | 111         | UMIN      |

## RSP channel opcodes

Table 13-14 shows the opcodes for the Response channel.

Table 13-14 RSP channel opcodes encoding

| Opcode[4:0] | Response       |
|-------------|----------------|
| 0x0         | RespLCrdReturn |
| 0x1         | SnpResp        |
| 0x2         | CompAck        |
| 0x3         | RetryAck       |
| 0x4         | Comp           |
| 0x5         | CompDBIDResp   |
| 0x6         | DBIDResp       |
| 0x7         | PCrdGrant      |
| 0x8         | ReadReceipt    |
| 0x9         | SnpRespFwded   |
| 0xA         | TagMatch       |
| 0xB         | RespSepData    |
| 0xC         | Persist        |
| 0xD         | CompPersist    |
| 0xE         | DBIDRespOrd    |
| 0xF         | Reserved       |
| 0x10        | StashDone      |
| 0x11        | CompStashDone  |
| 0x12-0x13   | Reserved       |
| 0x14        | CompCMO        |
| 0x15-0x1F   | Reserved       |

### Note

Prior to CHI Issue E, the following responses were not supported:

- DBIDRespOrd
- TagMatch
- StashDone
- CompStashDone
- CompCMO

## SNP channel opcodes

Table 13-15 shows the opcodes for the Snoop channel.

Table 13-15 SNP channel opcodes encoding

| Opcode[4:0] | Snoop command         |
|-------------|-----------------------|
| 0x00        | SnplCrdReturn         |
| 0x01        | SnplShared            |
| 0x02        | SnplClean             |
| 0x03        | SnplOnce              |
| 0x04        | SnplNotSharedDirty    |
| 0x05        | SnplUniqueStash       |
| 0x06        | SnplMakeInvalidStash  |
| 0x07        | SnplUnique            |
| 0x08        | SnplCleanShared       |
| 0x09        | SnplCleanInvalid      |
| 0x0A        | SnplMakeInvalid       |
| 0x0B        | SnplStashUnique       |
| 0x0C        | SnplStashShared       |
| 0x0D        | SnplDVMOp             |
| 0x0E - 0x0F | Reserved              |
| 0x10        | SnplQuery             |
| 0x11        | SnplSharedFwd         |
| 0x12        | SnplCleanFwd          |
| 0x13        | SnplOnceFwd           |
| 0x14        | SnplNotSharedDirtyFwd |
| 0x15        | SnplPreferUnique      |
| 0x16        | SnplPreferUniqueFwd   |
| 0x17        | SnplUniqueFwd         |
| 0x18 - 0x1F | Reserved              |

### Note

Prior to CHI Issue E, the following Snoop requests were not supported:

- SnplPreferUnique
- SnplPreferUniqueFwd
- SnplQuery

## DAT channel opcodes

Table 13-16 shows the opcodes for the Data channel.

Table 13-16 DAT channel opcodes encoding

| Opcode[3:0] | Data command      |
|-------------|-------------------|
| 0x0         | DataLCrdReturn    |
| 0x1         | SnpRespData       |
| 0x2         | CopyBackWrData    |
| 0x3         | NonCopyBackWrData |
| 0x4         | CompData          |
| 0x5         | SnpRespDataPtl    |
| 0x6         | SnpRespDataFwded  |
| 0x7         | WriteDataCancel   |
| 0x8 - 0xA   | Reserved          |
| 0xB         | DataSepResp       |
| 0xC         | NCBWrDataCompAck  |
| 0xD-0xF     | Reserved          |

### 13.10.18 Deep persistence, Deep

This field is used by the Requester to indicate that the Persist response must not be sent until all earlier writes are written to the final destination.

Applicable in the CleanSharedPersist\* request and Combined Write request with CleanSharedPersistSep.

Inapplicable and must be set to zero in all other requests.

When Deep is deasserted:

- The Completer must send Persist response after all the earlier writes have reached the PoP.
  - The PoP is the point at which it is guaranteed that sufficient time is available to make the data persistent after loss of power.

When Deep is asserted:

- The Completer must send the Persist response only after all earlier writes are written to the final destination, not just the PoP.
  - The final destination is the point at which no time is required to make the data persistent after the loss of power, thus preserving data even when battery failure occurs.

### 13.10.19 Address, Addr

This field specifies the address associated with the message.

This specification supports a PA of 44 to 52 bits. The address is carried in Addr field in the REQ and SNP channel.

The width of the field is defined by the REQ\_ADDR\_WIDTH parameter. The field width is the same value of the parameter in REQ channel, Addr[(43-51):0], and is three less than the parameter value in the SNP channel, Addr[(43-51):3].

The Addr field is utilized in the REQ and SNP channels in the following manner.

- For Read, PrefetchTgt, Dataless, Write, and Atomic transactions, the Addr field includes the address of the memory location being accessed. This starts with Addr[0] mapped to bit zero of Addr.
- For a snoop request, except SnpDVMOp, the Addr field includes the address of the location being snooped. This starts with Addr[3] mapped to bit zero of Addr.
  - Addr[(43-51):6] is the cache line address. It is sufficient to uniquely identify the cache line to be accessed by the snoop.
  - Addr[5:4] identifies the critical chunk being accessed by the transaction. See *Critical Chunk Identifier* on page 2-139. It is recommended that the snooped cache returns the data in wrap order with the critical chunk returned first.

**Note**

Addr[3] in the REQ channel, that is Addr[0] in SNP channel, is supplied but is not used by a snoop request.

- For a DVMOp and SnpDVMOp request, the Addr field is used to carry information related to a DVM operation. See *Chapter 8 DVM Operations*.
- The Addr value is not used for PCrdReturn transaction and must be set to zero.

### 13.10.20 Non-secure, NS

This field indicates a Non-secure access or a Secure access. See *Non-secure bit* on page 2-125.

Table 13-17 shows the NS field value encoding.

Table 13-17 NS value encoding

| NS | Description       |
|----|-------------------|
| 0  | Secure access     |
| 1  | Non-secure access |

### 13.10.21 Size of transaction data, Size

This field specifies the size of the data associated with the transaction. See *Data size* on page 2-134.

Table 13-18 shows the Size field value encodings.

Table 13-18 Size field value encodings

| Size[2:0] | Bytes |
|-----------|-------|
| 0b000     | 1     |
| 0b001     | 2     |
| 0b010     | 4     |

Table 13-18 Size field value encodings (continued)

| Size[2:0] | Bytes    |
|-----------|----------|
| 0b011     | 8        |
| 0b100     | 16       |
| 0b101     | 32       |
| 0b110     | 64       |
| 0b111     | Reserved |

### 13.10.22 Memory Attribute, MemAttr

This field is associated with the transaction.

Table 13-19 shows the MemAttr value encodings.

Table 13-19 MemAttr value encodings

| MemAttr[3:0] | Description                                                                                                                                                                                                                                 |
|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [3]          | Allocate hint bit. Indicates whether or not the cache receiving the transaction is recommended to allocate the transaction:<br>0 Recommend that it does not allocate.<br>1 Recommend that it allocates.                                     |
| [2]          | Cacheable bit. Indicates a Cacheable transaction for which the cache, when present, must be looked up in servicing the transaction:<br>0 Non-cacheable. Looking up a cache is not required.<br>1 Cacheable. Looking up a cache is required. |
| [1]          | Device bit. Indicates if the memory type associated with the transaction is Device or Normal:<br>0 Normal memory type.<br>1 Device memory type.                                                                                             |
| [0]          | Early Write Acknowledge (EWA) bit. Specifies the EWA status for the transaction:<br>0 Early Write Acknowledge not permitted.<br>1 Early Write Acknowledge permitted.                                                                        |

See [Memory Attributes](#) on page 2-126.

### 13.10.23 Snoop Attribute, SnpAttr

This field specifies the snoop attribute associated with the transaction.

Table 13-20 shows the SnpAttr value encoding.

Table 13-20 SnpAttr value encoding

| SnpAttr | Description   |
|---------|---------------|
| 0       | Non-snoopable |
| 1       | Snoopable     |

See [Snoop Attribute](#) on page 2-132.

### 13.10.24 Do Direct Write Transfer, DoDWT

The characteristics of this field are:

- Only applicable in WriteNoSnpFull, WriteNoSnpPtl, and Combined Write requests from Home to Subordinate.
- It is inapplicable and must be set to zero in all other requests.
- The bit shares the same field as SnpAttr.

Table 13-21 shows the DoDWT value encoding.

Table 13-21 DoDWT value encoding

| DoDWT | DBIDResp.TgtID value                      | DBIDResp.TxnID value                        |
|-------|-------------------------------------------|---------------------------------------------|
| 0     | Set to the SrcID value of the request     | Set to TxnID value in the request           |
| 1     | Set to the ReturnNID value in the request | Set to the ReturnTxnID value in the request |

See *Immediate write* on page 2-49 and *Combined Immediate Write and CMO* on page 2-56.

### 13.10.25 Likely Shared, LikelyShared

This field indicates whether the requested data is likely to be shared with another Request Node. See *Likely Shared* on page 2-131.

Table 13-22 shows the LikelyShared field value encoding.

Table 13-22 LikelyShared value encoding

| LikelyShared | Description                           |
|--------------|---------------------------------------|
| 0            | Not likely to be shared by another RN |
| 1            | Likely to be shared by another RN     |

### 13.10.26 Ordering requirements, Order

This field specifies the ordering requirements for a transaction. See *Ordering* on page 2-114 for more information on the ordering requirements.

Table 13-23 on page 13-431 shows the Order field value encodings.

Table 13-23 Order value encodings

| Order[1:0] | Description                             | Permitted between             |
|------------|-----------------------------------------|-------------------------------|
| 0b00       | No ordering required                    | All                           |
| 0b01       | Request accepted                        | HN-F to SN-F and HN-I to SN-I |
|            | Reserved                                | RN to HN                      |
| 0b10       | Request Order/Ordered Write Observation | RN to HN <sup>a</sup>         |
|            | Request Order                           | HN-I to SN-I                  |
|            | Reserved                                | HN-F to SN-F                  |
| 0b11       | Endpoint Order                          | RN to HN and HN-I to SN-I     |
|            | Reserved                                | HN-F to SN-F                  |

a. Request Order when ExpCompAck = 0.  
Ordered Write Observation when ExpCompAck = 1.

### 13.10.27 Exclusive, Excl

This field indicates that the corresponding transaction is an Exclusive-type transaction. The Exclusive bit must only be used with the following transactions:

- ReadNotSharedDirty
- ReadShared
- ReadClean
- ReadPreferUnique
- CleanUnique
- MakeReadUnique
- ReadNoSnp
- WriteNoSnp

Table 13-24 shows the Excl value encoding.

Table 13-24 Excl value encoding

| Excl | Description           |
|------|-----------------------|
| 0    | Normal transaction    |
| 1    | Exclusive transaction |

See *Exclusive transactions* on page 6-286.

### 13.10.28 Endian

This field indicates the endianness of Data in an Atomic transaction. See *Endianness* on page 2-138.

Applicable in Atomic requests, inapplicable in all other requests and must be set to zero.

Table 13-25 shows the Endian value encoding.

Table 13-25 Endian value encoding

| Endian | Description   |
|--------|---------------|
| 0      | Little Endian |
| 1      | Big Endian    |

### 13.10.29 Allow Retry, AllowRetry

This field specifies that the request is being sent without a P-Credit and that the target can determine if a retry response is given. See *Transaction Retry mechanism* on page 2-147.

Table 13-26 shows the AllowRetry value encoding.

Table 13-26 AllowRetry value encodings

| AllowRetry | Description                     |
|------------|---------------------------------|
| 0          | RetryAck response not permitted |
| 1          | RetryAck response permitted     |

### 13.10.30 Expect Completion Acknowledge, ExpCompAck

This field indicates that the transaction will include a CompAck response.

Table 13-27 shows the ExpCompAck value encoding.

Table 13-27 ExpCompAck value encoding

| ExpCompAck | Description                                     |
|------------|-------------------------------------------------|
| 0          | Transaction does not include a CompAck response |
| 1          | Transaction includes a CompAck response         |

### 13.10.31 SnoopMe

This field indicates that the Home must determine whether to send a snoop to the Requester. See *Atomic transactions* on page 2-68.

Only applicable in Atomic requests.

Table 13-28 shows the SnoopMe value encoding.

Table 13-28 SnoopMe value encoding

| SnoopMe | Description                                                                                                |
|---------|------------------------------------------------------------------------------------------------------------|
| 0       | Home is permitted but not required to send a snoop to the Requester.                                       |
| 1       | Home must send a Snoop to the Requester if it determines the cache line might be present at the Requester. |

### 13.10.32 Return to Source, RetToSrc

This field requests the Snoopee to return a copy of the cache line to the Home.

Applicable in all snoops except SnpDVMOp.

For RetToSrc bit semantics see *Returning Data with Snoop response* on page 4-240.

### 13.10.33 Data Pull, DataPull

This field indicates the inclusion of a Read request, also referred to as a Data Pull, in the Snoop response. See *Snoop requests and Data Pull* on page 7-294.

Applicable in SnpResp and SnpRespData response to a Stash request, not applicable in all other Snoop responses.

When the DataPull bit is set in a SnpRespData message it must be set in all packets of that response message.

Table 13-29 shows the DataPull field value encodings.

Table 13-29 DataPull value encodings

| DataPull[2:0] | Description | Comment                                      |
|---------------|-------------|----------------------------------------------|
| 0b000         | No Read     | Inclusion of Data Pull in the Snoop response |
| 0b001         | Read        |                                              |
| 0b010- 0b111  | -           | Reserved                                     |

### 13.10.34 Do not transition to SD state, DoNotGoToSD

This field is an attribute in a Snoop request indicating if a Snoopee is required to not transition to SD state. See *Do not transition to SD* on page 4-241.

Applicable, and can take any value in:

- SnpOnce, SnpOnceFwd
- SnpClean, SnpCleanFwd
- SnpNotSharedDirty, SnpNotSharedDirtyFwd
- SnpShared, SnpSharedFwd
- SnpPreferUnique, SnpPreferUniqueFwd

Applicable, and must be set to 1 in:

- SnpStashShared, SnpStashUnique
- SnpUnique, SnpUniqueFwd, SnpUniqueStash
- SnpCleanShared
- SnpCleanInvalid
- SnpMakeInvalid, SnpMakeInvalidStash

Inapplicable, and must be set to zero in:

- SnpQuery
- SnpDVMOp

Table 13-30 shows the DoNotGoToSD value encoding.

Table 13-30 DoNotGoToSD value encoding

| DoNotGoToSD | Description                                                                                                                                                                                                                                |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0           | Permitted to transition to SD state.                                                                                                                                                                                                       |
| 1           | Transitioning to SD state is not permitted.<br>If already in SD state, then except for SnpQuery must exit SD state in response to the snoop.<br>The bit value can be ignored by the Snoopee if the Snoop request is SnpOnce or SnpOnceFwd. |

### 13.10.35 Quality of Service priority level, QoS

Ascending values of QoS indicate higher priority levels. See *Chapter 10 Quality of Service* for more information.

### 13.10.36 Protocol Credit Type, PCrdType

This field indicates the type of credit being granted or returned. See *Transaction Retry mechanism* on page 2-147.

Table 13-31 shows the PCrdType value encodings.

Table 13-31 PCrdType value encodings

| PCrdType  | Description                         |
|-----------|-------------------------------------|
| 0x0 - 0xF | P-Credit type 0 to 15 respectively. |

### 13.10.37 Tag Operation, TagOp

This field indicates the operation to be performed on the tags present in the corresponding DAT channel.

Table 13-32 shows the TagOp value encodings.

Table 13-32 TagOp value encodings

| TagOp[1:0] | Tag Operation  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|------------|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0b00       | Invalid        | The tags are not valid.                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 0b01       | Transfer       | <ul><li>The tags are Clean.</li><li>Tag Match does not need to be performed.</li><li>All tags corresponding to data in the packet must be transferred. For Snoopable transactions, partial tag transfer is not supported.</li><li>TU field is not applicable and must be set to zero.</li></ul>                                                                                                                                                           |
| 0b10       | Update         | <ul><li>The Allocation Tag values have been updated and are Dirty.</li><li>The Tags in memory should be updated. Only the Tags that have TU asserted must be updated.</li></ul>                                                                                                                                                                                                                                                                           |
| 0b11       | Match<br>Fetch | <ul><li>Match:<ul><li>The Physical Tags in the write must be checked against the Allocation Tag values obtained from memory.</li><li>The Match Tag operation must be enabled for only those tags that have BE asserted.</li><li>TU field is not applicable and must be set to zero.</li></ul></li><li>Fetch:<ul><li>Tags must be fetched.</li><li>All tags must be fetched.</li><li>Permitted, but not required, to fetch valid data.</li></ul></li></ul> |

TagOp value in a Retry request must be the same as in the original request.

### 13.10.38 Tag

Tag[4\*n-1:0]. This field provides n sets of 4-bit tags, each associated with a 16-byte, aligned address location.

[Tag[(4\*n)-1]: 4\*(n-1)] corresponds to Data[(128\*n)-1]: 128\*(n-1)]

### 13.10.39 Tag Update, TU

TU[n-1:0]. This field indicates which of the Allocation Tags must be updated. There is one TU bit for each tag. Only valid in Snoop responses and Write transactions which update the Allocation Tags. Must be set to zero in all other transactions.

TU[n-1] corresponds to Tag[(4\*n)-1]: 4\*(n-1)]

### 13.10.40 Tag Group Identifier, TagGroupId

This field is used by a Requester to process different sets of TagMatch responses by grouping the corresponding requests together and identifying each group using TagGroupId. The precise contents of TagGroupId are implementation defined. Typically, TagGroupId is expected to contain an Exception Level, TTBR value, and CPU identifier.

TagGroupId is applicable in requests where TagOp is set to *Match* and in a TagMatch response.

In requests, when applicable, the same bits in the packet are used for LPID, PGroupID, or StashGroupID.

In responses, when applicable, the same bits in the packet are used for DBID, PGroupID, or StashGroupID.

### 13.10.41 Trace Tag, TraceTag

This field is a bit in a packet used to tag the packets associated with a transaction for tracing purposes.

Table 13-33 shows the TraceTag field value encoding.

Table 13-33 TraceTag value encoding

| TraceTag | Description           |
|----------|-----------------------|
| 0        | Packet is not tagged. |
| 1        | Packet is tagged.     |

See [Chapter 11 System Debug, Trace, and Monitoring](#).

### 13.10.42 Memory System Performance Resource Partitioning and Monitoring, MPAM

This field is used to efficiently utilize the memory resources among users and to monitor their use. See [MPAM on page 11-365](#).

### 13.10.43 Virtual Machine Identifier Extension, VMIDExt

This field is used to extend VMID value from 8-bits to 16-bits. See [DVMOp payload on page 8-315](#).

### 13.10.44 Response status, Resp

This field must have the same value in all data flits of a multi-flit data transfer.

Table 13-34 shows the Resp value encodings.

Table 13-34 Resp value encodings

| Resp[2:0] | Description                                                                                                                                                                                                                                                                                                                                                     |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Resp[2]   | PassDirty. Indicates that the data included in the response message is Dirty with respect to memory and that the responsibility of writing back the cache line is being passed to the recipient of the response message.<br>0 Returned data is not Dirty.<br>1 Returned data is Dirty and the responsibility of writing back the cache line is being passed on. |
| Resp[1:0] | For snoop responses, this field indicates the final state of the snooped RN-F.<br>For completion responses, this field indicates the final state in the RN.<br>For WriteData responses, this field indicates the state of the data in the RN when the data is sent.<br>For TagMatch responses, Resp[0] alone indicates a Tag Match pass or fail.                |

Table 13-35 shows the valid Resp value encodings.

Table 13-35 Valid Resp value encodings for different message types

| Response Type       | Resp[2:0]     | State  | Notes                                                                                              |
|---------------------|---------------|--------|----------------------------------------------------------------------------------------------------|
| Snoop responses     | 0b000         | I      | Final state of the snooped RN-F.                                                                   |
|                     | 0b001         | SC     |                                                                                                    |
|                     | 0b010         | UC, UD |                                                                                                    |
|                     | 0b011         | SD     |                                                                                                    |
|                     | 0b100         | I_PD   | Final state of the snooped RN-F. Responsibility for updating memory is passed to Home.             |
|                     | 0b101         | SC_PD  |                                                                                                    |
|                     | 0b110         | UC_PD  |                                                                                                    |
|                     | 0b111         | -      | Reserved.                                                                                          |
| Comp responses      | 0b000         | I      | Final state of the requesting RN-F.                                                                |
|                     | 0b001         | SC     |                                                                                                    |
|                     | 0b010         | UC     |                                                                                                    |
|                     | 0b011         | -      | Reserved.                                                                                          |
|                     | 0b100         | -      |                                                                                                    |
|                     | 0b101         | -      |                                                                                                    |
|                     | 0b110         | UD_PD  | Final state of the requesting RN-F. Responsibility for updating memory is passed to the Requester. |
| WriteData responses | 0b000         | I      | State of the cache line at the RN-F when data is sent.                                             |
|                     | 0b001         | SC     |                                                                                                    |
|                     | 0b010         | UC     |                                                                                                    |
|                     | 0b011         | -      | Reserved.                                                                                          |
|                     | 0b100         | -      |                                                                                                    |
|                     | 0b101         | -      |                                                                                                    |
|                     | 0b110         | UD_PD  | State of the cache line at the RN-F when data is sent.                                             |
|                     | 0b111         | SD_PD  | Responsibility for updating memory is passed to Home.                                              |
| TagMatch responses  | 0b000         | Fail   | Part of the Tag Match operation.                                                                   |
|                     | 0b001         | Pass   |                                                                                                    |
|                     | 0b010 - 0b111 | -      | Reserved.                                                                                          |

### 13.10.45 Forward State, FwdState

This field indicates the state in the CompData sent from the Snoopee to the Requester. Applicable in SnpRespFwded and SnpRespDataFwded, inapplicable in all other Snoop responses and must be set to zero.

Table 13-36 shows the FwdState value encodings.

Table 13-36 FwdState value encodings

| FwdState[2:0] | Description                                                                                                  |
|---------------|--------------------------------------------------------------------------------------------------------------|
| FwdState[2]   | PassDirty.                                                                                                   |
| 0             | Forwarded data is not Dirty.                                                                                 |
| 1             | Forwarded data is Dirty and the responsibility of writing back the cache line is passed on to the Requester. |
| FwdState[1:0] | Indicates the final state at the Requester. See Table 13-37.                                                 |

Table 13-37 enumerates the FwdState value encodings.

Table 13-37 Valid FwdState value encodings

| FwdState[2:0] | State | Comment                                                      |
|---------------|-------|--------------------------------------------------------------|
| 0b000         | I     | Final state at the Requester.                                |
| 0b001         | SC    |                                                              |
| 0b010         | UC    |                                                              |
| 0b011         | -     | Reserved.                                                    |
| 0b100         | -     |                                                              |
| 0b101         | -     |                                                              |
| 0b110         | UD_PD | Final state at the Requester.<br>Responsibility for updating |
| 0b111         | SD_PD | memory is passed to the<br>Requester.                        |

### 13.10.46 Completer Busy, CBusy

This field is a mechanism for the Completer of a transaction to indicate its current level of activity. The CBusy value encodings are IMPLEMENTATION DEFINED. See *Completer Busy* on page 11-367.

#### 13.10.47 Response Error, RespErr

This field indicates the error status of the response. See [Chapter 9 Error Handling](#).

Table 13-38 shows the RespErr value encodings.

Table 13-38 RespErr value encodings

| RespErr[1:0] | Description                                                                                                                  |
|--------------|------------------------------------------------------------------------------------------------------------------------------|
| 0000         | Normal Okay. Indicates that either: <ul><li>The Normal access was successful.</li><li>The Exclusive access failed.</li></ul> |
| 0001         | Exclusive Okay. Indicates that either the read or write portion of an Exclusive access was successful.                       |
| 0010         | Data Error.                                                                                                                  |
| 0011         | Non-data Error.                                                                                                              |

#### 13.10.48 Data payload, Data

This field is the data payload that is being transported in a Data packet.

The following data bus widths are supported:

- 128-bit
- 256-bit
- 512-bit

See [Data packetization on page 2-136](#).

#### 13.10.49 Critical Chunk Identifier, CCID

This field indicates the critical 128-bit chunk of the data that is being requested. See [Critical Chunk Identifier on page 2-139](#).

Table 13-39 shows the CCID value encodings.

Table 13-39 CCID value encodings

| CCID[1:0] | Critical data chunk |
|-----------|---------------------|
| 0000      | Data[127:0]         |
| 0001      | Data[255:128]       |
| 0010      | Data[383:256]       |
| 0011      | Data[511:384]       |

### 13.10.50 Data Identifier, DataID

This field indicates the relative position of the data chunk within the 512-bit cache line that is being transferred. See *Data packetization on page 2-136*.

Table 13-40 shows the DataID value encodings.

Table 13-40 DataID and the bytes within a packet for different data widths

| DataID | Data Width    |               |             |
|--------|---------------|---------------|-------------|
|        | 128-bit       | 256-bit       | 512-bit     |
| 0b00   | Data[127:0]   | Data[255:0]   | Data[511:0] |
| 0b01   | Data[255:128] | Reserved      | Reserved    |
| 0b10   | Data[383:256] | Data[511:256] | Reserved    |
| 0b11   | Data[511:384] | Reserved      | Reserved    |

### 13.10.51 Byte Enable, BE

This field indicates if the byte of data corresponding to this byte enable bit is valid. The BE field is defined for write data, DVM payload, and Snoop response data transfers. For Read response data transfers, this field is inapplicable and can take any value. It consists of a bit for each data byte in the DAT flit. See *Byte Enables on page 2-135*.

Table 13-41 shows the BE value encodings.

Table 13-41 BE value encodings

| BE | Byte enable                              |
|----|------------------------------------------|
| 0  | Corresponding byte of data is not valid. |
| 1  | Corresponding byte of data is valid.     |

### 13.10.52 Data check, DataCheck

This field is used to supply the DataCheck bit for the corresponding byte of Data. See *Data Check on page 9-348*.

### 13.10.53 Poison

This field indicates if the 64-bit chunk of data corresponding to a Poison bit is poisoned, that is, has an error, and must not be consumed. See *Poison on page 9-347*.

Table 13-42 shows the Poison value encodings.

Table 13-42 Poison value encodings

| Poison | Description                                 |
|--------|---------------------------------------------|
| 0      | Corresponding 64-bit chunk is not poisoned. |
| 1      | Corresponding 64-bit chunk is poisoned.     |

#### 13.10.54 Data source, DataSource

This field identifies the Sender of the data response. See *DataSource value assignment on page 11-360*.

Applicable in CompData and DataSepResp responses in Read and Atomic transactions, and SnpRespData and SnpRespDataPt responses in Non-stash type Snoop transactions. DataSource is not applicable, and must be set to zero, in all other responses.

Table 13-43 shows the DataSource value encodings.

Table 13-43 DataSource value encodings

| DataSource      | Description                 | Comment                                                                                                    |
|-----------------|-----------------------------|------------------------------------------------------------------------------------------------------------|
| 0b0000          | DataSource is not supported | Applicable only to a non-memory component                                                                  |
| 0b0001 - 0b0101 | IMPLEMENTATION DEFINED      | See <i>Suggested DataSource values on page 11-361</i>                                                      |
| 0b0110          | PrefetchTgt was useful      | Indication from memory that the earlier sent prefetch was useful or memory received a prefetch.            |
| 0b0111          | PrefetchTgt was not useful  | Indication from memory that the earlier sent prefetch was not useful or memory did not receive a prefetch. |
| 0b1000 - 0b1111 | IMPLEMENTATION DEFINED      | -                                                                                                          |

#### 13.10.55 System Level Caches Replacement Hint, SLCRepHint

This field forwards cache replacement hints from the Requesters to the SLC in the interconnect, See *SLC replacement hint on page 11-363*.

#### 13.10.56 Reserved for Customer Use, RSVDC

This field in a Protocol flit can take any value. Propagation of this field through the interconnect is IMPLEMENTATION DEFINED.

This field is applicable in the REQ and DAT channels as follows:

- The presence of this field is optional.
- The permitted field widths are 4-bit, 8-bit, 12-bit, 16-bit, 24-bit, and 32-bit.
- The field widths:
  - — Can be different between REQ and DAT channels.
  - — Need not be the same across all REQ channels in the system.
  - — Need not be the same across all DAT channels in the system.

When connecting Tx and Rx flit interfaces that have mismatched RSVDC widths:

- The corresponding lower-order bits of the RSVDC field must be connected at each side of the interface.
- The higher-order RSVDC bits at the RX interface that do not have corresponding bits at the TX interface must be tied LOW.

### 13.11 Link flit

A link flit is used to return L-Credits to the receiver during a link deactivation sequence. Link flits originate at a link Transmitter and terminate at the link Receiver on the other side of the link.

A link flit is identified by a zero value in the Opcode field. The TxnID field of the link flit is required to be zero. The remaining fields are not used and can take any value. See *Channel opcodes, Opcode on page 13-421* for the link flit type encoding.

## Chapter 14

# Link Handshake

This chapter describes the link handshake requirements. It contains the following sections:

- *Clock, and initialization* on page 14-444
- *Link layer Credit* on page 14-445
- *Low power signaling* on page 14-446
- *Flit level clock gating* on page 14-447
- *Interface activation and deactivation* on page 14-448
- *Transmit and receive link Interaction* on page 14-454
- *Protocol layer activity indication* on page 14-460

## 14.1 Clock, and initialization

This section specifies the AMBA 5 CHI requirement for global clock and reset signals.

### 14.1.1 Clock

This specification does not define a specific clocking microarchitecture. It is expected that all devices, interconnects, and so on, includes one or more clocks that can be relied upon by other Link layer functions that require synchronous communication. A generic clock signal is referred to as **CLK** in the following sections, where applicable.

### 14.1.2 Reset

This specification does not define a specific reset microarchitecture. It is expected that all devices, interconnects, and so on, include a specific reset deassertion event that can be relied upon by other Link layer functions. A generic reset signal is referred to as **RESETn** in the following sections, where applicable.

### 14.1.3 Initialization

During reset the following interface signals must be deasserted by the component:

- **TX\*\*\*LCRDV.**
- **TX\*\*\*FLITV.**
- **TXLINKACTIVEREQ** and **RXLINKACTIVEACK.**

The earliest point after reset that it is permitted to begin driving these signals HIGH is at a rising **CLK** edge after **RESETn** is HIGH.

All other signals can take any value.

## 14.2 Link layer Credit

This section describes the *Link layer Credit* (L-Credit) mechanism. Information is transferred across an interface channel by the use of L-Credits. To transfer one flit from the Transmitter to the Receiver, the Transmitter must have obtained an L-Credit.

### 14.2.1 L-Credit flow control

An L-Credit is sent from the Receiver to the Transmitter by asserting the appropriate *LCRDV* signal for a single clock cycle. There is one *LCRDV* signal for each channel. See *Channel interface signals on page 13-406* for the *LCRDV* signal naming for each channel.

Each transfer of a flit from the Transmitter to the Receiver consumes one L-Credit.

The minimum number of L-Credits that a Receiver can provide is one. The maximum number of L-Credits that a Receiver can provide is 15.

A Receiver must guarantee that it can accept all the flits for which it has issued L-Credits.

When the link is active, the Receiver must provide L-Credits in a timely manner without requiring any action on the part of the Transmitter.

**Note**

An L-Credit cannot be used in the cycle it is received.

### 14.3 Low power signaling

This section describes the signaling used to enhance the low power operation of the interface. There are several different levels of operation:

#### Flit Level Clock Gating

This technique is used to provide a cycle-by-cycle indication of the activity of each of the channels of the interface. For each channel, an additional signal is provided to indicate if a transfer might occur in the following cycle. This signaling permits local clock gating of certain registers associated with the interface.

#### Link Activation

Link activation and deactivation are supported to permit the interface to be taken to a safe state, so that both-sides of the interface can enter a low power state that permits them to be either clock-gated or power-gated.

#### Protocol Activity Indication

The Protocol layer activity indication is used by components to indicate if there are ongoing transactions in progress. The Protocol layer activity indication can be used to influence the decision to use other low power techniques.

## 14.4 Flit level clock gating

The **FLITPEND** signal associated with a channel is used to indicate if a valid flit is going to be sent in the next clock cycle. There is one **FLITPEND** signal for each channel. See *Channel interface signals* on page 13-406 for the **FLITPEND** signal naming for each channel.

The requirements for the use of **FLITPEND** are:

- It is required that the signal is asserted exactly one cycle before a flit is sent from the Transmitter.
- When asserted, it is permitted, but not required, that the Transmitter sends a flit in the next cycle.
- When deasserted, it is required that the Transmitter does not send a flit in the next cycle.
- A Transmitter is permitted to keep the signal permanently asserted. A Transmitter might do this, for example, if it is unable to determine in advance when a flit is to be sent.
- A Transmitter is permitted to assert this signal when it does not have an L-Credit.
- A Transmitter is permitted to assert and then deassert this signal without sending a flit.

Figure 14-1 shows an example of the use of the **FLITPEND** signal.

![Timing diagram showing CLK, FLITPEND, FLITV, and FLIT signals. CLK is a square wave. FLITPEND is asserted (high) one cycle before FLIT is asserted (high) and labeled 'flit'. FLITV is asserted (high) one cycle before FLIT is asserted (high). FLIT is asserted (high) and labeled 'flit'.](1d52017af467ea9e7ed8da8fd3b6ab7e_img.jpg)

Timing diagram showing CLK, FLITPEND, FLITV, and FLIT signals. CLK is a square wave. FLITPEND is asserted (high) one cycle before FLIT is asserted (high) and labeled 'flit'. FLITV is asserted (high) one cycle before FLIT is asserted (high). FLIT is asserted (high) and labeled 'flit'.

Figure 14-1 **FLITPEND** indicating a valid flit in next cycle

## 14.5 Interface activation and deactivation

A mechanism is provided for an entire interface to move between a full running operational state and a low power state. When moving between operational states, including when exiting from reset, it is important that the exchange of L-Credits. The exchange of Link flits is carefully controlled to avoid the loss of flits or credits.

On exit from reset, or when moving to a full running operational state, the interface starts in an idle state and the transfer of flits can only commence when L-Credits have been exchanged. L-Credits can only be exchanged when the Sender of the credits knows the Receiver is ready to receive them.

A two-signal, four-phase, handshake mechanism is used. This two signal interface is used for all channels traveling in the same direction, rather than being required for each individual channel. An entire interface uses a total of four signals, two signals are used for all the transmit channels and two signals are used for all the receive channels.

### 14.5.1 Request and Acknowledge handshake

For the purposes of description, the two signal Request and Acknowledge signaling is described using the signal names **LINKACTIVEREQ** and **LINKACTIVEACK**.

This section describes the operation of the **LINKACTIVEREQ** and **LINKACTIVEACK** handshake pairs for all channels moving in one direction. **Transmit and receive link interaction on page 14-454** describes the interaction between the handshake pairs for the transmit channels and those for the receive channels.

For a single channel, or group of channels traveling in the same direction, Figure 14-2 shows the relationship between the Payload, Credit, **LINKACTIVEREQ**, and **LINKACTIVEACK** signals.

![Figure 14-2 shows a sequence diagram illustrating the relationship between Payload, Credit, LINKACTIVEREQ, and LINKACTIVEACK signals between a Transmitter and a Receiver. The Transmitter sends LINKACTIVEREQ to the Receiver. The Receiver sends LINKACTIVEACK back to the Transmitter. The Transmitter then sends Payload to the Receiver. The Receiver sends Credit back to the Transmitter.](74366143dc6f7507173d356ccd497a93_img.jpg)

Figure 14-2 shows a sequence diagram illustrating the relationship between Payload, Credit, LINKACTIVEREQ, and LINKACTIVEACK signals between a Transmitter and a Receiver. The Transmitter sends LINKACTIVEREQ to the Receiver. The Receiver sends LINKACTIVEACK back to the Transmitter. The Transmitter then sends Payload to the Receiver. The Receiver sends Credit back to the Transmitter.

Figure 14-2 Relationship between Payload, Credit, and **LINKACTIVE** signals

As Figure 14-2 shows, during normal operation the Transmitter, which sends the payload flits, requires a credit before it can send a flit. A credit is passed from the Receiver when it has resources available to accept a flit:

- On exit from reset, credits are held by the Receiver and must be passed to the Transmitter before flit transfer can begin.
- During normal operation, there is an ongoing exchange of flits and credits between the two sides of the interface.
- Before entering a low power state, the sending of payload flits must be stopped and all credits must be returned to the Receiver. This effectively returns the interface to the same state that it was at immediately after reset.

Four states are defined for the interface operation:

| <b>RUN</b>        | There is an ongoing exchange of flits and credits between the two components.                                                                                 |
|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>STOP</b>       | The interface is in a low power state and it is not operational. All credits are held by the Receiver and the Transmitter is not permitted to send any flits. |
| <b>ACTIVATE</b>   | This state is used when moving from the <b>STOP</b> state to the <b>RUN</b> state.                                                                            |
| <b>DEACTIVATE</b> | This state is used when moving from the <b>RUN</b> state to the <b>STOP</b> state.                                                                            |

RUN and STOP are stable states. When one of these states is entered, a channel can remain in this state for an indefinite period.

DEACTIVATE and ACTIVATE are transient states. It is expected that when one of these states is entered, a channel moves to the next stable state in a relatively short period.

— Note —

The specification does not define a maximum period in a transient state, but it is expected that for any given implementation it is deterministic.

The state is determined by the LINKACTIVEREQ and LINKACTIVEACK signals. Figure 14-3 shows the relationship between the four states.

![Figure 14-3: Request and Acknowledge handshake states diagram. The states are STOP, DEACTIVATE, RUN, and ACTIVATE, arranged in a cycle. Transitions are: STOP to DEACTIVATE (00), DEACTIVATE to RUN (01), RUN to ACTIVATE (11), and ACTIVATE to STOP (10).](d8d7313aeb6a00ecda89d72735bb102b_img.jpg)

Figure 14-3: Request and Acknowledge handshake states diagram. The states are STOP, DEACTIVATE, RUN, and ACTIVATE, arranged in a cycle. Transitions are: STOP to DEACTIVATE (00), DEACTIVATE to RUN (01), RUN to ACTIVATE (11), and ACTIVATE to STOP (10).

Figure 14-3 Request and Acknowledge handshake states

Table 14-1 shows the mapping of the states to the LINKACTIVEREQ and LINKACTIVEACK signals.

Table 14-1 Mapping of states to the LINKACTIVE signals

| State      | LINKACTIVEREQ | LINKACTIVEACK |
|------------|---------------|---------------|
| STOP       | 0             | 0             |
| ACTIVATE   | 1             | 0             |
| RUN        | 1             | 1             |
| DEACTIVATE | 0             | 1             |

Table 14-2 on page 14-450 describes the behavior of both the Transmitter and the Receiver of a single link for each of the four states.

Table 14-2 Behavior for each Request and Acknowledge state

| State              | Transmitter behavior                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Receiver behavior                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|--------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| STOP               | <p>The Transmitter has no credits and must not send any flits.</p> <p>The Transmitter is guaranteed not to receive any credits.</p> <p>The Transmitter must assert <b>LINKACTIVEREQ</b> to move to the <b>ACTIVATE</b> state if it has flits to send.</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                           | <p>The Receiver is guaranteed not to receive any flits.</p> <p>The Receiver must not send any credits.</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ACTIVATE (ACT)     | <p>The Transmitter must not send any flits.</p> <p>The Transmitter must be prepared to receive credits in this state, although it must not use them until in the <b>RUN</b> state.</p> <p>The Transmitter remains in the <b>ACTIVATE</b> state while it is waiting for the Receiver to acknowledge the move to the <b>RUN</b> state.</p> <p><b>Note</b></p> <p>The Transmitter will only receive credits in the <b>ACTIVATE</b> state when there is a race between the Receiver sending credits and asserting <b>LINKACTIVEACK</b> to move to the <b>RUN</b> state.</p>                                                                                                                                             | <p>The Receiver is guaranteed not to receive any flits.</p> <p>The Receiver must not send any credits.</p> <p>The <b>ACTIVATE</b> state is a transient state and the Receiver controls the move to the <b>RUN</b> state by asserting <b>LINKACTIVEACK</b>.</p> <p>The Receiver must assert <b>LINKACTIVEACK</b> and move to the <b>RUN</b> state before sending credits. It is permitted to assert <b>LINKACTIVEACK</b> and send a credit in the same cycle.</p> <p><b>Note</b></p> <p>It can appear that a Receiver has sent credits in the <b>ACTIVATE</b> state if there is a race between the Receiver sending credits and asserting <b>LINKACTIVEACK</b> to move to the <b>RUN</b> state.</p>                                                                                                                                                                                           |
| RUN                | <p>The Transmitter can receive credits.</p> <p>The Transmitter can send flits when it has credits available.</p> <p>The Transmitter deasserts <b>LINKACTIVEREQ</b> to exit from this state if it wants to move to a low power state.</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <p>The Receiver can receive flits corresponding to the credits it has sent.</p> <p>The Receiver sends credits when it has resources available to accept further flits.</p> <p>The Receiver must remain in the <b>RUN</b> state until it observes the deassertion of <b>LINKACTIVEREQ</b>.</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| DEACTIVATE (DEACT) | <p>The Transmitter must return credits using Protocol flits or L-Credit return flits.</p> <p>It is recommended that the Transmitter enters the <b>DEACTIVATE</b> state only when it has no more Protocol flits to send. Therefore, it is expected that the Transmitter returns credits using only L-Credit return flits.</p> <p>The Transmitter must be prepared to continue receiving credits. For each additional credit received it must send an L-Credit return flit to return the credit.</p> <p>The Transmitter remains in the <b>DEACTIVATE</b> state while it is waiting for the Receiver to acknowledge the move to the <b>STOP</b> state. At this point, it is guaranteed to receive no more credits.</p> | <p>During this state, the Receiver stops sending credits and collects all returned credits.</p> <p>The Receiver must be prepared to receive flits, other than Link flits to return credits, in this state. This is not expected, but can occur.</p> <p>The Receiver is permitted to send credits when first entering this state. However, it must have stopped sending credits and had all credits returned before exiting this state.</p> <p>The Receiver receives L-Credit return flits until all credits are returned.</p> <p>The Receiver must wait for all credits to be returned before deasserting <b>LINKACTIVEACK</b>.</p> <p><b>Note</b></p> <p>The Receiver will only receive flits in the <b>DEACTIVATE</b> state when there is a race between the Transmitter sending the last remaining flits and deasserting <b>LINKACTIVEREQ</b> to move to the <b>DEACTIVATE</b> state.</p> |

Table 14-5 on page 14-458 summarizes the required behavior described in detail in Table 14-2 on page 14-450.

Table 14-3 Summary of behavior for each Request and Acknowledge state

| State | Transmitter                                                                                                    | Receiver                                          |
|-------|----------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| STOP  | Must not send flits.<br>Will not receive credits.                                                              | Must not send credits.<br>Will not receive flits. |
| ACT   | Must not send flits.<br>Must accept credits.                                                                   | Must not send credits.<br>Will not receive flits. |
| RUN   | Can send flits.<br>Must accept credits.                                                                        | Must accept flits.<br>Can send credits.           |
| DEACT | Expected to send L-Credit return flits.<br>Can send any flits.<br>Must accept credits.<br>Must return credits. | Must accept flits.<br>Must stop sending credits.  |

### Response to new state

When moving to a new state, where the state change has been initiated by the other-side of the interface, a component might be required to change its behavior.

If the state change requires a component to start sending flits or credits, there is no defined limit on the time taken for the component to start the new behavior. This new behavior will only occur in the new state.

If the state change requires a component to stop sending flits or credits, the component is permitted to take some time to respond. In this scenario, it is possible to see behavior when first entering a new state which is not expected within that state.

The state change from RUN to DEACTIVATE is the point at which flits and credits stop being sent.

Flits are sent by the Transmitter, which is also the component that determines the state change, and therefore the Transmitter can ensure flits are not sent after the state change.

Credits are sent by the Receiver, but that component does not determine the state change. The Receiver might take some time to react to the state change and therefore it is possible for credits to be sent when first entering the DEACTIVATE state.

The protocol requires that the Receiver has stopped sending credits and has had all credits returned before it signals the change from DEACTIVATE to STOP.

### Determining when to move to ACTIVATE or DEACTIVATE

For a given channel, or set of channels in the same direction, the Transmitter is always responsible for initiating the state change from RUN to STOP, or from STOP to RUN.

The Transmitter itself can determine that a state change is needed. This can happen through various mechanisms. The following examples are not exhaustive:

- The Transmitter can determine that it has flits to send, so must move from STOP to RUN.
- The Transmitter can determine that it has no activity to perform for a significant period, so can move from RUN to STOP.
- The Transmitter can observe an independent sideband signal that indicates it should move either from RUN to STOP, or from STOP to RUN.
- The Transmitter can determine that a transaction is not fully complete and therefore the channels should remain in RUN state until all activity has completed.
- The Transmitter can observe a state change on the channel, or set of channels, that are used in the opposite direction. See [Transmit and receive link Interaction on page 14-454](#).

### Multiple channels in the same direction

Figure 14-4 shows an example of a multiple channel interface, also referred to as a Link, that transfers payload flits in the same direction. A single pair of LINKACTIVEQ and LINKACTIVEACK signals are used for all channels.

![Figure 14-4 shows a sequence diagram for a multiple channel unidirectional interface. The Transmitter sends LINKACTIVEQ to the Receiver, which replies with LINKACTIVEACK. This is followed by three cycles of Payload flit transmission and Credit exchange, illustrating how a single pair of LINKACTIVEQ and LINKACTIVEACK signals is used for all channels.](1497bfadb58f99d4da38f012014e0bcb_img.jpg)

Figure 14-4 shows a sequence diagram for a multiple channel unidirectional interface. The Transmitter sends LINKACTIVEQ to the Receiver, which replies with LINKACTIVEACK. This is followed by three cycles of Payload flit transmission and Credit exchange, illustrating how a single pair of LINKACTIVEQ and LINKACTIVEACK signals is used for all channels.

Figure 14-4 Example of a multiple channel unidirectional interface

The rules regarding the relationship between the LINKACTIVEQ and LINKACTIVEACK signals must be applied appropriately across all channels:

- When a state change requires the Transmitter to be able to accept credits, it must be able to accept credits on all channels.
- When a state change requires the Receiver to be able to accept flits, it must be able to accept flits on all channels.
- When the sending of flits must stop before a state change, the sending of flits must stop on all channels.
- When the sending of credits must stop before a state change, the sending of credits must stop on all channels.
- A credit can only be associated with a flit on the same channel.

## 14.6 Transmit and receive link Interaction

This section describes the interaction between a link Transmitter and Receiver. It contains the following subsections:

- [Introduction](#)
- [Tx and Rx state machines on page 14-455](#)
- [Expected transitions on page 14-457](#)

### 14.6.1 Introduction

A single component has various different channels, some of which are inputs and some of which are outputs.

For a single component:

- All the channels where the Payload is an output are defined to be the *Transmit Link* (TXLINK).
- All the channels where the Payload is an input are defined to be the *Receive Link* (RXLINK).

It is required that the activation and deactivation of the TXLINK and RXLINK are coordinated.

When the TXLINK and RXLINK are both in the stable STOP state:

- If the RXLINK moves to the ACTIVATE state, which is controlled by the component on the other side of the interface, it is required that the TXLINK also moves to the ACTIVATE state, in a timely manner.
- If a component moves the TXLINK to the ACTIVATE state, which it controls, it can expect the RXLINK to also move to the ACTIVATE state, in a timely manner.

When the TXLINK and RXLINK are both in the stable RUN state:

- If the RXLINK moves to the DEACTIVATE state, which is controlled by the component on the other side of the interface, it is required that the TXLINK also moves to the DEACTIVATE state, in a timely manner.
- If a component moves the TXLINK to the DEACTIVATE state, which it controls, it can expect the RXLINK to also move to the DEACTIVATE state, in a timely manner.

When the TXLINK and RXLINK are changing states, the rules about the sending and receiving of credits and flits can be considered independently for each link.

## 14.6.2 Tx and Rx state machines

Figure 14-5 shows the permitted relationships between the Tx and Rx state machines. It is formatted so that the independent nature of the Tx and Rx state machines can be seen.

![Figure 14-5 Combined Tx and Rx state machines. This is a state diagram showing the permitted transitions between various Tx and Rx states. The states are grouped into Tx states (TxStop, TxAct, TxRun, TxDeact) and Rx states (RxStop, RxAct, RxRun, RxDeact). Transitions are color-coded: green arrows indicate transitions controlled by the local agent, blue arrows indicate transitions controlled by the remote agent, and black arrows indicate transitions controlled by both agents. The diagram also shows transitions related to signal changes (TXREQ, TXACK, RXREQ, RXACK) and race conditions (Banned Output Race, Asymp Input Race, Banned Output Race, Asymp Input Race).](53f6ff8d7aaccc4f23d79758949a41c7_img.jpg)

Figure 14-5 Combined Tx and Rx state machines. This is a state diagram showing the permitted transitions between various Tx and Rx states. The states are grouped into Tx states (TxStop, TxAct, TxRun, TxDeact) and Rx states (RxStop, RxAct, RxRun, RxDeact). Transitions are color-coded: green arrows indicate transitions controlled by the local agent, blue arrows indicate transitions controlled by the remote agent, and black arrows indicate transitions controlled by both agents. The diagram also shows transitions related to signal changes (TXREQ, TXACK, RXREQ, RXACK) and race conditions (Banned Output Race, Asymp Input Race, Banned Output Race, Asymp Input Race).

Figure 14-5 Combined Tx and Rx state machines

Figure 14-5 shows the combined Tx and Rx state machines for a single component:

- For clarity, shortened state names and signal names are used.
- A green arrow represents a transition that the local agent can control.
- A blue arrow represents a transition that is under the control of the remote agent on the other side of the interface.
- A black arrow represents a transition that is made when both the local and remote agents make a transition at the same time.
- Around the edge of Figure 14-5 is an indication of the individual Tx and Rx states. The green and blue arrows show which agent controls the transition. There is also an indication of the signal change that causes the state transition.
- A vertical or horizontal arrow is a state change caused by just one signal change, that is, only the Rx state machine or the Tx state machine changes state, not both.
- A diagonal arrow is a state change caused by two signals changing at the same time. If the diagonal arrow is green or blue, the same agent is changing both signals.

- There are a few cases where, by coincidence, a state change occurs due to two events, one on each side of the link, occurring at the same time. This is always a diagonal path and is shown by a black arrow.
- The sub-lines show dead-end paths where an exit from a state is not permitted. The color of a sub-line indicates which agent is responsible for ensuring that the path is not taken.
- The TxStop/RxStop and TxRun/RxRun states are expected to be stable states, and are typically the states where the state machines stay for long periods of time. These states are highlighted with a bold outline. All other states are considered transient states that are exited in a timely manner.
- The gray states, on the bottom right of Figure 14-5 on page 14-455, are replications of those on the top left. They are shown to aid clarity and maintain the symmetry of the diagram.
- The yellow states can only be reached by observing a race between two input signals. The transition into these states is labeled with *Async Input Race*. See *Asynchronous race condition* on page 14-458.
- The red states can only be reached by observing a race between two output signals. A race between two outputs is not permitted at the edge of a component and therefore the transition into these states is labeled with *Banned Output Race*. These states can only be observed at a midpoint between two components. See *Asynchronous race condition* on page 14-458.
- The bold arrows are used to indicate the expected transitions around the state machine. These are described in more detail in *Expected transitions* on page 14-457.
- The arrows labeled *Permitted* are state transactions that would not normally be expected, but they are permitted by the protocol.

### State naming

Figure 14-5 on page 14-455 shows the full set of states, including those that can only be reached through race conditions. A more detailed discussion of race conditions can be found in *Asynchronous race condition* on page 14-458.

There are two different TxStop/RxRun states and two different TxRun/RxStop states. These states differ in how they are reached and how it is permitted to exit from them. To differentiate between these states, a (+) suffix is used to indicate which state machine, Tx or Rx, is running ahead. For example:

- TxStop/RxRun+ indicates that the Tx state machine has remained in the previous STOP state, while the Rx state machine has advanced to the next RUN state.
- TxStop+/RxRun indicates that the Tx state machine has advanced to the next STOP state, while the Rx state machine remains in the previous RUN state.

## 14.6.3 Expected transitions

Figure 14-6 shows the expected state transitions.

![Figure 14-6: Expected Tx and Rx state machines transitions. This is a state diagram showing transitions between TxStop, TxAct, TxRun, TxDeact, TxStop, and TxAct states, and corresponding Rx states (RxStop, RxAct, RxRun, RxDeact, RxStop, RxAct). The diagram illustrates transitions based on signals like TXREQ, TXACK, RXREQ, and RXACK, and events like Remote Initiate, Local Initiate, Async Input Race, and Banned Output Race. Key states are highlighted in different colors: TxStop/RxStop (black), TxRun/RxRun (yellow), TxDeact/RxDeact (red), and TxAct/RxAct (green). Bold arrows indicate expected routes between stable states.](145911917016af21eb1395c033cdb929_img.jpg)

Figure 14-6: Expected Tx and Rx state machines transitions. This is a state diagram showing transitions between TxStop, TxAct, TxRun, TxDeact, TxStop, and TxAct states, and corresponding Rx states (RxStop, RxAct, RxRun, RxDeact, RxStop, RxAct). The diagram illustrates transitions based on signals like TXREQ, TXACK, RXREQ, and RXACK, and events like Remote Initiate, Local Initiate, Async Input Race, and Banned Output Race. Key states are highlighted in different colors: TxStop/RxStop (black), TxRun/RxRun (yellow), TxDeact/RxDeact (red), and TxAct/RxAct (green). Bold arrows indicate expected routes between stable states.

Figure 14-6 Expected Tx and Rx state machines transitions

Figure 14-6 shows, using bold arrows, the routes between the stable TxStop/RxStop and TxRun/RxRun states, and between the stable TxRun/RxRun and the TxStop/RxStop states.

The difference between the two routes moving from TxStop/RxStop to TxRun/RxRun states compared to moving from TxRun/RxRun to TxStop/RxStop states is due to the requirement to return L-Credits in the latter case. The differences are detailed in the following sections.

#### Expected transitions from TxStop/RxStop to TxRun/RxRun

There are two expected routes from a stable Stop/Stop to Run/Run state. Table 14-4 shows, in terms of the state transitions, the two expected paths.

Table 14-4 Stop/Stop to Run/Run state paths

| Route  | State 1       | State 2      | State 3     | State 4     |
|--------|---------------|--------------|-------------|-------------|
| Path 1 | TxStop/RxStop | TxStop/RxAct | TxAct/RxRun | TxRun/RxRun |
| Path 2 | TxStop/RxStop | TxAct/RxStop | TxRun/RxAct | TxRun/RxRun |

The annotations on the diagram arrows in Figure 14-6 on page 14-457 are:

| <b>Local Initiate</b>  | Indicates that the local agent has initiated the process of leaving one stable state towards the other stable state.                                     |
|------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>Remote Initiate</b> | Indicates that the remote agent on the other side of the interface has initiated the process of leaving one stable state towards the other stable state. |

### Expected transitions from TxRun/RxRun to TxStop/RxStop

A transition from a Run/Run state to a Stop/Stop state requires that L-Credits are returned. A link must remain in the DEACTIVATE state until all L-Credits are returned.

There are four expected routes from a stable Run/Run to Stop/Stop state. Table 14-5 shows, in terms of the state transitions, the four expected paths.

Table 14-5 State 5

| Route  | State 1     | State 2       | State 3         | State 4        | State 5       |
|--------|-------------|---------------|-----------------|----------------|---------------|
| Path 1 | TxRun/RxRun | TxDeact/RxRun | TxDeact/RxDeact | TxStop/RxDeact | TxStop/RxStop |
| Path 2 | TxRun/RxRun | TxDeact/RxRun | TxDeact/RxDeact | TxDeact/RxStop | TxStop/RxStop |
| Path 3 | TxRun/RxRun | TxRun/RxDeact | TxDeact/RxDeact | TxStop/RxDeact | TxStop/RxStop |
| Path 4 | TxRun/RxRun | TxRun/RxDeact | TxDeact/RxDeact | TxDeact/RxStop | TxStop/RxStop |

### Transitioning around a stable state

It is permitted, but not expected, to transition around a stable TxRun/RxRun or TxStop/RxStop state.

In the majority of cases, moving to the stable Run/Run or Stop/Stop state would be expected.

The most likely use case for wanting to move quickly out of one of the stable states is when an interface has started to enter a low power state, but there is still some activity required. It might be that the low power state was entered prematurely, or it might be that some new activity arose, by coincidence, while the low power state was being entered. In this use case, it is desirable to be able to move back to the Run/Run state as quickly as possible.

### Asynchronous race condition

There are situations where two output signals, X and Y, have a defined relationship such that:

- Output X must change after or at the same time as output Y, but it is not permitted to change before output Y.

This relationship applies specifically as follows:

- The assertion of RXACK must not occur before the assertion of TXREQ.
- The deassertion of RXACK must not occur before the deassertion of TXREQ.
- The assertion of TXREQ must not occur before the deassertion of RXACK.
- The deassertion of TXREQ must not occur before the assertion of RXACK.

In Figure 14-5 on page 14-455, these transitions are labeled as *Banned Output Race* and the resultant state is shown in red.

It is possible to observe these states if monitoring the output signals at a point in the system where asynchronous race conditions can result in two signals, that are asserted within the same cycle, are observed in different clock cycles.

A component that is on the other side of the interface, and has the two signals as inputs, can see the state transition if an asynchronous input race occurs. These transitions are labeled on the diagram as *Async Input Race* and the resultant state is shown in yellow.

For all input race conditions, a component that observes the input race is required to wait for both signals before changing any output signals. This is represented in Figure 14-5 on page 14-455 by the fact that the only permitted output transition from a race state is caused by the arrival of the other signal associated with the race condition.

### Combined Tx and Rx state machines without race conditions

In Figure 14-7, all transitions and states that occur as a result of a race condition in the combined Tx and Rx state machines have been removed.

![](7a3cfbeb6210a39a7d288a11138e6022_img.jpg)

Figure 14-7 is a state machine diagram illustrating the Combined Tx and Rx state machines without race conditions. The states are grouped by Tx and Rx components, and transitions are color-coded (Blue, Green, Black) and labeled with input/output signals and transition conditions.

**States:**

- **Tx States:** TxStop, TxAct, TxRun, TxDeact, TxStop, TxAct.
- **Rx States:** RxStop, RxAct, RxRun, RxDeact, RxStop, RxAct.

**Transitions:**

- **Vertical Transitions (Tx):** TxStop  $\leftrightarrow$  TxAct (TXREQ  $\uparrow$ , TXACK  $\downarrow$ ); TxAct  $\leftrightarrow$  TxRun (TXREQ  $\downarrow$ , TXACK  $\uparrow$ ); TxRun  $\leftrightarrow$  TxDeact (TXREQ  $\downarrow$ , TXACK  $\downarrow$ ); TxDeact  $\leftrightarrow$  TxStop (TXREQ  $\uparrow$ , TXACK  $\downarrow$ ).
- **Horizontal Transitions (Rx):** RxStop  $\leftrightarrow$  RxAct (RXREQ  $\uparrow$ , RXACK  $\uparrow$ ); RxAct  $\leftrightarrow$  RxRun (RXREQ  $\downarrow$ , RXACK  $\downarrow$ ); RxRun  $\leftrightarrow$  RxDeact (RXREQ  $\downarrow$ , RXACK  $\downarrow$ ); RxDeact  $\leftrightarrow$  RxStop (RXREQ  $\uparrow$ , RXACK  $\uparrow$ ).
- **Inter-State Transitions:**
  - **From TxStop/RxStop:** TxStop/RxStop  $\rightarrow$  TxAct/RxAct (Local Initiate).
  - **From TxAct/RxAct:** TxAct/RxAct  $\rightarrow$  TxRun/RxRun (Local Initiate).
  - **From TxRun/RxRun:** TxRun/RxRun  $\rightarrow$  TxDeact/RxDeact (Local Initiate).
  - **From TxDeact/RxDeact:** TxDeact/RxDeact  $\rightarrow$  TxStop/RxStop (Local Initiate).
  - **From TxStop/RxStop:** TxStop/RxStop  $\rightarrow$  TxAct/RxAct (Local Initiate).
- **Permitted Transitions (Diagonal):** These transitions are labeled "Permitted" and connect states across the Tx/Rx boundaries, typically moving towards the TxStop/RxStop state.
  - TxAct/RxAct  $\rightarrow$  TxRun/RxRun (Permitted).
  - TxRun/RxRun  $\rightarrow$  TxDeact/RxDeact (Permitted).
  - TxDeact/RxDeact  $\rightarrow$  TxStop/RxStop (Permitted).
  - TxStop/RxStop  $\rightarrow$  TxAct/RxAct (Permitted).

Figure 14-7 Combined Tx and Rx state machines without race conditions

## 14.7 Protocol layer activity indication

This section describes the signals that indicate Protocol layer activity. It contains the following subsections:

- [Introduction](#)
- [TXSACTIVE signal](#)
- [RXSACTIVE signal on page 14-463](#)
- [Relationship between SACTIVE and LINKACTIVE on page 14-463](#)

### 14.7.1 Introduction

SACTIVE signaling indicates that there are transactions in progress.

TXSACTIVE is an output signal that is asserted by an interface where there is a transaction either in progress or about to start:

- TXSACTIVE must be asserted before or in the same cycle in which the first flit relating to a transaction is sent.
- TXSACTIVE must remain asserted until after the last flit relating to all transactions is sent or received.

This means that the deassertion of TXSACTIVE on an interface implies that the component has completed all transactions in progress and does not need to send or receive any further flits.

A transaction that is given a RetryAck response is considered to be in progress, so TXSACTIVE must remain asserted until the associated credit has been supplied and used or returned.

RXSACTIVE is an input signal which indicates that the other side of the interface has ongoing Protocol layer activity. When RXSACTIVE is asserted a component must respond to Protocol layer activity in a timely manner.

SACTIVE signals must be synchronous to CLK and therefore are not required to be synchronized. If they cross a clock domain, the clock domain crossing bridge is required to synchronize the signals.

### 14.7.2 TXSACTIVE signal

The following rules apply to the TXSACTIVE signal:

- TXSACTIVE must be asserted when the transmitter has flits to send.
- A component that asserts TXSACTIVE must also, if required, initiate the link activation sequence. It is not permitted for a component to assert the TXSACTIVE signal and then wait for the other side of the interface to initiate the link activation sequence.
- TXSACTIVE must remain asserted until after the last flit relating to all transactions is sent or received.
- It is permitted for TXSACTIVE to be deasserted while transmitting link flits as part of the link deactivation sequence.

#### Note

To ensure an efficient power down sequence, it is recommended not to assert a deasserted TXSACTIVE signal during a link deactivation sequence.

It is permitted for the interface on an interconnect component to use the RXSACTIVE input signal to directly generate the TXSACTIVE output signal. This behavior is only permitted on the interconnect interface and it is not permitted on any attached component.

Except for an interconnect interface of a Link, no other interface of a Link is permitted to loop-back the incoming RXSACTIVE onto the outgoing TXSACTIVE.

Figure 14-8 on page 14-461 shows the requirements for TXSACTIVE assertion during the life of a transaction.

![](1e479517276bb511cc60cea9e54151da_img.jpg)

Sequence Diagram illustrating the TXSACTIVE assertion during the life of a transaction.

Participants (Lanes): RN-F0, RN-F1, RN-F1, ICN-RN, ICN-SN, SN-F.

Flow:

1. RN-F0 sends ReadUnique to ICN-RN.
2. ICN-RN sends SnpUnique to RN-F1.
3. ICN-RN sends SnpUnique to RN-F1.
4. RN-F1 sends SnpResp\_I to ICN-RN.
5. RN-F1 sends SnpResp\_I to ICN-RN.
6. ICN-RN sends ReadNoSnp to SN-F.
7. SN-F sends CompData to ICN-SN.
8. ICN-SN sends CompData\_UC to RN-F0.
9. RN-F0 sends I->UC to ICN-RN.
10. RN-F0 sends CompAck to ICN-RN.

Activity Indicators:

- RN-F0: =TXSACTIVE (indicated by a shaded bar below the lane).
- ICN-RN and ICN-SN: Interconnect (indicated by a bracket below the lanes).

Figure 14-8 TXSACTIVE assertion during the life of a transaction

### TXSACTIVE signaling from a Request Node

When initiating new transactions, a Request Node must assert **TXSACTIVE** in the same cycle or before **TXREQFLITV** is asserted and must keep it asserted until after the final completing flit of a transaction is sent or received.

The type of flit that completes a transaction initiated by a Request Node depends on both the transaction type and the manner in which the transaction progresses. For example, a ReadNoSnp transaction might typically complete with the receipt of the last CompData flit, but could equally complete with a ReadReceipt, if this is later than the last CompData flit.

An RN-F or RN-D component must also assert **TXSACTIVE** while a Snoop transaction is in progress. **TXSACTIVE** must be asserted after receiving an initiating snoop or SnpDVMOp flit, and no later than when its first Response flit is sent. It must keep **TXSACTIVE** asserted until after the final completing flit is sent for all Snoop transactions. The lifetime of a PrefetchTgt is a single flit. For the PrefetchTgt, the initiating flit is also the completing flit and the transaction can be considered complete in the following cycle after it is sent from the perspective of **TXSACTIVE**.

For an RN-F or RN-D, the **TXSACTIVE** output is the logical OR of the requirements for the Request interface and the Snoop interface.

### TXSACTIVE signaling from a Subordinate Node

A Subordinate Node cannot initiate new transactions and is only required to assert **TXSACTIVE** while it is processing a transaction that is in progress.

It must assert **TXSACTIVE** after receiving a transaction initiating flit and it must be asserted before or in the same cycle in which its first Response flit is sent. It must keep **TXSACTIVE** asserted until after the final completing flit is sent or received.

### TXSACTIVE signaling from an interconnect interface to a Request Node

The interconnect interface to a Request Node must assert **TXSACTIVE** in both the following conditions:

- On receiving a transaction initiating flit, it must be asserted before or in the same cycle in which its first Response flit is sent. It must keep **TXSACTIVE** asserted until after the final completing flit is sent or received.
- Before or in the same cycle in which its initiating Snoop or SnpDVMOp flit is sent. It must keep **TXSACTIVE** asserted until after the final completing flit is sent, which will be either SnpResp or SnpRespData.

### TXSACTIVE signaling from an interconnect interface to a Subordinate Node

The interconnect interface to a Subordinate Node must assert **TXSACTIVE** before or in the same cycle in which its initiating Request flit is sent. It must keep **TXSACTIVE** asserted until after the final completing flit is sent or received.

#### 14.7.3 RXSACTIVE signal

When **RXSACTIVE** is asserted, the receiver must respond to a link activation request in a timely manner. It is permitted for a Receiver to delay responding to a Link activation request when **RXSACTIVE** is deasserted.

— Note —

The deassertion of **RXSACTIVE** does not indicate that all Protocol layer activity has completed. It is possible for a Receiver to receive a Protocol flit, which corresponds to a transaction that was in progress while **RXSACTIVE** was asserted, after **RXSACTIVE** is deasserted.

**RXSACTIVE** can be used in combination with a knowledge of the ongoing transactions, which will be indicated by the components **TXSACTIVE** output, to indicate that no further transactions are required. This can be used to control entry to a low power state.

#### 14.7.4 Relationship between SACTIVE and LINKACTIVE

**SACTIVE** signaling is an indication of Protocol layer activity. A node can be considered inactive when both **TXSACTIVE** and **RXSACTIVE** are deasserted.

**LINKACTIVE** state is an indication of the Link layer activity. The Link layer at a node, or interconnect, can be considered inactive when its Receiver is in TxStop state and its receiver is in RxStop state.

**SACTIVE** signaling is orthogonal to the **LINKACTIVE** states with one constraint as specified in **RXSACTIVE** signal.

A node, or interconnect, should only enable higher-level clock gating and low power optimizations when both its Protocol and Link layers are inactive.



## Chapter 15

# System Coherency Interface

This chapter describes the interface signals that support connecting and disconnecting an RN-F from both the Coherency and DVM domains and an RN-D from the DVM domain. It contains the following sections:

- [Overview on page 15-466](#)
- [Handshake on page 15-467](#)

## 15.1 Overview

The system coherency interface signals are:

**SYSCOREQ** Requester coherency request.

**SYSCOACK** Interconnect coherency acknowledge.

Both **SYSCOREQ** and **SYSCOACK** signals must be synchronous to **CLK** and therefore are not required to be synchronized. If they cross a clock domain, the clock domain crossing bridge is required to synchronize the signals.

Figure 15-1 shows the system coherency interface signals connections.

![Diagram showing the system coherency interface signals connections. A box labeled 'RN-F or RN-D' contains the signals SYSCOREQ and SYSCOACK. These signals connect bidirectionally to a box labeled 'Interconnect'.](bae5758d5261f6e1c14edbd1f863af41_img.jpg)

Diagram showing the system coherency interface signals connections. A box labeled 'RN-F or RN-D' contains the signals SYSCOREQ and SYSCOACK. These signals connect bidirectionally to a box labeled 'Interconnect'.

Figure 15-1 System coherency interface signals

### Note

In this chapter:

- Coherency when stated, includes the DVM domain, unless explicitly stated otherwise.
- Snoop when stated, includes SnpDVMOp, unless explicitly stated otherwise.

## 15.2 Handshake

A Request Node, an RN-F or an RN-D, requests connection to system coherency by setting **SYSCOREQ** HIGH. The interconnect indicates that coherency is enabled by setting **SYSCOACK** HIGH.

The Request Node requests disconnection from system coherency by setting **SYSCOREQ** LOW. The interconnect indicates that coherency is disabled by setting **SYSCOACK** LOW.

Requests to enter and exit coherency are always initiated by the Request Node.

Figure 15-2 shows the system coherency interface handshake timing.

![Timing diagram showing the four-phase handshake between SYSCOREQ and SYSCOACK signals. The phases are: 1. Coherency Disabled (SYSCOREQ LOW, SYSCOACK LOW). 2. Coherency Connect (SYSCOREQ HIGH, SYSCOACK LOW). 3. Coherency Enabled (SYSCOREQ LOW, SYSCOACK HIGH). 4. Coherency Disconnect (SYSCOREQ HIGH, SYSCOACK LOW).](60aca185ab3994e47e435e0602aa9ada_img.jpg)

Timing diagram showing the four-phase handshake between SYSCOREQ and SYSCOACK signals. The phases are: 1. Coherency Disabled (SYSCOREQ LOW, SYSCOACK LOW). 2. Coherency Connect (SYSCOREQ HIGH, SYSCOACK LOW). 3. Coherency Enabled (SYSCOREQ LOW, SYSCOACK HIGH). 4. Coherency Disconnect (SYSCOREQ HIGH, SYSCOACK LOW).

Figure 15-2 System coherency interface handshake timing

As Figure 15-2 shows, the interface signaling obeys four-phase handshake rules:

- **SYSCOREQ** can only change when **SYSCOACK** is at the same logic state.
- **SYSCOACK** can only change when **SYSCOREQ** is at the opposite logic state.

### 15.2.1 RN rules

Referring to Figure 15-2, an RN must:

- Be able to service Snoop requests when it sets **SYSCOREQ** HIGH at **t1**.
- Not issue a transaction that permits it to cache a coherent location until **SYSCOACK** goes HIGH at **t2**.
- Ensure all transactions that permit it to cache a coherent location are complete before it sets **SYSCOREQ** LOW at **t3**.

**SYSCOREQ** can only be deasserted on the cycle after all of the following:

- All data packets are received for Reads.
- All data packets are sent for CopyBack.
- All data packets are sent for snoops and Forwarding snoops.

- Keep servicing Snoop requests until **SYSCOACK** is sampled LOW at **t4**.

**SACTIVE** must be asserted during coherency connect transition periods to guarantee the **SYSCOACK** transition occurs. See *Protocol layer activity indication* on page 14-460.

— Note —

The transactions that permit a coherent location to be cached are:

- ReadUnique
- ReadPreferUnique
- MakeReadUnique
- ReadClean
- ReadNotSharedDirty
- ReadShared
- CleanUnique
- MakeUnique

### 15.2.2 Interconnect rules

Referring to Figure 15-2 on page 15-467:

When the interconnect samples **SYSCOREQ HIGH** it must:

- Set **SYSCOACK HIGH** without waiting for responses to any Snoop requests that it has sent after **SYSCOREQ** goes HIGH.
- Be able to service coherent data accesses from the interface when it sets **SYSCOACK HIGH** at t2.

When the interconnect samples **SYSCOREQ LOW** it must:

- Complete all snoop accesses to the interface before it sets **SYSCOACK LOW** at t4.

### 15.2.3 Protocol states

Table 15-1 shows the interface states and the rules that the Requester must follow in relation to the interface state.

Table 15-1 System coherency interface states

| State name           | SYSCOREQ | SYSCOACK | Description                                                                                                                                                                                                                                                                                                                 |
|----------------------|----------|----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Coherency Disabled   | 0        | 0        | <ul><li>RN caches must not contain coherent data.</li><li>RN must not issue transactions that permit it to cache a coherent location or send DVM transactions.</li><li>RN not required to respond to Snoop requests.</li><li>Interconnect must not send Snoop requests.</li></ul>                                           |
| Coherency Connect    | 1        | 0        | <ul><li>RN caches must not contain coherent data.</li><li>RN must not issue transactions that permit it to cache a coherent location or send DVM transactions.</li><li>RN must respond to Snoop requests.</li><li>Interconnect can send Snoop requests.</li></ul>                                                           |
| Coherency Enabled    | 1        | 1        | <ul><li>RN caches can contain coherent data.</li><li>RN can issue transactions that cache a coherent location and send DVM transactions.</li><li>RN must respond to Snoop requests.</li></ul>                                                                                                                               |
| Coherency Disconnect | 0        | 1        | <ul><li>RN caches must not contain coherent data.</li><li>RN must not issue transactions that permit it to cache a coherent location or send DVM transactions.</li><li>RN must respond to Snoop requests.</li><li>Interconnect must complete outstanding Snoop requests but must not generate new Snoop requests.</li></ul> |

## Chapter 16

# Properties, Parameters, and Broadcast Signals

This chapter describes the properties, parameters, and optional broadcast signals that specify the behavior supported by an interface. It contains the following sections:

- [Interface properties and parameters on page 16-470](#)
- [Optional interface broadcast signals on page 16-474](#)
- [Atomic transaction support on page 16-478](#)

## 16.1 Interface properties and parameters

A property is used to declare a capability. If a property is not declared, it is considered False.

The properties and parameters that specify the interface behavior are:

### Atomic\_Transactions

An Atomic\_Transactions property is used to indicate if a component supports Atomic transactions:

- When not specified, or set to False, Atomic transactions are not supported.
- When set to True, Atomic transactions are supported.

A component that supports Atomic transactions must support all Atomic transactions. However, it is not required that a component that supports Atomic transactions supports the targeting of all memory types.

### Cache\_Stash\_Transactions

A Cache\_Stash\_Transactions property is used to indicate if a component supports Cache Stashing transactions:

- When not specified, or set to False, Cache Stashing transactions are not supported.
- When set to True, Cache Stashing Transactions are supported.

### Direct\_Memory\_Transfer

A Direct\_Memory\_Transfer property is used to indicate if a component supports Direct Memory Transfer transactions:

- When not specified, or set to False, Direct Memory Transfer transactions are not supported.
- When set to True, Direct Memory Transfer transactions are supported.
- The Direct\_Memory\_Transfer property is defined at each HN for each SN.

### Direct\_Cache\_Transfer

A Direct\_Cache\_Transfer property is used to indicate if a component supports Direct Cache Transfer transactions:

- When not specified, or set to False, Direct Cache Transfer transactions are not supported.
- When set to True, Direct Cache Transfer transactions are supported.
- It is the responsibility of the HN-F to determine the correct snoop type to use.

**Data\_Poison** A Data\_Poison property is used to indicate if a component supports Poison:

- When not specified, or set to False, Poison is not supported and the Poison field is not present in the DAT packet.
- When set to True, Poison is supported and the Poison field is present in the DAT packet.

See [Poison on page 9-347](#).

**Data\_Check** The Data Check property is used to indicate if Data Check is supported:

- When not specified, or set to False, Data Check is not supported and the DataCheck field is not present in the DAT packet.
- When set to Odd\_Parity, Data Check is supported and the DataCheck field is present in the DAT packet.

See [Data\\_Check on page 9-348](#).

**Check\_Type** The Check Type property is used to indicate the protection scheme employed on an interface:

- When not specified or set to False, no checking signals are present on the interface.
- When set to Odd\_Parity\_Byt\_Data, Odd parity checking is included for data signals only. Each parity signal covers up to 8 bits.

— **Note** —  
Only the DataCheck field is present.

- When set to Odd\_Parity\_Byt\_All, Odd parity checking is included for all functionally important signals. Each parity signal covers up to 8 bits.

— **Note** —  
A ParityCheck field covering the complete packet and control signals replaces the DataCheck field.

See [Use of interface parity on page 9-349](#).

#### CleanSharedPersistSep\_Request

The CleanSharedPersistSep\_Request property is used to indicate if a component supports CleanSharedPersistSep:

- When not specified, or set to False, the component does not support CleanSharedPersistSep and the component must not be sent a CleanSharedPersistSep request.
- When set to True, the component supports CleanSharedPersistSep.
- A Home that receives a CleanSharedPersistSep request must support such a request.
- A Home can track if a connected Subordinate supports CleanSharedPersistSep.
- If a Subordinate does not support CleanSharedPersistSep:
  - The Home must send a CleanSharedPersist instead of a CleanSharedPersistSep request to that Subordinate.
  - Home must take the responsibility of sending the Persist response to the Requester. This Persist response must only be sent after receiving the Comp response from the Subordinate.
- A Requester that does not support CleanSharedPersistSep will generate CleanSharedPersist instead.

#### MPAM\_Support

The MPAM\_Support property is used to indicate whether an interface supports MPAM.

- When not specified, or set to False, MPAM is not supported:
  - The interface is not MPAM enabled.
  - No MPAM signals are present on the interface.
- When set to MPAM\_9\_1, the interface is enabled for partitioning and monitoring:
  - It must include the MPAM signal on all address channels.
  - The width of PartID is 9 bits and the width of PerfMonGroup is 1bit.

How the MPAM field values are used by a receiver is IMPLEMENTATION DEFINED.

#### CCF\_Wrap\_Order

See [Critical chunk first wrap order on page 2-139](#).

#### Req\_Addr\_Width

This parameter specifies the maximum physical address supported by a component:

- Legal values for this parameter are 44 to 52.
- When Req\_Addr\_Width is not specified, the default value is 44.

#### NodeID\_Width

This parameter specifies the width of NodeID fields supported by a component, which determines the maximum permitted NodeID value in the system:

- The width specified is uniformly applied to all NodeID related fields.
- Legal values of NodeID\_Width are 7 to 11.
- When NodeID\_Width is not specified, the default value is 7.

#### Data\_Width

This parameter specifies the data width in the DAT channel packet supported by a component:

- Legal values for Data\_Width are 128, 256, and 512.
- When Data\_Width is not specified, the default value is 128.

#### Enhanced\_Features

The Enhanced\_Features property describes the combined support for some of the miscellaneous features in the CHI specification that do not have an explicit property or parameter defined.

When the Enhanced\_Features property is True, the component supports all the following enhanced features:

- Data return from SC state.
- I/O Deallocation transactions.
- ReadNotSharedDirty transaction.
- CleanSharedPersist transaction.
- Receiving of Forwarding snoops.

When not specified, or set to False, the component does not support the enhanced features that do not have an explicitly defined property or parameter.

## 16.1.1 DVM Property

A DVM\_Support property is used to indicate Arm ARM specification supported by a given component. When set to:

| <b>False</b>    | The component does not support any DVM transactions.                 |
|-----------------|----------------------------------------------------------------------|
| <b>DVM_v8</b>   | The component supports DVM transactions required to support Armv8.   |
| <b>DVM_v8.1</b> | The component supports DVM transactions required to support Armv8.1. |
| <b>DVM_v8.4</b> | The component supports DVM transactions required to support Armv8.4. |

In a system with heterogeneous components, it is the responsibility of the system configuration to determine the lowest common DVM specification supported in the system. The interconnect must have the knowledge of this lowest common denominator value by means of configuration, straps, parameterization, or some other IMPLEMENTATION DEFINED method.

To avoid deadlocks and denial of service, the interconnect must detect unsupported DVM operations. The interconnect must suppress unsupported DVM operation propagation and respond in a protocol-compliant manner. Error indication in such a response is optional.

### Note

The following expression can be used by the interconnect to determine if a DVM operation is a new one added in Armv8.4 and not supported by older specifications.

If the following expression is true, then the transaction is a DVM operation supported by Armv8.4 only.

```
[TLBI and ((hypervisor and Secure) or  
           (Guest OS and Secure and VMID) or  
           (Non-secure only) or  
           (Range))] OR  
[VICI and ((Guest OS and Secure and VMID))]
```

## 16.2 Optional interface broadcast signals

This specification includes six sets of optional pins to determine broadcasting of certain groups of transactions in the interconnect. These pins are optional at the Request Node to the interconnect, and the interconnect to the Subordinate Node interfaces. The optional broadcast pins are:

- *BROADCASTINNER and BROADCASTOUTER*
- *BROADCASTCACHEMAINTENANCE*
- *BROADCASTPERSIST*
- *BROADCASTATOMIC* on page 16-476
- *BROADCASTINVAL* on page 16-476
- *BROADCASTMTE* on page 16-476
- *BROADCASTERTLBINNER and BROADCASTERTLBOUTER* on page 16-476

An implementation that includes these signals at the interface must ensure that the signal values are stable when Reset is deasserted.

### 16.2.1 BROADCASTINNER and BROADCASTOUTER

The **BROADCASTINNER** and **BROADCASTOUTER** signals are used to control the issuing of Non-snoopable transactions from an interface. It is required that these two pins must be set to the same value.

When the signals are present and deasserted, all transactions are converted to Non-snoopable equivalents before they are sent. The transaction conversion from Snoopable to Non-snoopable, using the **BROADCASTINNER** and **BROADCASTOUTER** signals, the following conversions apply:

- All Read transactions must be converted to ReadNoSnp.
- All Snoopable CMO transactions must be converted to Non-snoopable CMO.
- The following Dataless transactions must be dropped:
  - CleanUnique
  - MakeUnique
  - Evict
  - StashOnce
  - StashOnce\*Unique
  - StashOnce\*Shared
- All Combined Writes must be converted to Combined WriteNoSnp.
- All Write transactions, except WriteEvictFull and WriteEvictOrEvict, must be converted to WriteNoSnp.
- WriteEvictFull and WriteEvictOrEvict transactions must be dropped.
- All Snoopable Atomic transactions must be converted to Non-snoopable.
- PrefetchTgt transaction conversion is not required.

### 16.2.2 BROADCASTCACHEMAINTENANCE

The **BROADCASTCACHEMAINTENANCE** signal is used to control the issuing of cache maintenance operations when there are no software-managed caches downstream of the interface.

When the **BROADCASTCACHEMAINTENANCE**, **BROADCASTINNER**, and **BROADCASTOUTER** signals are all present and deasserted:

- CleanShared, CleanInvalid, and MakeInvalid transactions are not issued.
- All Combined Write transactions must be converted to standalone Write transactions.

### 16.2.3 BROADCASTPERSIST

The **BROADCASTPERSIST** signal is used to control the issuing of CleanSharedPersist and CleanSharedPersistSep Cache Maintenance Operations.

When the **BROADCASTPERSIST** signal is present and deasserted, CleanSharedPersist and CleanSharedPersistSep transactions are converted to CleanShared. The conversion applies to both standalone CMO and Combined Write transactions.

— Note —

The issuing of the CleanShared is controlled by the **BROADCASTINNER**, **BROADCASTOUTER**, and **BROADCASTCACHMAINTENANCE** signals.

---

#### 16.2.4 BROADCASTATOMIC

The **BROADCASTATOMIC** signal is used to control the generation of Atomic transactions:

- When asserted, the interface is permitted to generate Atomic transactions.
- When deasserted, the interface must not generate Atomic transactions.

A Request Node is not required to make use of Atomic transactions. A Request Node that does not make use of Atomic transactions itself, needs no added functionality to be compatible with an interconnect that supports Atomic transactions.

A Request Node that supports atomic operations but does not include support for the execution of atomic operations must be able to send Atomic transactions.

See [Atomic transaction support on page 16-478](#).

#### 16.2.5 BROADCASTICINVAL

The **BROADCASTICINVAL** signal at each Request Node is used to inform the Request Node that broadcasting of Instruction Cache (*I*Cache) invalidations using the DVM mechanism is required:

- When asserted, DVMOp for ICache Invalidations must be sent to the interconnect.
- When deasserted, DVMOp for ICache invalidations are not required to be sent to the interconnect.

In a system where all Instruction Caches are fully coherent the hardware coherency mechanism automatically invalidates all ICache copies on a cache line update, In such systems, it is not necessary to broadcast ICache invalidation operations.

If a system contains one or more Instruction Caches that are not updated by the hardware coherency mechanism, then it is necessary for ICache invalidation operations to be broadcast using DVM transactions.

#### 16.2.6 BROADCASTMTE

The **BROADCASTMTE** signal is used to control the issuing of requests with MTE beyond the interface:

- When asserted, requests with MTE can be sent beyond the interface.
- When deasserted, requests with MTE must not be sent beyond the interface.

The **BROADCASTMTE** signal is typically deasserted when the interface does not support MTE functionality.

When the **BROADCASTMTE** signal is deasserted, all other MTE-related interface pins must be tied to zero. The interconnect is permitted to remove the related MTE transport wires.

The interface fields that can be fixed to a value of zero are:

- On DAT channels:
  - TagOp, Tag, and TU
- On REQ and RSP channels:
  - TagOp

#### 16.2.7 BROADCASTERTLBIINNER and BROADCASTTLBIOUTER

The **BROADCASTERTLBIINNER** (BTI) and **BROADCASTTLBIOUTER** (BTO) signals are used to control the issuing of TLBI operations in the interconnect.

Table 16-1 shows the permitted BTI and BTO signal encodings.

Table 16-1 BTI and BTO signal encodings

| BTI | BTO | Permitted |
|-----|-----|-----------|
| 0   | 0   | Yes       |
| 0   | 1   | Yes       |
| 1   | 0   | Reserved  |
| 1   | 1   | Yes       |

Note

The decision to broadcast a DVM(Sync) does not only depend on the values of BTI and BTO but must also consider if any DVM operations other than TLBI must be pushed to their completion by the DVM(Sync).

## 16.3 Atomic transaction support

The CHI component support requirements for Atomic transactions are described in the following sections:

- [Request Node support](#)
- [Interconnect support on page 16-479](#)
- [Subordinate Node support on page 16-479](#)

### 16.3.1 Request Node support

A Requester component is required to support a mechanism to suppress the generation of Atomic transactions to ensure compatibility in systems where Atomic transactions are not supported. A Requester can use the optional interface pin **BROADCASTATOMIC** to determine whether Atomic transactions are transmitted.

A Request Node is not required to make use of Atomic transactions. A Request Node that does not use Atomic transactions itself needs no added functionality to be compatible with an interconnect that supports Atomic transactions.

A Request Node that supports atomic operations but does not include support for the execution of atomic operations must be able to send Atomic transactions.

For a Request Node that supports both the execution of atomic operations as well as the sending of Atomic transactions the following applies:

- For cacheable locations, both Snoopable and Non-snoopable, a Request Node is able to perform an atomic operation locally without generating an Atomic transaction at its interface. To achieve this, the Requester obtains a copy of the location in its local cache, in the same manner that it would for a store operation, and then performs the atomic operation within its local cache. For cacheable locations that are Snoopable, if the contents of the cache line are updated and the cache line was not previously Dirty, then the cache line must be marked as Dirty.

### 16.3.2 Interconnect support

Interconnect support for Atomic transactions is optional.

The Atomic\_Transactions property is used to indicate that an interconnect supports Atomic transactions.

If Atomic transactions are not supported by the interconnect, all attached Request Nodes must be configured to not generate Atomic transactions. The **BROADCASTATOMIC** pin can be used for this purpose, when implemented. See [Request Node support on page 16-478](#).

For interconnects that support Atomic transactions, atomic operation execution can be supported at any point within an interconnect, including passing an Atomic transaction downstream to a Subordinate Node.

Atomic transactions are not required to be supported for every address location.

If Atomic transactions are supported for a given Snoopable address location, then they must be supported for the complete Snoopable address range.

If Atomic transactions are not supported for a given address location, then an appropriate Error response can be given for the Atomic transaction. See [Atomic transactions on page 9-342](#).

For transactions to a Device, the Atomic transaction must be passed to the appropriate endpoint Subordinate. If the Subordinate is configured to indicate that it does not support Atomic transactions, the interconnect must return an Error response for the transaction.

For Non-snoopable transactions, the Atomic transaction must be performed either:

- At a point, or past a point, where the transaction is visible to all other agents.
- At the endpoint.

For Snoopable transactions, the interconnect can either:

- Perform the atomic operation required by an Atomic transaction within the interconnect. This requires that the interconnect performs the appropriate Read, Write, and Snoop transactions to complete the Atomic transaction.
- If the appropriate endpoint Subordinate is configured to indicate that it supports Atomic transactions, the interconnect can pass the Atomic transaction to the Subordinate. The interconnect is still required to perform the appropriate Snoop and Write transactions before issuing the Atomic transaction to the Subordinate.

### 16.3.3 Subordinate Node support

Subordinate Node support for Atomic transactions is optional.

The Atomic\_Transaction property is used to indicate that a Subordinate Node supports Atomic transactions.

If a Subordinate Node supports Atomic transactions for particular memory types, or for particular address regions, then on receiving an Atomic transaction that it does not support, the Subordinate Node must give an appropriate Error response.



# Appendix A

## Message Field Mappings

This appendix shows the field mappings for the request, response, data, and snoop request messages. It contains the following sections:

- *Request message field mappings on page A-483*
- *Response message field mappings on page A-488*
- *Data message field mappings on page A-489*
- *Snoop Request message field mappings on page A-490*

Table A-1 shows the conventions used in the field mapping tables.

Table A-1 Key to field mapping table conventions

| Symbol | Description                                                                                        |
|--------|----------------------------------------------------------------------------------------------------|
| CF     | Common Field. Two or more protocol message fields share the same set of bits in this packet field. |
| X      | Inapplicable. Field value can take any value.                                                      |
| 1      | Applicable. Field value is used, must be set to one.                                               |
| 0      | Applicable. Field value is used, must be set to zero.                                              |
| 0*     | Inapplicable. Field value must be set to zero.                                                     |
| Y      | Applicable. Field value is used. See specification for permitted values and usage.                 |
| D      | Inapplicable. Field value must be default setting for MPAM fields.                                 |
| 8B     | Size field must be set to 8-byte encoding.                                                         |
| 64B    | Size field must be set to 64-byte encoding.                                                        |
| -      | Assigned to another protocol message field that shares the same set of bits in this packet field.  |

# **A.1 Request message field mappings**

[Table A-2](#page-482-0) and [Table A-3 on page A-484](#page-483-0) show the Read, Dataless and Miscellaneous Request message field mappings. See [Table A-1 on page A-482](#page-481-0) for the conventions used in the field mappings. For further information on field use see *[Protocol flit fields](#page-415-0)* on page 13-416.

**Table A-2 Read, Dataless and Miscellaneous Request message field mappings Part 1**

| Request message       | Qos | TgtID | SrcID | TxnID | Opcode | AllowRetry | PCrdType | RSVDC | TagOp | TraceTag | MPAM |
|-----------------------|-----|-------|-------|-------|--------|------------|----------|-------|-------|----------|------|
| ReqLCrdReturn         | X   | X     | X     | 0     | Y      | X          | X        | X     | X     | X        | X    |
| PCrdReturn            | Y   | Y     | Y     | 0a    | Y      | 0a         | Y        | Y     | 0a    | Y        | 0a   |
| DVMOp                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | 0a    | Y        | 0a   |
| PrefetchTgt           | Y   | Y     | Y     | X     | Y      | 0          | X        | Y     | Y     | Y        | Y    |
| ReadNoSnp             | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadNoSnpSep          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadOnce              | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadOnceCleanInvalid  | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadOnceMakeInvalid   | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadClean             | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadNotSharedDirty    | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadShared            | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadUnique            | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| ReadPreferUnique      | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| MakeReadUnique        | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| CleanShared           | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| CleanSharedPersist    | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| CleanSharedPersistSep | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| CleanInvalid          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| MakeInvalid           | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| CleanUnique           | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| MakeUnique            | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| Evict                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |

**Table A-3 Read, Dataless and Miscellaneous Request message field mappings Part 2**

|                       |      |    |         |          |           | MemAttr |         |         | CF        |       |              |      | CF      |            |      |                 | CF                |               |           | CF       |            |               | CF     |      |             | CF             |           |
|-----------------------|------|----|---------|----------|-----------|---------|---------|---------|-----------|-------|--------------|------|---------|------------|------|-----------------|-------------------|---------------|-----------|----------|------------|---------------|--------|------|-------------|----------------|-----------|
| Request message       | Addr | NS | Size    | Allocate | Cacheable | Device  | WA<br>E | SnpAttr | WT<br>DoD | Order | LikelyShared | Excl | SnoopMe | ExpCompAck | LPID | TagGroupID[4:0] | StashGroupID[4:0] | PGroupID[4:0] | ReturnNID | StashNID | SLCRepHint | StashNIDValid | Endian | Deep | ReturnTxnID | StashLPIDValid | StashLPID |
| ReqLCrdReturn         | X    | X  | X       | X        | X         | X       | X       | X       | X         | X     | X            |      | X       | X          |      |                 | X                 |               |           | X        |            |               | X      |      |             | X              |           |
| PCrdReturn            | 0a   | 0a | 0a      | 0a       | 0a        | 0a      | 0a      | 0a      | -         | 0a    | 0a           |      | 0a      | 0          |      |                 | 0a                |               |           | 0a       |            |               | 0a     |      |             | 0a             |           |
| DVMOp                 | Y    | 0a | 8B      | 0a       | 0a        | 0a      | 0a      | Y       | -         | 0a    | 0a           |      | 0a      | 0          | Y    | -               | -                 | -             |           | 0a       |            |               | 0a     |      |             | 0a             |           |
| PrefetchTgt           | Y    | Y  | X       | X        | X         | X       | X       | X       | X         | X     | X            | X    | -       | 0a         | Y    | -               | -                 | -             |           | 0a       |            |               | X      |      |             | 0a             |           |
| ReadNoSnp             | Y    | Y  | Y       | Y        | Y         | Y       | Y       | 0       | -         | Y     | 0            | Y    | -       | Y          | Y    | -               | -                 | -             | Y         | -        | Y          |               | 0a     |      | Y           | -              | -         |
| ReadNoSnpSep          | Y    | Y  | Y       | Y        | Y         | Y       | Y       | 0       | -         | Y     | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | Y         | -        | Y          |               | 0a     |      | Y           | -              | -         |
| ReadOnce              | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | 0            | 0    | -       | Y          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadOnceCleanInvalid  | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | 0            | 0    | -       | Y          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadOnceMakeInvalid   | Y    |    | Y 64B 0 |          | 1         | 0       | 1       | 1       | -         | Y     | 0            | 0    | -       | Y          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadClean             | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | Y    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadNotSharedDirty    | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | Y    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadShared            | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | Y    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadUnique            | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | 0    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| ReadPreferUnique      | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | Y    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| MakeReadUnique        | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | Y    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| CleanShared           | Y    |    | Y 64B Y |          | Y         | Y       | Y       | Y       | -         | 0a    | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| CleanSharedPersist    | Y    |    | Y 64B Y |          | Y         | Y       | Y       | Y       | -         | 0a    | 0            | 0    | -       | 0          |      |                 | 0a                |               | -         | -        | Y          | -             | -      | Y    |             | 0a             |           |
| CleanSharedPersistSep | Y    |    | Y 64B Y |          | Y         | Y       | Y       | Y       | -         | 0a    | 0            | 0    | -       | 0          | -    | -               | -                 | Y             | Y         | -        | Y          | -             | -      | Y    |             | 0a             |           |
| CleanInvalid          | Y    |    | Y 64B Y |          | Y         | Y       | Y       | Y       | -         | 0a    | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| MakeInvalid           | Y    |    | Y 64B Y |          | Y         | Y       | Y       | Y       | -         | 0a    | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| CleanUnique           | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | Y    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| MakeUnique            | Y    |    | Y 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | 0    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |
| Evict                 | Y    |    | Y 64B 0 |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      |             | 0a             |           |

[Table A-4](#page-484-0) and [Table A-5 on page A-486](#page-485-0) show the Write and Combined Write Request message field mappings. See [Table A-1 on page A-482](#page-481-0) for the conventions used in the field mappings. For further information on field use see *[Protocol flit fields](#page-415-0)* on page 13-416.

**Table A-4 Write and Combined Write Request message field mappings Part 1**

| Request message                | Qos | TgtID | SrcID | TxnID | Opcode | AllowRetry | PCrdType | RSVDC | TagOp | TraceTag | MPAM |
|--------------------------------|-----|-------|-------|-------|--------|------------|----------|-------|-------|----------|------|
| WriteNoSnpPtl                  | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpPtlCleanInv          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpPtlCleanSh           | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpPtlCleanShPerSep     | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpFull                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpFullCleanInv         | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpFullCleanSh          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpFullCleanShPerSep    | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteNoSnpZero                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniquePtlStash            | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniqueFullStash           | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniquePtl                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniquePtlCleanSh          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniquePtlCleanShPerSep    | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniqueFull                | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniqueFullCleanSh         | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniqueFullCleanShPerSep Y |     | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteUniqueZero                | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteBackPtl                   | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteBackFull                  | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteBackFullCleanInv          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteBackFullCleanSh           | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteBackFullCleanShPerSep     | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteCleanFull                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteCleanFullCleanSh          | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteCleanFullCleanShPerSep    | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
| WriteEvictFull                 | Y   | Y     | Y     | Y     | Y      | Y          | Y        | Y     | Y     | Y        | Y    |
|                                |     |       |       |       |        |            |          |       |       |          |      |

**Table A-5 Write and Combined Write Request message field mappings Part 2**

|                                |      |    |       |          |           | MemAttr |         |         | CF        |       |              |      | CF      |            |      | CF              |                   |               |           | CF       |            |               | CF     |      | CF                            |           |
|--------------------------------|------|----|-------|----------|-----------|---------|---------|---------|-----------|-------|--------------|------|---------|------------|------|-----------------|-------------------|---------------|-----------|----------|------------|---------------|--------|------|-------------------------------|-----------|
| Request message                | Addr | NS | Size  | Allocate | Cacheable | Device  | WA<br>E | SnpAttr | WT<br>DoD | Order | LikelyShared | Excl | SnoopMe | ExpCompAck | LPID | TagGroupID[4:0] | StashGroupID[4:0] | PGroupID[4:0] | ReturnNID | StashNID | SLCRepHint | StashNIDValid | Endian | Deep | StashLPIDValid<br>ReturnTxnID | StashLPID |
| WriteNoSnpPtl                  | Y    | Y  | Y     | Y        | Y         | Y       | Y       | 0       | Y         | Y     | 0            | Y    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteNoSnpPtlCleanInv          | Y    | Y  | Y     | Y        | Y         | Y       | Y       | 0       | Y         | Y     | 0            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteNoSnpPtlCleanSh           | Y    | Y  | Y     | Y        | Y         | Y       | Y       | 0       | Y         | Y     | 0            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteNoSnpPtlCleanShPerSep     | Y    | Y  | Y     | Y        | Y         | Y       | Y       | 0       | Y         | Y     | 0            | 0    | -       | Y          | -    | -               | -                 | Y             | -         | -        | Y          | -             | -      | Y    | 0a                            |           |
| WriteNoSnpFull                 | Y    | Y  | 64B Y |          | Y         | Y       | Y       | 0       | Y         | Y     | 0            | Y    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteNoSnpFullCleanInv         | Y    | Y  | 64B Y |          | Y         | Y       | Y       | 0       | Y         | Y     | 0            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteNoSnpFullCleanSh          | Y    | Y  | 64B Y |          | Y         | Y       | Y       | 0       | Y         | Y     | 0            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteNoSnpFullCleanShPerSep    | Y    | Y  | 64B Y |          | Y         | Y       | Y       | 0       | Y         | Y     | 0            | 0    | -       | Y          | -    | -               | -                 | Y             | -         | -        | Y          | -             | -      | Y    | 0a                            |           |
| WriteNoSnpZero                 | Y    | Y  | 64B Y |          | Y         | Y       | Y       | 0       | 0         | Y     | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteUniquePtlStash            | Y    | Y  | Y     | Y        | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | Y        | Y          | Y             | -      | -    | -<br>Y                        | Y         |
| WriteUniqueFullStash           | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | Y        | Y          | Y             | -      | -    | -<br>Y                        | Y         |
| WriteUniquePtl                 | Y    | Y  | Y     | Y        | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteUniquePtlCleanSh          | Y    | Y  | Y     | Y        | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteUniquePtlCleanShPerSep    | Y    | Y  | Y     | Y        | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | -    | -               | -                 | Y             | -         | -        | Y          | -             | -      | Y    | 0a                            |           |
| WriteUniqueFull                | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteUniqueFullCleanSh         | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteUniqueFullCleanShPerSep Y |      | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | Y          | -    | -               | -                 | Y             | -         | -        | Y          | -             | -      | Y    | 0a                            |           |
| WriteUniqueZero                | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | Y     | Y            | 0    | -       | 0          | Y    | Y               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteBackPtl                   | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | 0            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteBackFull                  | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteBackFullCleanInv          | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteBackFullCleanSh           | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteBackFullCleanShPerSep     | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | -    | -               | -                 | Y             | -         | -        | Y          | -             | -      | Y    | 0a                            |           |
| WriteCleanFull                 | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteCleanFullCleanSh          | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteCleanFullCleanShPerSep    | Y    | Y  | 64B Y |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | -    | -               | -                 | Y             | -         | -        | Y          | -             | -      | Y    | 0a                            |           |
| WriteEvictFull                 | Y    | Y  | 64B 1 |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |
| WriteEvictOrEvict              | Y    | Y  | 64B 1 |          | 1         | 0       | 1       | 1       | -         | 0     | Y            | 0    | -       | 1          | Y    | -               | -                 | -             | -         | -        | Y          |               | 0a     |      | 0a                            |           |

Table A-6 and Table A-7 on page A-487 show the Stash and Atomic Request message field mappings. See Table A-1 on page A-482 for the conventions used in the field mappings. For further information on field use see *Protocol flit fields* on page 13-416.

Table A-6 Stash and Atomic Request message field mappings part 1

| Request message    | Fields |      |      |      |        |            |          |       |       |          |      |  |  |  |  |  |
|--------------------|--------|------|------|------|--------|------------|----------|-------|-------|----------|------|--|--|--|--|--|
|                    | Gos    | TgID | SrID | TxID | Opcode | AllowRetry | PCrdType | RSVDC | TagOp | TraceTag | MPAM |  |  |  |  |  |
| StashOnceUnique    | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| StashOnceSepUnique | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| StashOnceShared    | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| StashOnceSepShared | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| AtomicLoad         | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| AtomicStore        | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| AtomicCompare      | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |
| AtomicSwap         | Y      | Y    | Y    | Y    | Y      | Y          | Y        | Y     | Y     | Y        | Y    |  |  |  |  |  |

Table A-7 Stash and Atomic Request message field mappings part 2

| Request message    | Addr |      | Size | Allocate | Cacheable | Device | EWA | SnpAttr | DoDWT | Order | LikelyShared | Excl | SnoopMe | ExpCompAck | LPID | TagGroupID[4:0] | StashGroupID[4:0] | PGroupID[4:0] | ReturnNID | StashNID | SLCRepHint | StashNIDValid | Endian | Deep | ReturnTxNID | StashLPIDValid | StashLPID |   |   |
|--------------------|------|------|------|----------|-----------|--------|-----|---------|-------|-------|--------------|------|---------|------------|------|-----------------|-------------------|---------------|-----------|----------|------------|---------------|--------|------|-------------|----------------|-----------|---|---|
|                    | NS   | Addr |      |          |           |        |     |         |       |       |              |      |         |            |      |                 |                   |               |           |          |            |               |        |      |             |                |           |   |   |
| StashOnceUnique    | Y    | Y    | 64B  | Y        | 1         | 0      | 1   | 1       | -     | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | Y        | Y          | Y             | -      | -    | -           | Y              | Y         | Y | Y |
| StashOnceSepUnique | Y    | Y    | 64B  | Y        | 1         | 0      | 1   | 1       | -     | 0     | Y            | 0    | -       | 0          | -    | -               | -                 | -             | -         | Y        | Y          | Y             | -      | -    | -           | Y              | Y         | Y | Y |
| StashOnceShared    | Y    | Y    | 64B  | Y        | 1         | 0      | 1   | 1       | -     | 0     | Y            | 0    | -       | 0          | Y    | -               | -                 | -             | -         | Y        | Y          | Y             | -      | -    | -           | Y              | Y         | Y | Y |
| StashOnceSepShared | Y    | Y    | 64B  | Y        | 1         | 0      | 1   | 1       | -     | 0     | Y            | 0    | -       | 0          | -    | -               | -                 | -             | -         | Y        | Y          | Y             | -      | -    | -           | Y              | Y         | Y | Y |
| AtomicLoad         | Y    | Y    | Y    | Y        | Y         | Y      | Y   | Y       | -     | Y     | 0            | -    | Y       | 0          | Y    | -               | -                 | -             | -         | Y        | -          | -             | -      | -    | -           | Y              | -         | - | - |
| AtomicStore        | Y    | Y    | Y    | Y        | Y         | Y      | Y   | Y       | -     | Y     | 0            | -    | Y       | 0          | Y    | -               | -                 | -             | -         | Y        | -          | -             | -      | -    | -           | Y              | -         | - | - |
| AtomicCompare      | Y    | Y    | Y    | Y        | Y         | Y      | Y   | Y       | -     | Y     | 0            | -    | Y       | 0          | Y    | -               | -                 | -             | -         | Y        | -          | -             | -      | -    | -           | Y              | -         | - | - |
| AtomicSwap         | Y    | Y    | Y    | Y        | Y         | Y      | Y   | Y       | -     | Y     | 0            | -    | Y       | 0          | Y    | -               | -                 | -             | -         | Y        | -          | -             | -      | -    | -           | Y              | -         | - | - |

## A.2 Response message field mappings

Table A-8 shows the Response message field mappings. See Table A-1 on page A-482 for the conventions used in the field mappings. For further information on field use see *Protocol flit fields* on page 13-416.

Table A-8 Response message field mappings

| Response message | QoS | Tgid | SrcID | TxnID          | Opcode | RespErr | Resp           | CBusy          | CF   |                |              | CF             |                |                |                |          |
|------------------|-----|------|-------|----------------|--------|---------|----------------|----------------|------|----------------|--------------|----------------|----------------|----------------|----------------|----------|
|                  |     |      |       |                |        |         |                |                | DBID | TagGroupID     | StashGroupID | PCrIDType      | FwdState       | DataTask       | TagOp          | TraceTag |
| RspLCrdReturn    | X   | X    | X     | 0              | Y      | X       | X              | X              | X    | X              | X            | X              | X              | X              | X              |          |
| SnResp           | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | Y    | -              | -            | 0 <sup>+</sup> | -              | Y              | 0 <sup>+</sup> | Y        |
| SnRespFwded      | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | X    | -              | -            | 0 <sup>+</sup> | Y              | -              | 0 <sup>+</sup> | Y        |
| CompAck          | Y   | Y    | Y     | Y              | Y      | 0       | 0 <sup>+</sup> | 0 <sup>+</sup> | X    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| RetryAck         | Y   | Y    | Y     | Y              | Y      | 0       | 0 <sup>+</sup> | Y              | X    | -              | -            | Y              | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| Comp             | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | Y    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y              | Y        |
| CompCMO          | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | X    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| Persist          | Y   | Y    | Y     | 0 <sup>+</sup> | Y      | Y       | 0 <sup>+</sup> | Y              | -    | -              | -            | Y              | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | X        |
| CompPersist      | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | -    | -              | -            | Y              | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| StashDone        | Y   | Y    | Y     | 0 <sup>+</sup> | Y      | Y       | 0 <sup>+</sup> | Y              | -    | -              | Y            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | X              | Y        |
| CompStashDone    | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | -    | -              | Y            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| RespSepData      | Y   | Y    | Y     | Y              | Y      | Y       | Y              | Y              | Y    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| CompDBIDResp     | Y   | Y    | Y     | Y              | Y      | Y       | 0              | Y              | Y    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| DBIDResp         | Y   | Y    | Y     | Y              | Y      | 0       | 0 <sup>+</sup> | Y              | Y    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| DBIDRespOrd      | Y   | Y    | Y     | Y              | Y      | 0       | 0 <sup>+</sup> | Y              | Y    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| TagMatch         | Y   | Y    | Y     | 0 <sup>+</sup> | Y      | Y       | Y              | Y              | -    | Y              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | X              | X        |
| PCrIDGrant       | Y   | Y    | Y     | 0 <sup>+</sup> | Y      | 0       | 0 <sup>+</sup> | Y              | -    | 0 <sup>+</sup> | -            | Y              | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |
| ReadReceipt      | Y   | Y    | Y     | Y              | Y      | 0       | 0 <sup>+</sup> | Y              | X    | -              | -            | 0 <sup>+</sup> | 0 <sup>+</sup> | 0 <sup>+</sup> | Y              | Y        |

# **A.3 Data message field mappings**

[Table A-9](#page-488-0) shows the Data message field mappings. See [Table A-1 on page A-482](#page-481-0) for the conventions used in the field mappings. For further information on field use see *[Protocol flit fields](#page-415-0)* on page 13-416.

**Table A-9 Data message field mappings**

|                   |     |       |       |       |        |         |      |       |      |      |        |       |    |      |         | CF       |          |            |          |           |        |       |     |    |
|-------------------|-----|-------|-------|-------|--------|---------|------|-------|------|------|--------|-------|----|------|---------|----------|----------|------------|----------|-----------|--------|-------|-----|----|
| Data message      | Qos | TgtID | SrcID | TxnID | Opcode | RespErr | Resp | CBusy | DBID | CCID | DataID | RSVDC | BE | Data | HomeNID | FwdState | DataPull | DataSource | TraceTag | DataCheck | Poison | TagOp | Tag | TU |
| DatLCrdReturn     | X   | X     | X     | 0     | Y      | X       | X    | X     | X    | X    | X      | X     | X  | X    | X       |          | X        |            | X        | X         | X      | X     | X   | X  |
| SnpRespData       | Y   | Y     | Y     | Y     | Y      | Y       | Y    | Y     | Y    | Y    | Y      | Y     | Y  | Y    | 0a      | -        | Y        | Y          | Y        | Y         | Y      | Y     | Y   | Y  |
| SnpRespDataFwded  | Y   | Y     | Y     | Y     | Y      | Y       | Y    | Y     | X    | Y    | Y      | Y     | Y  | Y    | 0a      | Y        | -        | -          | Y        | Y         | Y      | Y     | Y   | Y  |
| CopyBackWrData    | Y   | Y     | Y     | Y     | Y      | Y       | Y    | 0a    | X    | Y    | Y      | Y     | Y  | Y    | 0a      |          | 0a       |            | Y        | Y         | Y      | Y     | Y   | Y  |
| NonCopyBackWrData | Y   | Y     | Y     | Y     | Y      | Y       | Y    | 0a    | X    | Y    | Y      | Y     | Y  | Y    | 0a      |          | 0a       |            | Y        | Y         | Y      | Y     | Y   | Y  |
| NCBWrDataCompAck  | Y   | Y     | Y     | Y     | Y      | Y       | Y    | 0a    | X    | Y    | Y      | Y     | Y  | Y    | 0a      |          | 0a       |            | Y        | Y         | Y      | Y     | Y   | Y  |
| CompData          | Y   | Y     | Y     | Y     | Y      | Y       | Y    | Y     | Y    | Y    | Y      | Y     | X  | Y    | Y       | -        | -        | Y          | Y        | Y         | Y      | Y     | Y   | Y  |
| DataSepResp       | Y   | Y     | Y     | Y     | Y      | Y       | Y    | Y     | Y    | Y    | Y      | Y     | X  | Y    | Y       | -        | -        | Y          | Y        | Y         | Y      | Y     | Y   | Y  |
| SnpRespDataPtl    | Y   | Y     | Y     | Y     | Y      | Y       | Y    | Y     | Y    | Y    | Y      | Y     | Y  | Y    | 0a      | -        | Y        | Y          | Y        | Y         | Y      | Y     | Y   | Y  |
| WriteDataCancel   | Y   | Y     | Y     | Y     | Y      | Y       | Y    | 0a    | X    | Y    | Y      | Y     | 0  | Y    | 0a      |          | 0a       |            | Y        | Y         | Y      | Y     | Y   | Y  |

## A.4 Snoop Request message field mappings

Table A-10 shows the snoop request message field mappings. See Table A-1 on page A-482 for the conventions used in the field mappings. For further information on field use see *Protocol/field fields* on page 13-416.

Table A-10 Snoop Request message field mappings

| Snoop Request message | QoS | SrcID | TxnID | Opcode | Addr{43-51}:3 | NS | FwdNID         | Common Field   |                |           |        |                |                |          |                |
|-----------------------|-----|-------|-------|--------|---------------|----|----------------|----------------|----------------|-----------|--------|----------------|----------------|----------|----------------|
|                       |     |       |       |        |               |    |                | FwdTxnID       | StashLPIDValid | StashLPID | VMIExt | DoNotGoToSD    | RetToSrc       | TraceTag | MPAM           |
| SnplCrdReturn         | X   | X     | 0     | Y      | X             | X  | X              | X              | X              | X         | X      | X              | X              | X        | X              |
| SnplShared            | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | Y              | Y              | Y        | D              |
| SnplClean             | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | Y              | Y              | Y        | D              |
| SnplOnce              | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | Y              | Y              | Y        | D              |
| SnplNotSharedDirty    | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | Y              | Y              | Y        | D              |
| SnplUnique            | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | 1              | Y              | Y        | D              |
| SnplPreferUnique      | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | Y              | Y              | Y        | D              |
| SnplCleanShared       | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | 1              | 0 <sup>a</sup> | Y        | D              |
| SnplCleanInvalid      | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | 1              | 0 <sup>a</sup> | Y        | D              |
| SnplMakeInvalid       | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | 1              | 0 <sup>a</sup> | Y        | D              |
| SnplSharedFwd         | Y   | Y     | Y     | Y      | Y             | Y  | Y              | -              | -              | -         | Y      | 0 <sup>a</sup> | Y              | D        |                |
| SnplCleanFwd          | Y   | Y     | Y     | Y      | Y             | Y  | Y              | -              | -              | -         | Y      | 0 <sup>a</sup> | Y              | D        |                |
| SnplOnceFwd           | Y   | Y     | Y     | Y      | Y             | Y  | Y              | -              | -              | -         | Y      | 0 <sup>a</sup> | Y              | D        |                |
| SnplNotSharedDirtyFwd | Y   | Y     | Y     | Y      | Y             | Y  | Y              | -              | -              | -         | Y      | 0 <sup>a</sup> | Y              | D        |                |
| SnplUniqueFwd         | Y   | Y     | Y     | Y      | Y             | Y  | Y              | -              | -              | -         | 1      | 0 <sup>a</sup> | Y              | D        |                |
| SnplPreferUniqueFwd   | Y   | Y     | Y     | Y      | Y             | Y  | Y              | -              | -              | -         | Y      | 0 <sup>a</sup> | Y              | D        |                |
| SnplUniqueStash       | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | -              | Y              | Y         | -      | 1              | 0 <sup>a</sup> | Y        | Y              |
| SnplMakeInvalidStash  | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | -              | Y              | Y         | -      | 1              | 0 <sup>a</sup> | Y        | Y              |
| SnplStashUnique       | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | -              | Y              | Y         | -      | 1              | 0 <sup>a</sup> | Y        | Y              |
| SnplStashShared       | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | -              | Y              | Y         | -      | 1              | 0 <sup>a</sup> | Y        | Y              |
| SnplQuery             | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | 1              | 0 <sup>a</sup> | Y        | D              |
| SnplDVMOp             | Y   | Y     | Y     | Y      | Y             | Y  | 0 <sup>a</sup> | 0 <sup>a</sup> |                |           |        | 0 <sup>a</sup> | 0 <sup>a</sup> | Y        | 0 <sup>a</sup> |

## Appendix B

# Communicating Nodes

This appendix specifies, for each packet type, the nodes that communicate using that packet type. It contains the following sections:

- *Request communicating nodes* on page B-492.
- *Snoop communicating nodes* on page B-494.
- *Response communicating nodes* on page B-495.
- *Data communicating nodes* on page B-496.

## B.1 Request communicating nodes

Table B-1 shows the Request communicating nodes. In Table B-1, unless explicitly stated otherwise, a reference to a Write transaction includes both the individual Write transaction and the corresponding Combined Write transaction.

For some Requests, both an expected target and a permitted target are given. The use of the permitted target can occur in the case of a software based error. The permitted target must complete the transaction in a protocol compliant manner, this might require the use of an error response.

Table B-1 Request communicating nodes

| Request              | From             | To              | Expected | Permitted |
|----------------------|------------------|-----------------|----------|-----------|
| ReadNoSnp            | RN-F, RN-D, RN-I | ICN(HN-F, HN-I) | -        | -         |
| WriteNoSnpPtl        | ICN(HN-F)        | SN-F            | -        | -         |
| WriteNoSnpFull       | ICN(HN-I)        | SN-I            | -        | -         |
| WriteNoSnpZero       | ICN(HN-I)        | SN-I            | -        | -         |
| ReadNoSnpSep         | ICN(HN-F)        | SN-F            | -        | -         |
|                      | ICN(HN-I)        | SN-I            | -        | -         |
| ReadClean            | RN-F             | ICN(HN-F)       | -        | ICN(HN-I) |
| ReadShared           |                  |                 |          |           |
| ReadNotSharedDirty   |                  |                 |          |           |
| ReadUnique           |                  |                 |          |           |
| ReadPreferUnique     |                  |                 |          |           |
| MakeReadUnique       |                  |                 |          |           |
| CleanUnique          |                  |                 |          |           |
| MakeUnique           |                  |                 |          |           |
| Evict                |                  |                 |          |           |
| WriteBackPtl         |                  |                 |          |           |
| WriteBackFull        |                  |                 |          |           |
| WriteCleanFull       |                  |                 |          |           |
| WriteEvictFull       |                  |                 |          |           |
| WriteEvictOrEvict    |                  |                 |          |           |
| ReadOnce             | RN-F, RN-D, RN-I | ICN(HN-F)       | -        | ICN(HN-I) |
| ReadOnceCleanInvalid |                  |                 |          |           |
| ReadOnceMakeInvalid  |                  |                 |          |           |
| StashOnceUnique      |                  |                 |          |           |
| StashOnceShared      |                  |                 |          |           |
| StashOnceSepUnique   |                  |                 |          |           |
| StashOnceSepShared   |                  |                 |          |           |
| WriteUniqueFull      |                  |                 |          |           |
| WriteUniqueFullStash |                  |                 |          |           |
| WriteUniquePtl       |                  |                 |          |           |
| WriteUniquePtlStash  |                  |                 |          |           |
| WriteUniqueZero      |                  |                 |          |           |

Table B-1 Request communicating nodes (continued)

| Request                      | From             | To                  | Expected  | Permitted |
|------------------------------|------------------|---------------------|-----------|-----------|
| CleanShared                  | RN-F, RN-D, RN-I | ICN(HN-F, HN-I)     | -         | -         |
| CleanSharedPersist           | ICN(HN-F)        | SN-F                | -         | -         |
| CleanSharedPersistSep        | ICN(HN-I)        | SN-I                | -         | -         |
| CleanInvalid                 | ICN(HN-I)        | SN-I                | -         | -         |
| MakeInvalid                  | ICN(HN-I)        | SN-I                | -         | -         |
| WriteUniquePtlCleanSh        | RN-F             | ICN(HN-F)           | ICN(HN-I) | -         |
| WriteUniquePtlCleanShPerSep  | ICN(HN-F)        | SN-F                | -         | -         |
| WriteUniqueFullCleanSh       | ICN(HN-F)        | SN-F                | -         | -         |
| WriteUniqueFullCleanShPerSep | ICN(HN-F)        | SN-F                | -         | -         |
| WriteBackFullICleanInv       | ICN(HN-F)        | SN-F                | -         | -         |
| WriteBackFullICleanSh        | ICN(HN-F)        | SN-F                | -         | -         |
| WriteBackFullICleanShPerSep  | ICN(HN-F)        | SN-F                | -         | -         |
| WriteCleanFullCleanSh        | ICN(HN-F)        | SN-F                | -         | -         |
| WriteCleanFullCleanShPerSep  | ICN(HN-F)        | SN-F                | -         | -         |
| WriteNoSnpPtlCleanInv        | RN-F, RN-D, RN-I | ICN(HN-F, HN-I)     | -         | -         |
| WriteNoSnpPtlCleanSh         | ICN(HN-F)        | SN-F                | -         | -         |
| WriteNoSnpPtlCleanShPerSep   | ICN(HN-F)        | SN-F                | -         | -         |
| WriteNoSnpFullICleanInv      | ICN(HN-I)        | SN-I                | -         | -         |
| WriteNoSnpFullICleanSh       | ICN(HN-I)        | SN-I                | -         | -         |
| WriteNoSnpFullCleanShPerSep  | ICN(HN-I)        | SN-I                | -         | -         |
| DVMOp                        | RN-F, RN-D       | ICN(MN)             | -         | -         |
| PCrdReturn                   | RN-F, RN-D, RN-I | ICN(HN-F, HN-I, MN) | -         | -         |
|                              | ICN(HN-F)        | SN-F                | -         | -         |
|                              | ICN(HN-I)        | SN-I                | -         | -         |
| AtomicStore                  | RN-F, RN-D, RN-I | ICN(HN-F, HN-I)     | -         | -         |
| AtomicLoad                   | ICN(HN-F)        | SN-F                | -         | -         |
| AtomicSwap                   | ICN(HN-F)        | SN-F                | -         | -         |
| AtomicCompare                | ICN(HN-I)        | SN-I                | -         | -         |
| PrefetchTgt                  | RN-F, RN-D, RN-I | SN-F                | -         | -         |

## B.2 Snoop communicating nodes

Table B-2 on page B-494 shows the Snoop communicating nodes.

Table B-2 Snoop communicating nodes

| Snoop                | From      | To         |
|----------------------|-----------|------------|
| SnpShared            | ICN(HN-F) | RN-F       |
| SnpClean             |           |            |
| SnpOnce              |           |            |
| SnpNotSharedDirty    |           |            |
| SnpUnique            |           |            |
| SnpPreferUnique      |           |            |
| SnpCleanShared       |           |            |
| SnpCleanInvalid      |           |            |
| SnpMakeInvalid       |           |            |
| SnpSharedFwd         |           |            |
| SnpCleanFwd          |           |            |
| SnpOnceFwd           |           |            |
| SnpNotSharedDirtyFwd |           |            |
| SnpUniqueFwd         |           |            |
| SnpPreferUniqueFwd   |           |            |
| SnpUniqueStash       |           |            |
| SnpMakeInvalidStash  |           |            |
| SnpStashUnique       |           |            |
| SnpStashShared       |           |            |
| SnpQuery             |           |            |
| SnpDVMOp             | ICN(MN)   | RN-F, RN-D |

### B.3 Response communicating nodes

Table B-3 on page B-495 shows the Response communicating nodes.

Table B-3 Response communicating nodes

| Response      | From            | To                          |                             |
|---------------|-----------------|-----------------------------|-----------------------------|
| Upstream      | RetryAck        | ICN(HN-F, HN-I, MN)         | RN-F, RN-D, RN-I            |
|               | PCrdGrant       | SN-F                        | ICN(HN-F)                   |
|               | Comp            | SN-I                        | ICN(HN-I)                   |
|               | CompDBIDResp    | ICN(HN-F, HN-I)             | RN-F, RN-D, RN-I            |
|               | CompCMO         | SN-F                        | ICN(HN-F)                   |
|               | ReadReceipt     | SN-I                        | ICN(HN-I)                   |
|               | RespSepData     | ICN(HN-F, HN-I)             | RN-F, RN-D, RN-I            |
|               | DBIDResp        | ICN(HN-F, HN-I, MN)         | RN-F, RN-D, RN-I            |
|               |                 | SN-F                        | ICN(HN-F), RN-F, RN-D, RN-I |
|               |                 | SN-I                        | ICN(HN-I), RN-F, RN-D, RN-I |
| DBIDRespOrd   | ICN(HN-F, HN-I) | RN-F, RN-D, RN-I            |                             |
| StashDone     | ICN(HN-F)       | RN-F, RN-D, RN-I            |                             |
| CompStashDone |                 |                             |                             |
| TagMatch      | ICN(HN-F)       | RN-F, RN-D, RN-I            |                             |
|               | SN-F            | ICN(HN-F), RN-F, RN-D, RN-I |                             |
| Persist       | ICN(HN-F, HN-I) | RN-F, RN-D, RN-I            |                             |
|               | SN-F            | ICN(HN-F), RN-F, RN-D, RN-I |                             |
|               | SN-I            | ICN(HN-I), RN-F, RN-D, RN-I |                             |
| CompPersist   | ICN(HN-F, HN-I) | RN-F, RN-D, RN-I            |                             |
|               | SN-F            | ICN(HN-F)                   |                             |
|               | SN-I            | ICN(HN-I)                   |                             |
| Downstream    | CompAck         | RN-F, RN-D, RN-I            | ICN(HN-F, HN-I)             |
|               | SnpResp         | RN-F                        | ICN(HN-F)                   |
|               |                 | RN-F, RN-D                  | ICN(MN)                     |
|               | SnpRespFwded    | RN-F                        | ICN(HN-F)                   |

## B.4 Data communicating nodes

Table B-4 shows the Data communicating nodes.

For some Data, both an expected target and a permitted target are given. The use of the permitted target can occur in the case of an incorrect address decode. The permitted target must complete the transaction in a protocol compliant manner. In Table B-4, unless explicitly stated otherwise, a reference to a Write transaction includes both the individual Write transaction and the corresponding Combined Write transaction.

Table B-4 Data communicating nodes

| Data        |                   | From             | To                             |                  |
|-------------|-------------------|------------------|--------------------------------|------------------|
|             |                   |                  | Expected                       | Permitted        |
| Upstream    | CompData          | ICN(HN-F, HN-I)  | RN-F, RN-D, RN-I               | -                |
|             |                   | SN-F             | RN-F, RN-D,<br>RN-I, ICN(HN-F) | -                |
|             | DataSepResp       | SN-I             | RN-F, RN-D,<br>RN-I, ICN(HN-I) | -                |
|             |                   | ICN(HN-F, HN-I)  | RN-F, RN-D, RN-I               | -                |
| Downstream  | CopyBackWrData    | SN-F             | RN-F, RN-D, RN-I               | ICN(HN-F)        |
|             |                   | SN-I             | RN-F, RN-D, RN-I               | ICN(HN-I)        |
|             | WriteDataCancel   | RN-F             | ICN(HN-F)                      | ICN(HN-I)        |
|             |                   | RN-F, RN-D, RN-I | ICN(HN-F, HN-I)                | -                |
|             |                   | ICN(HN-F)        | SN-F                           | -                |
|             | NonCopyBackWrData | ICN(HN-I)        | SN-I                           | -                |
|             |                   | RN-F, RN-D, RN-I | ICN(HN-F, HN-I)                | -                |
|             |                   | RN-F, RN-D       | ICN(MN)                        | -                |
|             |                   | ICN(HN-F)        | SN-F                           | -                |
|             |                   | ICN(HN-I)        | SN-I                           | -                |
|             | NCBWrDataCompAck  | RN-F, RN-D, RN-I | ICN(HN-F, HN-I)                | -                |
|             |                   | RN-F             | ICN(HN-F)                      | -                |
| SnpRespData | SnpRespDataFwded  | RN-F             | ICN(HN-F)                      | -                |
|             | SnpRespDataPtl    | RN-F             | ICN(HN-F)                      | -                |
|             | Peer-to-Peer      | CompData         | RN-F                           | RN-F, RN-D, RN-I |

## Appendix C Revisions

This appendix describes the technical changes between released issues of this specification.

Table C-1 Issue B

| Change                           | Location |
|----------------------------------|----------|
| No changes, first public release | -        |

Table C-2 Issue C

| Change                                                                                                                                     | Location                                                                         |
|--------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| New feature: Response after receiving first Data packet.                                                                                   | <i>Allocating Read on page 2-41.</i><br><i>Non-allocating Read on page 2-44.</i> |
| New feature: Separate Non-data and Data-only response.                                                                                     | <i>Read transactions on page 2-41 and multiple related locations.</i>            |
| New feature: Combined CompAck with WriteData.                                                                                              | <i>WriteUnique transaction on page 2-107 and multiple related locations.</i>     |
| Clarification: Regarding byte enables for Write transactions.                                                                              | <i>Byte Enables on page 2-135.</i>                                               |
| Update: Concerning the list of fields that can change value from the original request in the retried request.                              | <i>Request Retry on page 2-145.</i>                                              |
| Clarification: Concerning the transaction responses permitted to be sent to the same address when a Snoop transaction response is pending. | <i>At the RN-F node on page 4-242.</i>                                           |

Table C-2 Issue C (continued)

| Change                                                                             | Location                                                                       |
|------------------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| Additional information: Concerning Legal RespErr field values for WriteDataCancel. | Table 9-7 on page 9-340.                                                       |
| Clarification: Regarding TraceTag field value propagation.                         | <i>TraceTag usage and rules</i> on page 11-368.                                |
| Corrections and additions: Concerning message field mappings.                      | Table A-3 on page A-484, Table A-8 on page A-488, and Table A-9 on page A-489. |

Table C-3 Issue D

| Change                                                                                                                                           | Location                                                                                                                                                                                                                                                                                                                                                                                                         |
|--------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| New feature: Persistent CMO with two part response.                                                                                              | <i>Dataless transactions</i> on page 2-73.<br><i>Dataless transactions</i> on page 2-101.<br><i>Cache Maintenance transactions</i> on page 4-170.<br><i>Details of transaction identifier fields</i> on page 2-87.<br><i>Persistent CMO with snoop and separate Comp and Persist</i> on page 5-258.<br><i>Interface properties and parameters</i> on page 16-470.<br><i>Dataless transactions</i> on page 9-339. |
| New feature: Deep Persistent cache maintenance.                                                                                                  | <i>Cache Maintenance transactions</i> on page 4-170.<br><i>Deep persistence, Deep</i> on page 13-426.                                                                                                                                                                                                                                                                                                            |
| New feature: Interface Parity.                                                                                                                   | <i>Use of interface parity</i> on page 9-349.<br><i>Interface properties and parameters</i> on page 16-470.                                                                                                                                                                                                                                                                                                      |
| New feature: <i>Memory System Performance Resource Partitioning and Monitoring</i> (MPAM).                                                       | <i>MPAM</i> on page 11-365.<br><i>Interface properties and parameters</i> on page 16-470.                                                                                                                                                                                                                                                                                                                        |
| New feature: Completer Busy indication.                                                                                                          | <i>Completer Busy</i> on page 11-367.                                                                                                                                                                                                                                                                                                                                                                            |
| New feature: ICache Invalidation broadcast signal.                                                                                               | <i>Optional interface broadcast signals</i> on page 16-474.                                                                                                                                                                                                                                                                                                                                                      |
| Additional requirement: Concerning <b>SACTIVE</b> synchronization to <b>CLK</b> .                                                                | <i>Protocol layer activity indication</i> on page 14-460.                                                                                                                                                                                                                                                                                                                                                        |
| Additional requirement: Concerning <b>SYSCOREQ</b> and <b>SYSCOACK</b> synchronization to <b>CLK</b> .                                           | Chapter 15 <i>System Coherency Interface</i> .                                                                                                                                                                                                                                                                                                                                                                   |
| Correction: Concerning the use of <b>RXSACTIVE</b> to directly generate the <b>TXSACTIVE</b> signal.                                             | <i>TXSACTIVE signal</i> on page 14-460.                                                                                                                                                                                                                                                                                                                                                                          |
| Update: Concerning Ordered Write Observation flow enhancements.                                                                                  | <i>Streaming Ordered Write transactions</i> on page 2-122.                                                                                                                                                                                                                                                                                                                                                       |
| Update: Concerning the relaxation of the order requirement between Cache Maintenance transactions and any other transaction to the same address. | <i>Cache Maintenance transactions</i> on page 4-170.                                                                                                                                                                                                                                                                                                                                                             |
| Update: Concerning <b>UD_PD</b> state is permitted on a <b>DataSepResp</b> response.                                                             | <i>Read and Atomic transaction completion</i> on page 4-197.                                                                                                                                                                                                                                                                                                                                                     |
| Update: Concerning DVM early Comp.                                                                                                               | <i>DVM early Comp for Non-sync DVMOps</i> on page 8-305.                                                                                                                                                                                                                                                                                                                                                         |

Table C-3 Issue D (continued)

| Change                                                                          | Location                                       |
|---------------------------------------------------------------------------------|------------------------------------------------|
| Update: Concerning increased TxnID width.                                       | <i>Flit packet definitions</i> on page 13-410. |
| Clarification: Regarding when a RespSepData response includes a Non-data Error. | <i>Read transactions</i> on page 9-337.        |
| Clarification: Regarding when the DataPull bit is set in a SnpRespData message. | <i>Data Pull, DataPull</i> on page 13-433.     |

Table C-4 Issue E.a

| Change                                                                                                                                                                                                   | Location                                                                                                                                                                                                                                                                                                                                                                                               |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| New feature: Writes with optional Data: <ul><li>WriteEvictOrEvict.</li></ul>                                                                                                                             | <i>CopyBack Write</i> on page 2-55.<br><i>CopyBack transactions</i> on page 4-177.<br><i>Chapter 9 Error Handling</i> .<br><i>Chapter 12 Memory Tagging</i> .                                                                                                                                                                                                                                          |
| New feature: Write Zero with no Data: <ul><li>WriteNoSnpZero.</li><li>WriteUniqueZero.</li></ul>                                                                                                         | <i>Immediate write</i> on page 2-49.<br><i>Transaction ordering</i> on page 2-118.<br><i>Write transactions</i> on page 4-176.<br><i>Chapter 9 Error Handling</i> .<br><i>Chapter 12 Memory Tagging</i> .                                                                                                                                                                                              |
| New feature: SnpQuery Snoop request.                                                                                                                                                                     | <i>Snoop request types</i> on page 4-191.<br><i>Chapter 9 Error Handling</i> .                                                                                                                                                                                                                                                                                                                         |
| New feature: DBIDRespOrd response.                                                                                                                                                                       | <i>Immediate write</i> on page 2-49.<br><i>Miscellaneous response</i> on page 4-207.                                                                                                                                                                                                                                                                                                                   |
| New feature: New transactions to support Exclusive reads: <ul><li>ReadPreferUnique.</li><li>SnpPreferUnique.</li><li>SnpPreferUniqueFwd.</li><li>MakeReadUnique.</li><li>MakeReadUnique(Excl).</li></ul> | <i>Read transactions</i> on page 2-41.<br><i>Stash transactions</i> on page 2-69.<br><i>Read transactions</i> on page 4-163.<br><i>Snoop request types</i> on page 4-191.<br><i>MakeReadUnique transaction</i> on page 4-213.<br><i>Exclusive transactions</i> on page 6-286.<br><i>MakeReadUnique(Excl)</i> on page 6-288.<br><i>Chapter 9 Error Handling</i> .<br><i>Chapter 12 Memory Tagging</i> . |
| New feature: Direct Write-data Transfer.                                                                                                                                                                 | <i>Write Transactions</i> on page 2-49.<br><i>Do Direct Write Transfer, DoDWT</i> on page 13-430.                                                                                                                                                                                                                                                                                                      |
| New feature: Combined Write transactions: <ul><li>CompCMO.</li></ul>                                                                                                                                     | <i>Transaction classification</i> on page 1-24.<br><i>Combined Immediate Write and CMO</i> on page 2-56.<br><i>Combined Write requests</i> on page 4-182.                                                                                                                                                                                                                                              |
| New feature: Two-part StashOnce transaction including: <ul><li>StashOnceSep requests.</li><li>StashDone response.</li><li>CompStashDone response.</li></ul>                                              | <i>Stash transactions</i> on page 2-69<br><i>StashOnce or StashOnceSep transaction</i> on page 2-109.<br><i>Dataless transactions</i> on page 4-169.<br><i>Independent Stash request</i> on page 7-297.<br><i>Chapter 9 Error Handling</i> .<br><i>Chapter 12 Memory Tagging</i> .                                                                                                                     |

Table C-4 Issue E.a (continued)

| Change                                                                                                                                | Location                                                                    |
|---------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| New feature: Forward indication on Snoop forward treated as a hint.                                                                   | <i>Request transactions and corresponding Snoop requests on page 4-194.</i> |
| New feature: Increasing inter-port bandwidth: <ul><li>Multiple interfaces.</li><li>Replicated channels.</li></ul>                     | <i>Increasing inter-port bandwidth on page 13-402.</i>                      |
| New feature: Memory tagging.                                                                                                          | <i>Chapter 12 Memory Tagging.</i>                                           |
| New feature: Extending DVM operations: <ul><li>Range based TLBI.</li><li>Level hint in TLBI operations,</li><li>DVM Domain.</li></ul> | <i>Chapter 8 DVM Operations.</i>                                            |
| New feature: SLC replacement hint.                                                                                                    | <i>SLC replacement hint on page 11-363.</i>                                 |
| Additional requirement: Concerning Transaction Ordering guarantees.                                                                   | <i>Transaction ordering on page 2-118.</i>                                  |
| Additional requirement: Concerning change in WriteNoSnpFull behavior.                                                                 | <i>Write Transactions on page 2-49.</i>                                     |
| Correction: Concerning Size field value in ReadNoSnpSep.                                                                              | <i>Read transactions on page 4-163.</i>                                     |
| Correction: Concerning the Ordering guarantees provided by the Comp and CompData response.                                            | <i>Completion response and ordering on page 2-114.</i>                      |
| Update: Concerning removal of the DoNotDataPull attribute on snoops.                                                                  | -                                                                           |
| Update: Concerning extending the GroupID field width.                                                                                 | <i>See Table C-5 on page C-501 for further information.</i>                 |
| Update: Concerning extending the TxnID field width.                                                                                   | <i>Flit packet definitions on page 13-410.</i>                              |
| Update: Concerning ICache invalidation operations.                                                                                    | <i>Virtual Instruction Cache Invalidate on page 8-330.</i>                  |
| Update: Concerning Secure EL2 TLBI operations.                                                                                        | <i>TLB Invalidate on page 8-322.</i>                                        |
| Update: Concerning the Order requirements between transactions with different Order field values. <sup>a</sup>                        | <i>Transaction ordering on page 2-118.</i>                                  |
| Clarification: Regarding Comp and cancelled Write.                                                                                    | <i>Write Transactions on page 2-49.</i>                                     |
| Clarification: Regarding CopyBack Write transaction and RetryAck response.                                                            | <i>Request Retry on page 2-145.</i>                                         |
| Clarification: Regarding the SnpAttr and Cacheable field value in a standalone CMO transaction.                                       | <i>Cache Maintenance transactions on page 4-170.</i>                        |
| Clarification: Regarding the attributes of Exclusive accesses.                                                                        | <i>Exclusive monitors on page 6-283.</i>                                    |
| Clarification: Regarding the receiving of WriteData and the sending of the Persist response.                                          | <i>Cache Maintenance transactions on page 4-170.</i>                        |

a. This Update applies retroactively to CHI Issue D.

Table C-5 Issue E.b

| Change                                                                                                                                                       | Location                                                            |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------|
| Update: All offensive terminology has been replaced per Arm's commitment to progressive terminology.                                                         | Throughout the specification.                                       |
| Update: Restructured and reformatted Transaction structures section.                                                                                         | <i>Transaction structure on page 2-40</i>                           |
| Clarification: SnpAttr bit reuse in DVMOp and inapplicability in PrefetchTgt.                                                                                | <i>Table 2-13 on page 2-132</i>                                     |
| Update: SLCrepHint value is permitted to be different in the resent request.                                                                                 | <i>Request Retry on page 2-145</i>                                  |
| Clarification: Simultaneous pending of CMO and allocating requests to the same address.                                                                      | <i>Cache Maintenance transactions on page 4-170</i>                 |
| Correction: Request Order permitted in WriteNoSnpZero from HN-1 to SN-1.                                                                                     | <i>Non-CopyBack transactions on page 4-176</i>                      |
| Update: Re-write of transactions, grouping common characteristics.                                                                                           | <i>Request types on page 4-162</i>                                  |
| Clarification: Permitted attribute values for requests, initial cache state at the Requester, and final cache state at the Requester outlined.               | <i>Request types on page 4-162</i>                                  |
| Correction: Order field value 0b00 and 0b01 permitted in ReadNoSnp <sup>4</sup> .                                                                            | <i>Read transactions on page 4-163</i>                              |
| Correction: Security field 0b10 in PCI DVM operation expanded to include both Secure and Non-secure.                                                         | <i>Table 8-7 on page 8-315</i>                                      |
| Clarification: Corrupt data must be marked with Poison, DERR, or NDERR.                                                                                      | <i>Error response use by transaction type on page 9-337</i>         |
| Clarification: Poison on MTE is not supported.                                                                                                               | <i>Poison on page 9-347<br/>Non-Tag Match errors on page 12-386</i> |
| Correction: Legal RespErr field tables corrected.                                                                                                            | <i>Table 9-6 on page 9-340</i>                                      |
| Correction: Transaction error cannot be indicated in DBIDResp response.                                                                                      | <i>Table 9-6 on page 9-340</i>                                      |
| Update: All four combinations of Request NS and MPAMNS field values are legal <sup>4</sup> .                                                                 | <i>MPAMNS on page 11-365</i>                                        |
| Clarification: MTE fields are inapplicable and must be set to zero in WriteDataCancel write data response.                                                   | <i>TagOp, TU, and tags relationship on page 12-378</i>              |
| Update: Redundant GroupIDExt field definition is removed from the specification                                                                              | <i>Protocol flit fields on page 13-416</i>                          |
| Clarification: Re-write of protocol flit fields.                                                                                                             | <i>Protocol flit fields on page 13-416</i>                          |
| Correction: Requirements for DoNotGoToSD in SnpQuery updated.                                                                                                | <i>Do not transition to SD state, DoNotGoToSD on page 13-434</i>    |
| Correction: Link deactivation and sending of protocol flits updated. Race conditions section deleted.                                                        | <i>Table 14-3 on page 14-451</i>                                    |
| Clarification: Restructured and reformatted Broadcast signals.                                                                                               | <i>Optional interface broadcast signals on page 16-474</i>          |
| Correction: TagGroupID field is applicable in WriteNoSnpPtl, WriteNoSnpFull, WriteUniquePtlStash, WriteUniqueFullStash, WriteUniquePtl, and WriteUniqueFull. | <i>Table A-5 on page A-486</i>                                      |

Table C-5 Issue E.b (continued)

| Change                                                                                                                                      | Location                                                           |
|---------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|
| Correction: PGroupID field applicable in WriteNoSnpPtl, WriteNoSnpFull, WriteUniquePtl, WriteUniqueFull, WriteCleanFull, and WriteBackFull. | Table A-5 on page A-486                                            |
| Correction: Deep field in all CleanSharedPersist* and Write*CleanShPerSep requests applicable.                                              | Table A-5 on page A-486                                            |
| Correction: SLCRepHint not applicable for Atomic transactions                                                                               | Table A-7 on page A-487                                            |
| Clarification: UniqueDirtyPartial cache line can have none, some, or all bytes valid.                                                       | Cache state model on page 1-27 and Cache line states on page 4-160 |

a. This correction is applied retrospectively to CHI Issue C, Issue D, and Issue E.a.  
b. This update is applied retrospectively to CHI Issue D and Issue E.a.

# Glossary

This glossary describes some of the technical terms used in AMBA 5 CHI documentation.

## Advanced Microcontroller Bus Architecture (AMBA)

The AMBA family of protocol specifications is the ARM open standard for on-chip buses. AMBA provides solutions for the interconnection and management of the functional blocks that make up a *System-on-Chip* (SoC). Applications include the development of embedded systems with one or more processors or signal processors and multiple peripherals.

## Aligned

A data item stored at an address that is divisible by the highest power of 2 that divides into its size in bytes. Aligned halfwords, words, and doublewords therefore have addresses that are divisible by 2, 4, and 8 respectively.

An aligned access is one where the address of the access is aligned to the size of each element of the access.

## AMBA

See [Advanced Microcontroller Bus Architecture \(AMBA\)](#).

## At approximately the same time

Two events occur at approximately the same time if a remote observer might not be able to determine the order in which they occurred.

## Barrier

An operation that forces a defined ordering of other actions.

## Blocking

Describes an operation that prevents following actions from continuing until the operation completes.

A non-blocking operation can permit following operations to continue before it completes.

## Byte

An 8-bit data item.

## Cache

Any cache, buffer, or other storage structure that can hold a copy of the data value for a particular address location.

## Cache hierarchy

The organization of different size caches in a hierarchy, typically with the cache with faster access and smaller size closer to the core and larger and slower access ones farther away from the core. The last level of this hierarchy might be connected to the memory. In this specification, in relation to a referenced cache, above refers to caches closer to the core, and below refers to caches farther from the core.

| <b>Cache line</b>           | The basic unit of storage in a cache. Its size in words is always a power of two. A cache line must be aligned to the size of the cache line.<br>The size of the cache line is equivalent to the coherency granule.<br><i>See also Coherency granule.</i>                                                                                                                                                                                                                                                                                                                                      |
|-----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>Cache state</b>          | State of a block of data in a cache, of 64-byte size in this specification. The state determines if the block is cached in any other caches in the system and also if it is different from the copy of the block in memory. See <i>Cache state model</i> on page 1-27 for a description of the cache states supported in this specification.                                                                                                                                                                                                                                                   |
| <b>Channel</b>              | A set of signals grouped together to communicate a particular set of messages between a transmitter and receiver pair. For example Request channel is used to communicate request messages.<br>A channels consist of a set of information signals and a separate Valid and Credit signal to provide the channel handshake mechanism.                                                                                                                                                                                                                                                           |
| <b>Coherent</b>             | Data accesses from a set of observers to a memory location are coherent accesses to that memory location by the members of the set of observers are consistent with there being a single total order of all writes to that memory location by all members of the set of observers.                                                                                                                                                                                                                                                                                                             |
| <b>Coherency granule</b>    | The minimum size of the block of memory affected by any coherency consideration. For example, an operation to make two copies of an address coherent makes the two copies of a block of memory coherent, where that block of memory is: <ul><li>At least the size of the coherency granule.</li><li>Aligned to the size of the coherency granule.</li></ul> <i>See also Cache line.</i>                                                                                                                                                                                                        |
| <b>Completer</b>            | <i>See Completer</i> on page 1-22.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <b>Component</b>            | A distinct functional unit that has at least one AMBA interface. Component can be used as a general term for Requester, Subordinate, peripheral, and interconnect components.<br><i>See also Interconnect component, Requester component, Memory Subordinate component, Peripheral Subordinate component, Subordinate component.</i>                                                                                                                                                                                                                                                           |
| <b>Deprecated</b>           | Something that is present in the specification for backwards compatibility. Whenever possible you must avoid using deprecated features. These features might not be present in future versions of the specification.                                                                                                                                                                                                                                                                                                                                                                           |
| <b>Device</b>               | <i>See Peripheral Subordinate component.</i>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <b>Direct Data Transfer</b> | Sending Read data directly from a Snoopee or Subordinate to the Requester bypassing the Home Node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <b>Downstream</b>           | A transaction operates between a Requester component and one or more Subordinate components, and can pass through one or more intermediate components. At any intermediate component, for a given transaction, <i>downstream</i> means between that component and a destination Subordinate component, and includes the destination Subordinate component.<br>Downstream and upstream are defined relative to the transaction as a whole, not relative to individual data flows within the transaction.<br><i>See also Requester component, Peer to Peer, Subordinate component, Upstream.</i> |
| <b>Downstream Cache</b>     | <i>See Downstream cache</i> on page 1-21.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <b>Endpoint</b>             | <i>See Endpoint</i> on page 1-22.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <b>Final Destination</b>    | Final destination for a Memory transaction is a peripheral or physical memory, also called an Endpoint.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <b>Flit</b>                 | <i>See Flit</i> on page 1-21.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <b>HN</b>                   | <i>See HN</i> on page 1-22.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |

## ICN

See ICN on page 1-22.

## In a timely manner

See In a timely manner on page 1-23.

## IMPLEMENTATION DEFINED

Behavior that is not defined by the architecture, but is defined and documented by individual implementations.

When IMPLEMENTATION DEFINED appears in body text, it is always in small capitals.

## IMPLEMENTATION SPECIFIC

Behavior that is not architecturally defined, and might not be documented by an individual implementation. Used when there are a number of implementation options available and the option chosen does not affect software compatibility.

When IMPLEMENTATION SPECIFIC appears in body text, it is always in small capitals.

## Interconnect component

A component with more than one AMBA interface that connects one or more Requester components to one or more Subordinate components.

An interconnect component can be used to group together either:

- A set of Requesters so that they appear as a single Requester interface.
- A set of Subordinates so that they appear as a single Subordinate interface.

See also Component, Requester component, Subordinate component.

## IO Coherent node

See IO Coherent node on page 1-23.

## Line

See Cache line.

## Link

A Link is the connection used for communicating between a transmitter and receiver pair.

## Link layer Credit

See Link layer Credit on page 1-22.

## Load

The action of a Requester component reading the value held at a particular address location. For a processor, a load occurs as the result of executing a particular instruction. Whether the load results in the Requester issuing a Read transaction depends on whether the accessed cache line is held in the local cache.

See also Speculative read, Store.

## Main memory

The memory that holds the data value of an address location when no cached copies of that location exist. For any location, main memory can be out of date with respect to the cached copies of the location, but main memory is updated with the most recent data value when no cached copies exist neither in the RNs nor in the Interconnect.

Main memory can be referred to as memory when the context makes the intended meaning clear.

## Requester

See Requester on page 1-22.

## Requester component

A component that initiates transactions.

It is possible that a single component can act as both a Requester component and as a Subordinate component. For example, a Direct Memory Access (DMA) component can be a Requester component when it is initiating transactions to move data, and a Subordinate component when it is being programmed.

See also Component, Interconnect component, Subordinate component.

## Memory Management Unit (MMU)

Provides detailed control of the part of a memory system that provides address translation. Most of the control is provided using translation tables that are held in memory, and define the attributes of different regions of the physical memory map.

See also System Memory Management Unit (SMMU).

**Memory Subordinate component**

A Memory Subordinate component, or *Memory Subordinate*, is a Subordinate component with the following properties:

- A read of a byte from a Memory Subordinate returns the last value written to that byte location.
- A write to a byte location in a Memory Subordinate updates the value at that location to a new value that is obtained by subsequent reads.
- Reading a location multiple times has no side-effects on any other byte location.
- Reading or writing one byte location has no side-effects on any other byte location.

See also *Component*, *Requester component*, *Peripheral Subordinate component*.

**Message**

See *Message on page 1-21*.

**Observer**

A processor or other Requester component, such as a peripheral device, that can generate reads from or writes to memory.

**Outstanding Request**

A transaction is outstanding from the cycle that the Request is first issued until either:

- The transaction is fully completed, as determined by the return of all responses that are expected for the transaction.
- It receives RetryAck and PCrdGrant and is either:
  - Retried using a credit of the appropriate PCrdType, and then is fully completed as determined above.
  - Canceled, and returns the received credit using the PCrdReturn message.

**Peer node**

A protocol node of the same type with reference to itself. For example, the peer node for a Request Node is another Request Node.

**Peer to Peer**

Communication between the same type of nodes. For example, from one RN to another RN.

See also *Downstream*, *Upstream*.

**Peripheral Subordinate component**

A Peripheral Subordinate component is also described as a *Peripheral Subordinate*. This specification recommends that a Peripheral Subordinate has an *IMPLEMENTATION DEFINED* method of access that is typically described in the data sheet for the component. Any access that is not defined as permitted might cause the Peripheral Subordinate to fail, but must complete in a protocol-compliant manner to prevent system deadlock. The protocol does not require continued correct operation of the peripheral.

See also *Memory Subordinate component*, *Subordinate component*.

**Permission to store**

A component has permission to store if it can perform a store to the associated cache line without informing any other components or the interconnect.

**Packet**

See *Packet on page 1-21*.

**Phit**

See *Phit on page 1-21*.

**PoC**

See *PoC on page 1-21*.

**PoS**

See *PoS on page 1-21*.

**PoP**

See *PoP on page 1-21*.

| <b>Prefetching</b>                          | Prefetching refers to speculatively fetching instructions or data from the memory system. In particular, instruction prefetching is the process of fetching instructions from memory before the instructions that precede them, in simple sequential execution of the program, have finished executing. Prefetching an instruction does not mean that the instruction has to be executed.<br>In this specification, references to instruction or data fetching apply also to prefetching, unless the context explicitly indicates otherwise. |
|---------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <b>Protocol Credit</b>                      | See <a href="#">Protocol Credit on page 1-22</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <b>Requester</b>                            | See <a href="#">Requester on page 1-22</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <b>RN</b>                                   | See <a href="#">RN on page 1-22</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <b>Subordinate</b>                          | See <a href="#">Subordinate on page 1-22</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <b>Subordinate component</b>                | A component that receives transactions and responds to them.<br>It is possible that a single component can act as both a Subordinate component and as a Requester component. For example, a Direct Memory Access (DMA) component can be a Subordinate component when it is being programmed and a Requester component when it is initiating transactions to move data.<br>See also <a href="#">Requester component</a> , <a href="#">Memory Subordinate component</a> , <a href="#">Peripheral Subordinate component</a> .                   |
| <b>SN</b>                                   | See <a href="#">SN on page 1-22</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <b>Snooped cache</b>                        | A hardware-coherent cache that receives Snoop transactions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <b>Snoop filter</b>                         | A snoop filter is able to track the cache lines that might be allocated within a Requester.                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <b>Speculative read</b>                     | A transaction that a component issues when it might not need the transaction to be performed because it already has a copy of the accessed cache line in its local cache. Typically, a speculative read is performed in parallel with a local cache lookup. This gives lower latency than looking in the local cache first, and then issuing a Read transaction only if the required cache line is not found in the local cache.<br>See also <a href="#">Load</a> .                                                                          |
| <b>Stash</b>                                | The action of placing data in a cache closer to the agent that is expected to be the next user of the data.                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <b>Store</b>                                | The action of a Requester component changing the value held at a particular address location. For a processor, a store occurs as the result of executing a particular instruction. Whether the store results in the Requester issuing a Read or Write transaction depends on whether the accessed cache line is held in the local cache, and if it is in the local cache, the state it is in.<br>See also <a href="#">Load</a> , <a href="#">Permission to store</a> .                                                                       |
| <b>Synchronization barrier</b>              | See <a href="#">Barrier</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <b>System Memory Management Unit (SMMU)</b> | A system-level MMU. That is, a system component that provides address translation from one address space to another. An SMMU provides one or more of: <ul><li><i>Virtual Address (VA) to Physical Address (PA) translation.</i></li><li><i>VA to Intermediate Physical Address (IPA) translation.</i></li><li><i>IPA to PA translation.</i></li></ul> See also <a href="#">Memory Management Unit (MMU)</a> .                                                                                                                                |
| <b>TLB</b>                                  | See <a href="#">Translation Lookaside Buffer (TLB)</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| <b>Transaction</b>                          | See <a href="#">Transaction on page 1-21</a> .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |

**Translation Lookaside Buffer (TLB)**

A memory structure containing the results of translation table walks. TLBs help to reduce the average cost of a memory access.

See also [System Memory Management Unit \(SMMU\)](#), [Translation table](#), [Translation table walk](#).

**Translation table**

A table held in memory that defines the properties of memory areas of various sizes from 1KB.

See also [Translation Lookaside Buffer \(TLB\)](#), [Translation table walk](#).

**Translation table walk**

The process of doing a full translation table lookup.

See also [Translation Lookaside Buffer \(TLB\)](#), [Translation table](#).

**Unaligned**

An unaligned access is an access where the address of the access is not aligned to the size of an element of the access.

**Unaligned memory accesses**

Are memory accesses that are not, or might not be, appropriately halfword-aligned, word-aligned, or doubleword-aligned.

See also [Aligned](#).

**UNPREDICTABLE**

In the AMBA Architecture means that the behavior cannot be relied upon.

UNPREDICTABLE behavior must not be documented or promoted as having a defined effect.

When UNPREDICTABLE appears in body text, it is always in small capitals.

**Upstream**

A transaction operates between a Requester component and one or more Subordinate components, and can pass through one or more intermediate components. At any intermediate component, for a given transaction, *upstream* means between that component and the originating Requester component, and includes the originating Requester component.

Downstream and upstream are defined relative to the transaction as a whole, not relative to individual data flows within the transaction.

See also [Downstream](#), [Requester component](#), [Peer to Peer](#), [Subordinate component](#).

**Write-Back cache**

A cache in which, when a store is permitted to store, the data is only written to the cache. Data in the cache can therefore be more up-to-date than data in main memory. Any such data is written back to next level cache or main memory when the cache line is cleaned or re-allocated. Another common term for a Write-Back cache is a *Copy-Back* cache.

**Write-Invalidate protocol**

See [Write-Invalidate protocol on page 1-23](#).