{
  "children": [
    {
      "html": "<h1>The ARM11 Architecture</h1><p>Ian Davey</p><p>Payton Oliveri</p><p>Spring 2009</p><p>CS433</p>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/0/Page/0",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/0/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h1>The ARM11 Architecture</h1>",
          "page": 0,
          "polygon": [
            [
              241.0,
              268.0
            ],
            [
              1238.0,
              268.0
            ],
            [
              1238.0,
              348.0
            ],
            [
              241.0,
              348.0
            ]
          ],
          "bbox": [
            241.0,
            268.0,
            1238.0,
            348.0
          ],
          "section_hierarchy": {},
          "images": {}
        },
        {
          "id": "/page/0/Text/1",
          "block_type": "Text",
          "html": "<p>Ian Davey</p>",
          "page": 0,
          "polygon": [
            [
              600.0,
              488.0
            ],
            [
              884.0,
              488.0
            ],
            [
              884.0,
              546.0
            ],
            [
              600.0,
              546.0
            ]
          ],
          "bbox": [
            600.0,
            488.0,
            884.0,
            546.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/2",
          "block_type": "Text",
          "html": "<p>Payton Oliveri</p>",
          "page": 0,
          "polygon": [
            [
              550.0,
              580.0
            ],
            [
              935.0,
              580.0
            ],
            [
              935.0,
              640.0
            ],
            [
              550.0,
              640.0
            ]
          ],
          "bbox": [
            550.0,
            580.0,
            935.0,
            640.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/3",
          "block_type": "Text",
          "html": "<p>Spring 2009</p>",
          "page": 0,
          "polygon": [
            [
              574.0,
              767.0
            ],
            [
              909.0,
              767.0
            ],
            [
              909.0,
              829.0
            ],
            [
              574.0,
              829.0
            ]
          ],
          "bbox": [
            574.0,
            767.0,
            909.0,
            829.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/0/Text/4",
          "block_type": "Text",
          "html": "<p>CS433</p>",
          "page": 0,
          "polygon": [
            [
              646.0,
              861.0
            ],
            [
              839.0,
              861.0
            ],
            [
              839.0,
              912.0
            ],
            [
              646.0,
              912.0
            ]
          ],
          "bbox": [
            646.0,
            861.0,
            839.0,
            912.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {}
    },
    {
      "html": "<h2>Why ARM Matters</h2><ul><li>Over 90% of the embedded market is based on the ARM architecture</li><li>ARM Ltd. makes over $100 million USD annually in royalties and licensing fees for this technology</li><li>Over two billion units are shipped each year</li><li>We will focus primarily on the ARM1176JZF-S, which is used in a number of smartphones as well as the iPod Touch</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/1/Page/1",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/1/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>Why ARM Matters</h2>",
          "page": 1,
          "polygon": [
            [
              59.0,
              54.0
            ],
            [
              775.0,
              54.0
            ],
            [
              775.0,
              139.0
            ],
            [
              59.0,
              139.0
            ]
          ],
          "bbox": [
            59.0,
            54.0,
            775.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/1/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Over 90% of the embedded market is based on the ARM architecture</li><li>ARM Ltd. makes over $100 million USD annually in royalties and licensing fees for this technology</li><li>Over two billion units are shipped each year</li><li>We will focus primarily on the ARM1176JZF-S, which is used in a number of smartphones as well as the iPod Touch</li></ul>",
          "page": 1,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1401.0,
              263.0
            ],
            [
              1401.0,
              938.0
            ],
            [
              81.0,
              938.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1401.0,
            938.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/1/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0"
      }
    },
    {
      "html": "<h2>General Overview</h2><ul><li>ARM stands for Advanced RISC Machine</li><li>The ARM11 is based on the ARMv6 instruction set architecture</li><li>Bi-endian \u2013 can operate in either little-endian or big-endian format<ul><li>Most devices today use little-endian</li></ul></li><li>Actually uses two instruction sets \u2013 the 32-bit ARM and the 16-bit Thumb</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/2/Page/2",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/2/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>General Overview</h2>",
          "page": 2,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              772.0,
              54.0
            ],
            [
              772.0,
              127.0
            ],
            [
              62.0,
              127.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            772.0,
            127.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/1/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/2/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>ARM stands for Advanced RISC Machine</li><li>The ARM11 is based on the ARMv6 instruction set architecture</li><li>Bi-endian \u2013 can operate in either little-endian or big-endian format<ul><li>Most devices today use little-endian</li></ul></li><li>Actually uses two instruction sets \u2013 the 32-bit ARM and the 16-bit Thumb</li></ul>",
          "page": 2,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1405.0,
              264.0
            ],
            [
              1405.0,
              882.0
            ],
            [
              81.0,
              882.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1405.0,
            882.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/1/SectionHeader/0"
      }
    },
    {
      "html": "<h3>ARM and Thumb</h3><ul><li>Since many embedded devices have small amounts of memory, a smaller, 16-bit instruction set can be used</li><li>This 16-bit 'Thumb' instruction set makes use of implied operands and reduced functionality to reduce code size</li><li>Thumb instructions are decoded into ARM instructions on the fly at execution time, though consuming one additional cycle</li><li>CPU is either in \"ARM state\" or \"Thumb state\"</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/3/Page/3",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/3/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>ARM and Thumb</h3>",
          "page": 3,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              726.0,
              54.0
            ],
            [
              726.0,
              127.0
            ],
            [
              62.0,
              127.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            726.0,
            127.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/3/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Since many embedded devices have small amounts of memory, a smaller, 16-bit instruction set can be used</li><li>This 16-bit 'Thumb' instruction set makes use of implied operands and reduced functionality to reduce code size</li><li>Thumb instructions are decoded into ARM instructions on the fly at execution time, though consuming one additional cycle</li><li>CPU is either in \"ARM state\" or \"Thumb state\"</li></ul>",
          "page": 3,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1396.0,
              263.0
            ],
            [
              1396.0,
              1003.0
            ],
            [
              81.0,
              1003.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1396.0,
            1003.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/3/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/2/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Registers \u2013 32-bit ARM mode</h3><ul><li>16 general-purpose registers R0-R15<ul><li>R13 is the stack pointer and is often called SP</li><li>R14 holds return addresses and is often called LR (for link register)</li><li>R15 is the program counter and is often called PC</li><li>PC is always word-aligned</li></ul></li><li>17 general-purpose \"mode-specific\" registers (used for exception handling, etc.)</li><li>7 status registers, one for each operating mode</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/4/Page/4",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/4/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Registers \u2013 32-bit ARM mode</h3>",
          "page": 4,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              1213.0,
              54.0
            ],
            [
              1213.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            1213.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/3/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/4/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>16 general-purpose registers R0-R15<ul><li>R13 is the stack pointer and is often called SP</li><li>R14 holds return addresses and is often called LR (for link register)</li><li>R15 is the program counter and is often called PC</li><li>PC is always word-aligned</li></ul></li><li>17 general-purpose \"mode-specific\" registers (used for exception handling, etc.)</li><li>7 status registers, one for each operating mode</li></ul>",
          "page": 4,
          "polygon": [
            [
              81.0,
              265.0
            ],
            [
              1401.0,
              265.0
            ],
            [
              1401.0,
              960.0
            ],
            [
              81.0,
              960.0
            ]
          ],
          "bbox": [
            81.0,
            265.0,
            1401.0,
            960.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/4/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/2/SectionHeader/0",
        "3": "/page/3/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Registers \u2013 16-bit Thumb mode</h3><ul><li>7 sets of 11 registers each<ul><li>8 general-purpose registers R0-R7</li><li>Stack pointer, link register, and program counter</li></ul></li><li>Each set is for a different operating mode</li><li>More on operating modes later</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/5/Page/5",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/5/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Registers \u2013 16-bit Thumb mode</h3>",
          "page": 5,
          "polygon": [
            [
              62.0,
              53.0
            ],
            [
              1302.0,
              53.0
            ],
            [
              1302.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            53.0,
            1302.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/4/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/5/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>7 sets of 11 registers each<ul><li>8 general-purpose registers R0-R7</li><li>Stack pointer, link register, and program counter</li></ul></li><li>Each set is for a different operating mode</li><li>More on operating modes later</li></ul>",
          "page": 5,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1329.0,
              264.0
            ],
            [
              1329.0,
              674.0
            ],
            [
              81.0,
              674.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1329.0,
            674.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/5/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/2/SectionHeader/0",
        "3": "/page/4/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Status Register Specifics</h3><ul><li>Bits 0 through 4 determine the processor operating mode</li><li>Bit 5 indicates whether the processor is in ARM or Thumb state</li><li>Bits 6 and 7 disable interrupts</li><li>Bits 28 through 31 are ALU condition code flags<ul><li>N for negative ALU result</li><li>Z for zero ALU result</li><li>C for overflow after shift operation</li><li>V for overflow after signed arithmetic operation</li></ul></li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/6/Page/6",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/6/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Status Register Specifics</h3>",
          "page": 6,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              1064.0,
              55.0
            ],
            [
              1064.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            1064.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/5/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/6/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Bits 0 through 4 determine the processor operating mode</li><li>Bit 5 indicates whether the processor is in ARM or Thumb state</li><li>Bits 6 and 7 disable interrupts</li><li>Bits 28 through 31 are ALU condition code flags<ul><li>N for negative ALU result</li><li>Z for zero ALU result</li><li>C for overflow after shift operation</li><li>V for overflow after signed arithmetic operation</li></ul></li></ul>",
          "page": 6,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1416.0,
              264.0
            ],
            [
              1416.0,
              1066.0
            ],
            [
              81.0,
              1066.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1416.0,
            1066.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/6/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/2/SectionHeader/0",
        "3": "/page/5/SectionHeader/0"
      }
    },
    {
      "html": "<h2>Operating Modes</h2><ul><li>As mentioned before, each mode has its own mode-specific registers, including a status register</li><li>The 8 modes of operation consist of 7 \"privileged modes\" - which are used to handle exceptions and ease normal resource restrictions - and 1 \"user mode\" which is used during normal operation and has all restrictions in place</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/7/Page/7",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/7/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>Operating Modes</h2>",
          "page": 7,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              747.0,
              55.0
            ],
            [
              747.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            747.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/2/SectionHeader/0",
            "3": "/page/6/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/7/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>As mentioned before, each mode has its own mode-specific registers, including a status register</li><li>The 8 modes of operation consist of 7 \"privileged modes\" - which are used to handle exceptions and ease normal resource restrictions - and 1 \"user mode\" which is used during normal operation and has all restrictions in place</li></ul>",
          "page": 7,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1393.0,
              264.0
            ],
            [
              1393.0,
              890.0
            ],
            [
              81.0,
              890.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1393.0,
            890.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/7/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/2/SectionHeader/0",
        "3": "/page/6/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Operating Modes</h3><ol><li>User \u2013 normal operation</li><li>Fast interrupt \u2013 handling of \u201cfast\u201d interrupts</li><li>Interrupt \u2013 handling of all other interrupts</li><li>Supervisor \u2013 operating system protected mode</li><li>Abort \u2013 abortion of memory access</li><li>System \u2013 operating system privileged mode</li><li>Undefined \u2013 invalid instruction in stream</li><li>Secure monitor \u2013 on-chip security features</li></ol>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/8/Page/8",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/8/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Operating Modes</h3>",
          "page": 8,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              747.0,
              55.0
            ],
            [
              747.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            747.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/7/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/8/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ol><li>User \u2013 normal operation</li><li>Fast interrupt \u2013 handling of \u201cfast\u201d interrupts</li><li>Interrupt \u2013 handling of all other interrupts</li><li>Supervisor \u2013 operating system protected mode</li><li>Abort \u2013 abortion of memory access</li><li>System \u2013 operating system privileged mode</li><li>Undefined \u2013 invalid instruction in stream</li><li>Secure monitor \u2013 on-chip security features</li></ol>",
          "page": 8,
          "polygon": [
            [
              83.0,
              264.0
            ],
            [
              1407.0,
              264.0
            ],
            [
              1407.0,
              983.0
            ],
            [
              83.0,
              983.0
            ]
          ],
          "bbox": [
            83.0,
            264.0,
            1407.0,
            983.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/7/SectionHeader/0",
            "3": "/page/8/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/7/SectionHeader/0"
      }
    },
    {
      "html": "<h2>ARM Instruction Set Architecture</h2><ul><li>Each instruction is 32 bits long</li><li>Highest four bits determine condition (indicated in status register) under which the instruction is executed<ul><li>Can discard instruction immediately after decode</li><li>Only two pipeline stages are wasted (as seen next)</li><li>Fewer branch instructions needed, smaller code</li></ul></li><li>Other fields contain operands, offset constants, and various 1-bit flags</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/9/Page/9",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/9/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>ARM Instruction Set Architecture</h2>",
          "page": 9,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              1371.0,
              54.0
            ],
            [
              1371.0,
              128.0
            ],
            [
              62.0,
              128.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            1371.0,
            128.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/7/SectionHeader/0",
            "3": "/page/8/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/9/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Each instruction is 32 bits long</li><li>Highest four bits determine condition (indicated in status register) under which the instruction is executed<ul><li>Can discard instruction immediately after decode</li><li>Only two pipeline stages are wasted (as seen next)</li><li>Fewer branch instructions needed, smaller code</li></ul></li><li>Other fields contain operands, offset constants, and various 1-bit flags</li></ul>",
          "page": 9,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1396.0,
              263.0
            ],
            [
              1396.0,
              953.0
            ],
            [
              81.0,
              953.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1396.0,
            953.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/7/SectionHeader/0",
        "3": "/page/8/SectionHeader/0"
      }
    },
    {
      "html": "<h3>The Pipeline</h3><h4><ul><li>8 stages in normal pipeline</li></ul></h4><ol><li>Fe1 \u2013 Address is sent and instruction received</li><li>Fe2 \u2013 Much of the branch prediction goes here</li><li>De \u2013 Decode instruction</li><li>Iss \u2013 Read registers and issue instruction</li><li>Sh \u2013 Perform shift operations</li><li>ALU \u2013 Perform integer operations</li><li>Sat \u2013 Saturate results</li><li>WB \u2013 Write back data to registers</li></ol>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/10/Page/10",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/10/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>The Pipeline</h3>",
          "page": 10,
          "polygon": [
            [
              59.0,
              54.0
            ],
            [
              558.0,
              54.0
            ],
            [
              558.0,
              139.0
            ],
            [
              59.0,
              139.0
            ]
          ],
          "bbox": [
            59.0,
            54.0,
            558.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/10/SectionHeader/1",
          "block_type": "SectionHeader",
          "html": "<h4><ul><li>8 stages in normal pipeline</li></ul></h4>",
          "page": 10,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              856.0,
              264.0
            ],
            [
              856.0,
              328.0
            ],
            [
              81.0,
              328.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            856.0,
            328.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/10/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/10/ListGroup/2",
          "block_type": "ListGroup",
          "html": "<ol><li>Fe1 \u2013 Address is sent and instruction received</li><li>Fe2 \u2013 Much of the branch prediction goes here</li><li>De \u2013 Decode instruction</li><li>Iss \u2013 Read registers and issue instruction</li><li>Sh \u2013 Perform shift operations</li><li>ALU \u2013 Perform integer operations</li><li>Sat \u2013 Saturate results</li><li>WB \u2013 Write back data to registers</li></ol>",
          "page": 10,
          "polygon": [
            [
              154.0,
              356.0
            ],
            [
              1311.0,
              356.0
            ],
            [
              1311.0,
              969.0
            ],
            [
              154.0,
              969.0
            ]
          ],
          "bbox": [
            154.0,
            356.0,
            1311.0,
            969.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/10/SectionHeader/0",
            "4": "/page/10/SectionHeader/1"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/9/SectionHeader/0"
      }
    },
    {
      "html": "<h4>The Shift Pipeline Stage</h4><ul><li>There are no explicit shift instructions</li><li>Each arithmetic instruction has a field to specify amount to shift one operand</li><li>ARM microarchitecture contains a barrel shifter that can perform shifts and rotates on operands</li><li>This is why the status register has separate flags of shift and arithmetic overflow</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1059.0,
        794.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1059.0,
          0.0
        ],
        [
          1059.0,
          794.0
        ],
        [
          0.0,
          794.0
        ]
      ],
      "id": "/page/11/Page/11",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/11/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h4>The Shift Pipeline Stage</h4>",
          "page": 11,
          "polygon": [
            [
              44.0,
              38.0
            ],
            [
              718.0,
              38.0
            ],
            [
              718.0,
              99.0
            ],
            [
              44.0,
              99.0
            ]
          ],
          "bbox": [
            44.0,
            38.0,
            718.0,
            99.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/10/SectionHeader/0",
            "4": "/page/10/SectionHeader/1"
          },
          "images": {}
        },
        {
          "id": "/page/11/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>There are no explicit shift instructions</li><li>Each arithmetic instruction has a field to specify amount to shift one operand</li><li>ARM microarchitecture contains a barrel shifter that can perform shifts and rotates on operands</li><li>This is why the status register has separate flags of shift and arithmetic overflow</li></ul>",
          "page": 11,
          "polygon": [
            [
              59.0,
              188.0
            ],
            [
              999.0,
              188.0
            ],
            [
              999.0,
              576.0
            ],
            [
              59.0,
              576.0
            ]
          ],
          "bbox": [
            59.0,
            188.0,
            999.0,
            576.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/10/SectionHeader/0",
            "4": "/page/11/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/9/SectionHeader/0",
        "3": "/page/10/SectionHeader/0",
        "4": "/page/10/SectionHeader/1"
      }
    },
    {
      "html": "<h3>Alternate Pipeline Paths</h3><ul><li>Sh, ALU, and Sat can be replaced with three MAC stages, which perform multiplication operations</li><li>These three stages can also be replaced with different stages for memory operations:<ol><li>ADD \u2013 calculate address</li><li>DC1 and DC2 \u2013 Access data cache</li></ol></li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/12/Page/12",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/12/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Alternate Pipeline Paths</h3>",
          "page": 12,
          "polygon": [
            [
              62.0,
              53.0
            ],
            [
              1018.0,
              53.0
            ],
            [
              1018.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            53.0,
            1018.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/10/SectionHeader/0",
            "4": "/page/11/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/12/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Sh, ALU, and Sat can be replaced with three MAC stages, which perform multiplication operations</li><li>These three stages can also be replaced with different stages for memory operations:<ol><li>ADD \u2013 calculate address</li><li>DC1 and DC2 \u2013 Access data cache</li></ol></li></ul>",
          "page": 12,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1352.0,
              263.0
            ],
            [
              1352.0,
              781.0
            ],
            [
              81.0,
              781.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1352.0,
            781.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/12/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/9/SectionHeader/0",
        "3": "/page/10/SectionHeader/0",
        "4": "/page/11/SectionHeader/0"
      }
    },
    {
      "html": "<h2>Parallelism within Instructions</h2><ul><li>Some instructions, such as those which access memory and increment a register at the same time (useful for array operations), will use both the memory access pathway and the arithmetic pathway simultaneously</li><li>If the data cache misses and there is a stall in the memory access pathway, the arithmetic pathway will continue execution anyway</li><li>This frees up the ALU and saturation stage for use with other instructions</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/13/Page/13",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/13/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>Parallelism within Instructions</h2>",
          "page": 13,
          "polygon": [
            [
              62.0,
              53.0
            ],
            [
              1265.0,
              53.0
            ],
            [
              1265.0,
              128.0
            ],
            [
              62.0,
              128.0
            ]
          ],
          "bbox": [
            62.0,
            53.0,
            1265.0,
            128.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/9/SectionHeader/0",
            "3": "/page/12/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/13/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Some instructions, such as those which access memory and increment a register at the same time (useful for array operations), will use both the memory access pathway and the arithmetic pathway simultaneously</li><li>If the data cache misses and there is a stall in the memory access pathway, the arithmetic pathway will continue execution anyway</li><li>This frees up the ALU and saturation stage for use with other instructions</li></ul>",
          "page": 13,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1401.0,
              263.0
            ],
            [
              1401.0,
              978.0
            ],
            [
              81.0,
              978.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1401.0,
            978.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/9/SectionHeader/0",
        "3": "/page/12/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Branches</h3><ul><li>Branch instruction contains condition field, link flag, and 24-bit offset field</li><li>Target must be word-aligned, so offset is effectively 26 bits</li><li>Target address calculated by sign-extending <math>PC-8+offset</math> (subtract 8 for pipeline)</li><li>Program can branch to addresses up to 32 megabytes away from PC</li><li>If the link flag is set, store old PC in LR</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/14/Page/14",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/14/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Branches</h3>",
          "page": 14,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              449.0,
              55.0
            ],
            [
              449.0,
              126.0
            ],
            [
              62.0,
              126.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            449.0,
            126.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/14/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Branch instruction contains condition field, link flag, and 24-bit offset field</li><li>Target must be word-aligned, so offset is effectively 26 bits</li><li>Target address calculated by sign-extending <math>PC-8+offset</math> (subtract 8 for pipeline)</li><li>Program can branch to addresses up to 32 megabytes away from PC</li><li>If the link flag is set, store old PC in LR</li></ul>",
          "page": 14,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1375.0,
              263.0
            ],
            [
              1375.0,
              968.0
            ],
            [
              81.0,
              968.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1375.0,
            968.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/14/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Branch Prediction</h3><ul><li>While the condition attached to every instruction helps reduce costly explicit branches, it does not eliminate them entirely</li><li>Naive approach in ARM9 is to always predict that the branch will not be taken<ul><li>This risks losing 3+ cycles if wrong!</li><li>This was more acceptable for the ARM9, which has a shorter pipeline</li></ul></li><li>Therefore, ARM11 implements more aggressive techniques</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/15/Page/15",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/15/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Branch Prediction</h3>",
          "page": 15,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              781.0,
              54.0
            ],
            [
              781.0,
              127.0
            ],
            [
              62.0,
              127.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            781.0,
            127.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/14/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/15/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>While the condition attached to every instruction helps reduce costly explicit branches, it does not eliminate them entirely</li><li>Naive approach in ARM9 is to always predict that the branch will not be taken<ul><li>This risks losing 3+ cycles if wrong!</li><li>This was more acceptable for the ARM9, which has a shorter pipeline</li></ul></li><li>Therefore, ARM11 implements more aggressive techniques</li></ul>",
          "page": 15,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1402.0,
              263.0
            ],
            [
              1402.0,
              1001.0
            ],
            [
              81.0,
              1001.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1402.0,
            1001.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0",
        "3": "/page/14/SectionHeader/0"
      }
    },
    {
      "html": "<h4>Branch Target Address Cache</h4><ul><li>Direct-mapped, 128-entry cache which keeps track of previous branch instructions (indexed by address) and their results</li><li>Stores 2-bit prediction history, which it uses to make next prediction</li><li>Lines only evicted from cache in the event of a conflict with another branch address</li><li>Very effective for loops, where branches have the same result many times in a row</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/16/Page/16",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/16/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h4>Branch Target Address Cache</h4>",
          "page": 16,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              1256.0,
              54.0
            ],
            [
              1256.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            1256.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/16/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Direct-mapped, 128-entry cache which keeps track of previous branch instructions (indexed by address) and their results</li><li>Stores 2-bit prediction history, which it uses to make next prediction</li><li>Lines only evicted from cache in the event of a conflict with another branch address</li><li>Very effective for loops, where branches have the same result many times in a row</li></ul>",
          "page": 16,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1381.0,
              263.0
            ],
            [
              1381.0,
              944.0
            ],
            [
              81.0,
              944.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1381.0,
            944.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/16/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0",
        "3": "/page/15/SectionHeader/0"
      }
    },
    {
      "html": "<h4>Static Branch Prediction</h4><ul><li>Used when BTAC entry not available</li><li>Configured in hardware to take branches with negative offsets, and not take branches with positive offsets</li><li>Once again this would help loop performance, since jumps backwards tend to follow the body of a loop</li><li>The forward-not-taken choice accommodates the way compilers handle conditionals</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/17/Page/17",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/17/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h4>Static Branch Prediction</h4>",
          "page": 17,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              1028.0,
              54.0
            ],
            [
              1028.0,
              127.0
            ],
            [
              62.0,
              127.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            1028.0,
            127.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/16/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/17/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Used when BTAC entry not available</li><li>Configured in hardware to take branches with negative offsets, and not take branches with positive offsets</li><li>Once again this would help loop performance, since jumps backwards tend to follow the body of a loop</li><li>The forward-not-taken choice accommodates the way compilers handle conditionals</li></ul>",
          "page": 17,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1383.0,
              264.0
            ],
            [
              1383.0,
              944.0
            ],
            [
              81.0,
              944.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1383.0,
            944.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/17/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0",
        "3": "/page/15/SectionHeader/0",
        "4": "/page/16/SectionHeader/0"
      }
    },
    {
      "html": "<h4>Branch Folding</h4><ul><li>Removes predicted branch instructions from the instruction stream</li><li>Branches with \"side effects\" are not subject to this optimization, since those effects (such as links into new procedures) must be carried out</li><li>Branches to branches cannot be folded, for reasons that will become clear shortly</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/18/Page/18",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/18/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h4>Branch Folding</h4>",
          "page": 18,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              676.0,
              54.0
            ],
            [
              676.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            676.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/17/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/18/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Removes predicted branch instructions from the instruction stream</li><li>Branches with \"side effects\" are not subject to this optimization, since those effects (such as links into new procedures) must be carried out</li><li>Branches to branches cannot be folded, for reasons that will become clear shortly</li></ul>",
          "page": 18,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1375.0,
              263.0
            ],
            [
              1375.0,
              782.0
            ],
            [
              81.0,
              782.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1375.0,
            782.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/18/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0",
        "3": "/page/15/SectionHeader/0",
        "4": "/page/17/SectionHeader/0"
      }
    },
    {
      "html": "<h4>What happens on misprediction?</h4><ul><li>Pipeline is flushed and correct instructions are fetched</li><li>Instructions following folded branches fail</li><li>Whenever there is a chance a folded branch has been mispredicted, address of the alternative choice must be remembered</li><li>These alternatives are retrieved if it turns out the branch was indeed mispredicted</li><li>This is why branches to branches cannot be folded \u2013 would need to store multiple alternatives</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/19/Page/19",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/19/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h4>What happens on misprediction?</h4>",
          "page": 19,
          "polygon": [
            [
              59.0,
              53.0
            ],
            [
              1372.0,
              53.0
            ],
            [
              1372.0,
              139.0
            ],
            [
              59.0,
              139.0
            ]
          ],
          "bbox": [
            59.0,
            53.0,
            1372.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/18/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/19/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Pipeline is flushed and correct instructions are fetched</li><li>Instructions following folded branches fail</li><li>Whenever there is a chance a folded branch has been mispredicted, address of the alternative choice must be remembered</li><li>These alternatives are retrieved if it turns out the branch was indeed mispredicted</li><li>This is why branches to branches cannot be folded \u2013 would need to store multiple alternatives</li></ul>",
          "page": 19,
          "polygon": [
            [
              83.0,
              206.0
            ],
            [
              1372.0,
              206.0
            ],
            [
              1372.0,
              1038.0
            ],
            [
              83.0,
              1038.0
            ]
          ],
          "bbox": [
            83.0,
            206.0,
            1372.0,
            1038.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/19/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0",
        "3": "/page/15/SectionHeader/0",
        "4": "/page/18/SectionHeader/0"
      }
    },
    {
      "html": "<h2>Memory Access</h2><ul><li>Data must be moved to registers before it can be manipulated</li><li>A memory word can be indexed by a register plus or minus a 12-bit offset constant</li><li>A halfword or byte can be indexed the same way, except the offset can only be 8 bits</li><li>Support for block-data transfer \u2013 can transfer up to 16 registers to and from memory in a single instruction</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/20/Page/20",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/20/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>Memory Access</h2>",
          "page": 20,
          "polygon": [
            [
              62.0,
              56.0
            ],
            [
              701.0,
              56.0
            ],
            [
              701.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            56.0,
            701.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/13/SectionHeader/0",
            "3": "/page/15/SectionHeader/0",
            "4": "/page/19/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/20/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Data must be moved to registers before it can be manipulated</li><li>A memory word can be indexed by a register plus or minus a 12-bit offset constant</li><li>A halfword or byte can be indexed the same way, except the offset can only be 8 bits</li><li>Support for block-data transfer \u2013 can transfer up to 16 registers to and from memory in a single instruction</li></ul>",
          "page": 20,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1357.0,
              264.0
            ],
            [
              1357.0,
              944.0
            ],
            [
              81.0,
              944.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1357.0,
            944.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/13/SectionHeader/0",
        "3": "/page/15/SectionHeader/0",
        "4": "/page/19/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Memory Hierarchy</h3><ul><li>L1 cache involves separate instruction and data caches and a write buffer<ul><li>Each cache is 4-way set-associative, ranging from 4KB to 64KB in size, with 8-word cache lines</li><li>Cache is virtually indexed, virtually tagged</li><li>Data cache misses are non-blocking</li><li>Upon eviction, if data needs to be written back to memory, the line is added to the write buffer</li><li>Write buffer handles all RAW hazards that may occur when holding needed data</li></ul></li></ul>",
      "bbox": [
        0.0,
        0.0,
        1059.0,
        794.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1059.0,
          0.0
        ],
        [
          1059.0,
          794.0
        ],
        [
          0.0,
          794.0
        ]
      ],
      "id": "/page/21/Page/21",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/21/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Memory Hierarchy</h3>",
          "page": 21,
          "polygon": [
            [
              44.0,
              38.0
            ],
            [
              563.0,
              38.0
            ],
            [
              563.0,
              99.0
            ],
            [
              44.0,
              99.0
            ]
          ],
          "bbox": [
            44.0,
            38.0,
            563.0,
            99.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/21/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>L1 cache involves separate instruction and data caches and a write buffer<ul><li>Each cache is 4-way set-associative, ranging from 4KB to 64KB in size, with 8-word cache lines</li><li>Cache is virtually indexed, virtually tagged</li><li>Data cache misses are non-blocking</li><li>Upon eviction, if data needs to be written back to memory, the line is added to the write buffer</li><li>Write buffer handles all RAW hazards that may occur when holding needed data</li></ul></li></ul>",
          "page": 21,
          "polygon": [
            [
              58.0,
              188.0
            ],
            [
              1003.0,
              188.0
            ],
            [
              1003.0,
              690.0
            ],
            [
              58.0,
              690.0
            ]
          ],
          "bbox": [
            58.0,
            188.0,
            1003.0,
            690.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/21/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/20/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Memory Hierarchy</h3><ul><li>L2 cache is off-chip<ul><li>Instruction controller, data controller, and DMA hardware on-chip each has its own 64-bit wide port, allowing for simultaneous accesses to the cache</li><li>An additional 32-bit peripheral interface connects to processor peripherals such as coprocessors</li></ul></li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/22/Page/22",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/22/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Memory Hierarchy</h3>",
          "page": 22,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              793.0,
              55.0
            ],
            [
              793.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            793.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/21/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/22/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>L2 cache is off-chip<ul><li>Instruction controller, data controller, and DMA hardware on-chip each has its own 64-bit wide port, allowing for simultaneous accesses to the cache</li><li>An additional 32-bit peripheral interface connects to processor peripherals such as coprocessors</li></ul></li></ul>",
          "page": 22,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1405.0,
              264.0
            ],
            [
              1405.0,
              666.0
            ],
            [
              81.0,
              666.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1405.0,
            666.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/22/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/20/SectionHeader/0",
        "3": "/page/21/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Translation Lookaside Buffer</h3><ul><li>Actually has two levels</li><li>First level is known as Micro-TLB<ul><li>2 10-entry, fully associative TLBs, one for I-cache, one for D-cache</li><li>Performs translation in parallel</li></ul></li><li>Second level is called the Main TLB<ul><li>Next level up when Micro-TLB misses</li><li>64-entry, 2-way set associative buffer</li><li>Also has 8-entry, fully associative section, used mainly in Secure Monitor mode</li></ul></li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/23/Page/23",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/23/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Translation Lookaside Buffer</h3>",
          "page": 23,
          "polygon": [
            [
              59.0,
              53.0
            ],
            [
              1213.0,
              53.0
            ],
            [
              1213.0,
              127.0
            ],
            [
              59.0,
              127.0
            ]
          ],
          "bbox": [
            59.0,
            53.0,
            1213.0,
            127.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/22/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/23/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Actually has two levels</li><li>First level is known as Micro-TLB<ul><li>2 10-entry, fully associative TLBs, one for I-cache, one for D-cache</li><li>Performs translation in parallel</li></ul></li><li>Second level is called the Main TLB<ul><li>Next level up when Micro-TLB misses</li><li>64-entry, 2-way set associative buffer</li><li>Also has 8-entry, fully associative section, used mainly in Secure Monitor mode</li></ul></li></ul>",
          "page": 23,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1369.0,
              264.0
            ],
            [
              1369.0,
              1034.0
            ],
            [
              81.0,
              1034.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1369.0,
            1034.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/23/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/20/SectionHeader/0",
        "3": "/page/22/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Hardware Stack</h3><ul><li>ARM also supports a hardware stack</li><li>Both upward and downward-growing stacks are supported<ul><li>Which direction to grow is specified by the flags in the push and pop instructions</li></ul></li><li>Stack is used to store activation records</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1059.0,
        794.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1059.0,
          0.0
        ],
        [
          1059.0,
          794.0
        ],
        [
          0.0,
          794.0
        ]
      ],
      "id": "/page/24/Page/24",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/24/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Hardware Stack</h3>",
          "page": 24,
          "polygon": [
            [
              44.0,
              38.0
            ],
            [
              495.0,
              38.0
            ],
            [
              495.0,
              91.0
            ],
            [
              44.0,
              91.0
            ]
          ],
          "bbox": [
            44.0,
            38.0,
            495.0,
            91.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/23/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/24/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>ARM also supports a hardware stack</li><li>Both upward and downward-growing stacks are supported<ul><li>Which direction to grow is specified by the flags in the push and pop instructions</li></ul></li><li>Stack is used to store activation records</li></ul>",
          "page": 24,
          "polygon": [
            [
              58.0,
              188.0
            ],
            [
              1000.0,
              188.0
            ],
            [
              1000.0,
              508.0
            ],
            [
              58.0,
              508.0
            ]
          ],
          "bbox": [
            58.0,
            188.0,
            1000.0,
            508.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/24/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/20/SectionHeader/0",
        "3": "/page/23/SectionHeader/0"
      }
    },
    {
      "html": "<h2>ARM Calling Conventions</h2><ul><li>R0 through R3 hold the first four arguments<ul><li>Additional arguments are passed in reverse order on the stack</li><li>Values larger than 32 bits are passed as multiple 32-bit values</li><li>Floating-point values are passed in registers on the floating-point coprocessor</li></ul></li><li>R4 through R10 hold local variables</li><li>R11 serves as the frame pointer</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/25/Page/25",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/25/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>ARM Calling Conventions</h2>",
          "page": 25,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              1082.0,
              55.0
            ],
            [
              1082.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            1082.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/20/SectionHeader/0",
            "3": "/page/24/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/25/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>R0 through R3 hold the first four arguments<ul><li>Additional arguments are passed in reverse order on the stack</li><li>Values larger than 32 bits are passed as multiple 32-bit values</li><li>Floating-point values are passed in registers on the floating-point coprocessor</li></ul></li><li>R4 through R10 hold local variables</li><li>R11 serves as the frame pointer</li></ul>",
          "page": 25,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1396.0,
              264.0
            ],
            [
              1396.0,
              928.0
            ],
            [
              81.0,
              928.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1396.0,
            928.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/25/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/20/SectionHeader/0",
        "3": "/page/24/SectionHeader/0"
      }
    },
    {
      "html": "<h2>ARM Calling Conventions</h2><ul><li>R0 through R3 hold return values<ul><li>Once again, data types larger than 32 bits are treated as multiple 32-bit values</li></ul></li><li>R12 holds intra-procedural intermediate values as well as serves as a scratchpad register between calls</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/26/Page/26",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/26/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>ARM Calling Conventions</h2>",
          "page": 26,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              1081.0,
              54.0
            ],
            [
              1081.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            1081.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/25/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/26/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>R0 through R3 hold return values<ul><li>Once again, data types larger than 32 bits are treated as multiple 32-bit values</li></ul></li><li>R12 holds intra-procedural intermediate values as well as serves as a scratchpad register between calls</li></ul>",
          "page": 26,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1390.0,
              264.0
            ],
            [
              1390.0,
              685.0
            ],
            [
              81.0,
              685.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1390.0,
            685.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/26/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/25/SectionHeader/0"
      }
    },
    {
      "html": "<h2>Exception Handling</h2><ul><li>Uses vectored exception handling</li><li>Has a separate set of mode-specific registers for each exception mode</li><li>Special instructions exist for storing and reloading processor state to and from mode-specific registers</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/27/Page/27",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/27/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>Exception Handling</h2>",
          "page": 27,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              839.0,
              54.0
            ],
            [
              839.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            839.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/26/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/27/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Uses vectored exception handling</li><li>Has a separate set of mode-specific registers for each exception mode</li><li>Special instructions exist for storing and reloading processor state to and from mode-specific registers</li></ul>",
          "page": 27,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1347.0,
              264.0
            ],
            [
              1347.0,
              716.0
            ],
            [
              81.0,
              716.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1347.0,
            716.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/27/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/26/SectionHeader/0"
      }
    },
    {
      "html": "<h3>When an Exception Occurs</h3><ul><li>Status register is copied into the mode-specific counterpart</li><li>If processor is in Thumb state, change to ARM</li><li>Store return address in mode-specific LR</li><li>Store appropriate handler address in PC</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/28/Page/28",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/28/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>When an Exception Occurs</h3>",
          "page": 28,
          "polygon": [
            [
              59.0,
              54.0
            ],
            [
              1140.0,
              54.0
            ],
            [
              1140.0,
              139.0
            ],
            [
              59.0,
              139.0
            ]
          ],
          "bbox": [
            59.0,
            54.0,
            1140.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/27/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/28/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Status register is copied into the mode-specific counterpart</li><li>If processor is in Thumb state, change to ARM</li><li>Store return address in mode-specific LR</li><li>Store appropriate handler address in PC</li></ul>",
          "page": 28,
          "polygon": [
            [
              81.0,
              263.0
            ],
            [
              1386.0,
              263.0
            ],
            [
              1386.0,
              674.0
            ],
            [
              81.0,
              674.0
            ]
          ],
          "bbox": [
            81.0,
            263.0,
            1386.0,
            674.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/27/SectionHeader/0",
            "3": "/page/28/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/27/SectionHeader/0"
      }
    },
    {
      "html": "<h3>Returning from Exceptions</h3><ul><li>Copy mode-specific status register back into user status register</li><li>Copy return address from mode-specific LR back into PC</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/29/Page/29",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/29/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h3>Returning from Exceptions</h3>",
          "page": 29,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              1133.0,
              55.0
            ],
            [
              1133.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            1133.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/27/SectionHeader/0",
            "3": "/page/28/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/29/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Copy mode-specific status register back into user status register</li><li>Copy return address from mode-specific LR back into PC</li></ul>",
          "page": 29,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1322.0,
              264.0
            ],
            [
              1322.0,
              546.0
            ],
            [
              81.0,
              546.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1322.0,
            546.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/27/SectionHeader/0",
            "3": "/page/29/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/27/SectionHeader/0",
        "3": "/page/28/SectionHeader/0"
      }
    },
    {
      "html": "<h2>System Control Coprocessor</h2><ul><li>A set of 32 readable and writeable registers</li><li>Which registers can be written depends on whether the processor is in the Secure Monitor operating mode</li><li>Used in configuring various operations ranging from DMA to cache control to performance measurement</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1059.0,
        794.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1059.0,
          0.0
        ],
        [
          1059.0,
          794.0
        ],
        [
          0.0,
          794.0
        ]
      ],
      "id": "/page/30/Page/30",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/30/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>System Control Coprocessor</h2>",
          "page": 30,
          "polygon": [
            [
              44.0,
              39.0
            ],
            [
              863.0,
              39.0
            ],
            [
              863.0,
              99.0
            ],
            [
              44.0,
              99.0
            ]
          ],
          "bbox": [
            44.0,
            39.0,
            863.0,
            99.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/27/SectionHeader/0",
            "3": "/page/29/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/30/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>A set of 32 readable and writeable registers</li><li>Which registers can be written depends on whether the processor is in the Secure Monitor operating mode</li><li>Used in configuring various operations ranging from DMA to cache control to performance measurement</li></ul>",
          "page": 30,
          "polygon": [
            [
              58.0,
              188.0
            ],
            [
              985.0,
              188.0
            ],
            [
              985.0,
              553.0
            ],
            [
              58.0,
              553.0
            ]
          ],
          "bbox": [
            58.0,
            188.0,
            985.0,
            553.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/30/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/27/SectionHeader/0",
        "3": "/page/29/SectionHeader/0"
      }
    },
    {
      "html": "<h2>SIMD Capabilities</h2><ul><li>Vector Floating-Point coprocessor performs operations on 8 single-precision or 4 double-precision values simultaneously, in parallel with CPU</li><li>Otherwise costly arithmetic operations such as square root are built into hardware</li><li>Dedicated interface to main processor</li><li>Results of compare instructions are stored in CPU status register<ul><li>Could make interface bandwidth and latency a bottleneck</li></ul></li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/31/Page/31",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/31/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>SIMD Capabilities</h2>",
          "page": 31,
          "polygon": [
            [
              62.0,
              55.0
            ],
            [
              765.0,
              55.0
            ],
            [
              765.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            55.0,
            765.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/30/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/31/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Vector Floating-Point coprocessor performs operations on 8 single-precision or 4 double-precision values simultaneously, in parallel with CPU</li><li>Otherwise costly arithmetic operations such as square root are built into hardware</li><li>Dedicated interface to main processor</li><li>Results of compare instructions are stored in CPU status register<ul><li>Could make interface bandwidth and latency a bottleneck</li></ul></li></ul>",
          "page": 31,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1401.0,
              264.0
            ],
            [
              1401.0,
              1081.0
            ],
            [
              81.0,
              1081.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1401.0,
            1081.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/31/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/30/SectionHeader/0"
      }
    },
    {
      "html": "<h2>VFP Pipelines</h2><ul><li>Each pipeline shares decode and issue stages, but otherwise works independently and in parallel</li><li>Multiply and Accumulate (FMAC) pipeline has 7 execution stages</li><li>Divide and Square root (DS) pipeline has 4 execution stages</li><li>Load/Store (LS) pipeline has 1 execution and 2 memory access stages, and is responsible for communicating with the main processor</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/32/Page/32",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/32/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>VFP Pipelines</h2>",
          "page": 32,
          "polygon": [
            [
              62.0,
              54.0
            ],
            [
              617.0,
              54.0
            ],
            [
              617.0,
              139.0
            ],
            [
              62.0,
              139.0
            ]
          ],
          "bbox": [
            62.0,
            54.0,
            617.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/31/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/32/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Each pipeline shares decode and issue stages, but otherwise works independently and in parallel</li><li>Multiply and Accumulate (FMAC) pipeline has 7 execution stages</li><li>Divide and Square root (DS) pipeline has 4 execution stages</li><li>Load/Store (LS) pipeline has 1 execution and 2 memory access stages, and is responsible for communicating with the main processor</li></ul>",
          "page": 32,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1396.0,
              264.0
            ],
            [
              1396.0,
              1012.0
            ],
            [
              81.0,
              1012.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1396.0,
            1012.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/32/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/31/SectionHeader/0"
      }
    },
    {
      "html": "<h2>VFP Registers and Data Formats</h2><ul><li>Four banks of 8 32-bit registers</li><li>Each instruction operates on a bank of registers</li><li>Consecutive pairs of registers can store double-precision floating-point data</li><li>Floating-point data format follows the IEEE standard</li></ul>",
      "bbox": [
        0.0,
        0.0,
        1489.0,
        1116.0
      ],
      "polygon": [
        [
          0.0,
          0.0
        ],
        [
          1489.0,
          0.0
        ],
        [
          1489.0,
          1116.0
        ],
        [
          0.0,
          1116.0
        ]
      ],
      "id": "/page/33/Page/33",
      "block_type": "Page",
      "children": [
        {
          "id": "/page/33/SectionHeader/0",
          "block_type": "SectionHeader",
          "html": "<h2>VFP Registers and Data Formats</h2>",
          "page": 33,
          "polygon": [
            [
              61.0,
              55.0
            ],
            [
              1352.0,
              55.0
            ],
            [
              1352.0,
              139.0
            ],
            [
              61.0,
              139.0
            ]
          ],
          "bbox": [
            61.0,
            55.0,
            1352.0,
            139.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/32/SectionHeader/0"
          },
          "images": {}
        },
        {
          "id": "/page/33/ListGroup/1",
          "block_type": "ListGroup",
          "html": "<ul><li>Four banks of 8 32-bit registers</li><li>Each instruction operates on a bank of registers</li><li>Consecutive pairs of registers can store double-precision floating-point data</li><li>Floating-point data format follows the IEEE standard</li></ul>",
          "page": 33,
          "polygon": [
            [
              81.0,
              264.0
            ],
            [
              1416.0,
              264.0
            ],
            [
              1416.0,
              734.0
            ],
            [
              81.0,
              734.0
            ]
          ],
          "bbox": [
            81.0,
            264.0,
            1416.0,
            734.0
          ],
          "section_hierarchy": {
            "1": "/page/0/SectionHeader/0",
            "2": "/page/33/SectionHeader/0"
          },
          "images": {}
        }
      ],
      "section_hierarchy": {
        "1": "/page/0/SectionHeader/0",
        "2": "/page/32/SectionHeader/0"
      }
    }
  ],
  "metadata": {
    "page_stats": [
      {
        "page_id": 0,
        "num_blocks": 5
      },
      {
        "page_id": 1,
        "num_blocks": 2
      },
      {
        "page_id": 2,
        "num_blocks": 2
      },
      {
        "page_id": 3,
        "num_blocks": 2
      },
      {
        "page_id": 4,
        "num_blocks": 2
      },
      {
        "page_id": 5,
        "num_blocks": 2
      },
      {
        "page_id": 6,
        "num_blocks": 2
      },
      {
        "page_id": 7,
        "num_blocks": 2
      },
      {
        "page_id": 8,
        "num_blocks": 2
      },
      {
        "page_id": 9,
        "num_blocks": 2
      },
      {
        "page_id": 10,
        "num_blocks": 3
      },
      {
        "page_id": 11,
        "num_blocks": 2
      },
      {
        "page_id": 12,
        "num_blocks": 2
      },
      {
        "page_id": 13,
        "num_blocks": 2
      },
      {
        "page_id": 14,
        "num_blocks": 2
      },
      {
        "page_id": 15,
        "num_blocks": 2
      },
      {
        "page_id": 16,
        "num_blocks": 2
      },
      {
        "page_id": 17,
        "num_blocks": 2
      },
      {
        "page_id": 18,
        "num_blocks": 2
      },
      {
        "page_id": 19,
        "num_blocks": 2
      },
      {
        "page_id": 20,
        "num_blocks": 2
      },
      {
        "page_id": 21,
        "num_blocks": 2
      },
      {
        "page_id": 22,
        "num_blocks": 2
      },
      {
        "page_id": 23,
        "num_blocks": 2
      },
      {
        "page_id": 24,
        "num_blocks": 2
      },
      {
        "page_id": 25,
        "num_blocks": 2
      },
      {
        "page_id": 26,
        "num_blocks": 2
      },
      {
        "page_id": 27,
        "num_blocks": 2
      },
      {
        "page_id": 28,
        "num_blocks": 2
      },
      {
        "page_id": 29,
        "num_blocks": 2
      },
      {
        "page_id": 30,
        "num_blocks": 2
      },
      {
        "page_id": 31,
        "num_blocks": 2
      },
      {
        "page_id": 32,
        "num_blocks": 2
      },
      {
        "page_id": 33,
        "num_blocks": 2
      }
    ]
  }
}